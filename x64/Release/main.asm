; Listing generated by Microsoft (R) Optimizing Compiler Version 19.25.28614.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R4?$small_any_policy@M@anyimpl@cvflann@@6B@	; cvflann::anyimpl::small_any_policy<float>::`RTTI Complete Object Locator'
PUBLIC	??_R0PEBD@8					; char const * `RTTI Type Descriptor'
PUBLIC	??_R4?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::`RTTI Complete Object Locator'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R2?$small_any_policy@_N@anyimpl@cvflann@@8	; cvflann::anyimpl::small_any_policy<bool>::`RTTI Base Class Array'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_C@_0M@LLFGKPEG@?$FLempty_any?$FN@		; `string'
PUBLIC	??_7?$small_any_policy@_N@anyimpl@cvflann@@6B@	; cvflann::anyimpl::small_any_policy<bool>::`vftable'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_C@_0L@NMCHEKHG@video1?4mp4@			; `string'
PUBLIC	??_C@_0CG@GGBHFKB@Erro?5ao?5abrir?5o?5ficheiro?5de?5v?o?$LP@ ; `string'
PUBLIC	??_C@_02LDNLGICJ@VC@				; `string'
PUBLIC	??_C@_08EGGIHDDP@gray?4pgm@			; `string'
PUBLIC	??_C@_0BC@EKELLDGB@Fase?52?5concluida?6@	; `string'
PUBLIC	??_C@_0BD@FNBPBDIB@Fase?53?5concluida?6?6@	; `string'
PUBLIC	??_C@_0CL@JDABLFJH@Frame?5?$CFd?3?5A?5matricula?5n?C?$KDo?5foi?5@ ; `string'
PUBLIC	??_C@_07LFLALKLI@FRAME?3?5@			; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_0M@NHHODHJD@Matricula?3?5@		; `string'
PUBLIC	??_C@_08JJLIBGIM@77?9QR?998@			; `string'
PUBLIC	??_C@_0BC@MEHHJOD@N?5de?5matriculas?3?5@	; `string'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	??_R2?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::`RTTI Base Class Array'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R0M@8					; float `RTTI Type Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$small_any_policy@H@anyimpl@cvflann@@8 ; cvflann::anyimpl::small_any_policy<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$typed_base_any_policy@H@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$small_any_policy@I@anyimpl@cvflann@@8 ; cvflann::anyimpl::small_any_policy<unsigned int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$small_any_policy@H@anyimpl@cvflann@@6B@	; cvflann::anyimpl::small_any_policy<int>::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AU?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any> `RTTI Type Descriptor'
PUBLIC	??_R0?AU?$small_any_policy@M@anyimpl@cvflann@@@8 ; cvflann::anyimpl::small_any_policy<float> `RTTI Type Descriptor'
PUBLIC	??_R2?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::`RTTI Base Class Array'
PUBLIC	??_R3?$small_any_policy@_N@anyimpl@cvflann@@8	; cvflann::anyimpl::small_any_policy<bool>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$small_any_policy@I@anyimpl@cvflann@@6B@	; cvflann::anyimpl::small_any_policy<unsigned int>::`vftable'
PUBLIC	??_R4?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::`RTTI Complete Object Locator'
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
PUBLIC	??_R4?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0I@8					; unsigned int `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$small_any_policy@PEBD@anyimpl@cvflann@@8 ; cvflann::anyimpl::small_any_policy<char const *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AU?$typed_base_any_policy@PEBD@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<char const *> `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::`RTTI Base Class Array'
PUBLIC	??_R0?AU?$typed_base_any_policy@M@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<float> `RTTI Type Descriptor'
PUBLIC	??_R0?AU?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t> `RTTI Type Descriptor'
PUBLIC	??_R0?AW4flann_algorithm_t@cvflann@@@8		; enum cvflann::flann_algorithm_t `RTTI Type Descriptor'
PUBLIC	??_R4?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$small_any_policy@I@anyimpl@cvflann@@8	; cvflann::anyimpl::small_any_policy<unsigned int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$small_any_policy@PEBD@anyimpl@cvflann@@8	; cvflann::anyimpl::small_any_policy<char const *>::`RTTI Base Class Array'
PUBLIC	??_R0?AU?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t> `RTTI Type Descriptor'
PUBLIC	??_R2?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Array'
PUBLIC	??_R2?$small_any_policy@M@anyimpl@cvflann@@8	; cvflann::anyimpl::small_any_policy<float>::`RTTI Base Class Array'
PUBLIC	??_7base_any_policy@anyimpl@cvflann@@6B@	; cvflann::anyimpl::base_any_policy::`vftable'
PUBLIC	??_R3?$typed_base_any_policy@H@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R1A@?0A@EA@?$small_any_policy@_N@anyimpl@cvflann@@8 ; cvflann::anyimpl::small_any_policy<bool>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$small_any_policy@I@anyimpl@cvflann@@8	; cvflann::anyimpl::small_any_policy<unsigned int>::`RTTI Base Class Array'
PUBLIC	??_R0?AU?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t> `RTTI Type Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$typed_base_any_policy@_N@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<bool>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AU?$typed_base_any_policy@I@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<unsigned int> `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$typed_base_any_policy@M@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<float>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::`vftable'
PUBLIC	??_R0?AU?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > `RTTI Type Descriptor'
PUBLIC	??_R0?AU?$small_any_policy@I@anyimpl@cvflann@@@8 ; cvflann::anyimpl::small_any_policy<unsigned int> `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4base_any_policy@anyimpl@cvflann@@6B@	; cvflann::anyimpl::base_any_policy::`RTTI Complete Object Locator'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_R3?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$small_any_policy@M@anyimpl@cvflann@@6B@	; cvflann::anyimpl::small_any_policy<float>::`vftable'
PUBLIC	??_R3?$small_any_policy@PEBD@anyimpl@cvflann@@8	; cvflann::anyimpl::small_any_policy<char const *>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$typed_base_any_policy@M@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<float>::`RTTI Base Class Array'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AW4flann_centers_init_t@cvflann@@@8	; enum cvflann::flann_centers_init_t `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$typed_base_any_policy@M@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<float>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$typed_base_any_policy@H@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<int>::`RTTI Base Class Array'
PUBLIC	??_R0?AUempty_any@anyimpl@cvflann@@@8		; cvflann::anyimpl::empty_any `RTTI Type Descriptor'
PUBLIC	??_R0?AU?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t> `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<char const *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::`RTTI Base Class Array'
PUBLIC	??_R2base_any_policy@anyimpl@cvflann@@8		; cvflann::anyimpl::base_any_policy::`RTTI Base Class Array'
PUBLIC	??_R0?AU?$typed_base_any_policy@H@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$typed_base_any_policy@PEBD@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<char const *>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3?$small_any_policy@M@anyimpl@cvflann@@8	; cvflann::anyimpl::small_any_policy<float>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8 ; cvflann::anyimpl::base_any_policy::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AU?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any> `RTTI Type Descriptor'
PUBLIC	??_R0?AU?$small_any_policy@PEBD@anyimpl@cvflann@@@8 ; cvflann::anyimpl::small_any_policy<char const *> `RTTI Type Descriptor'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R3base_any_policy@anyimpl@cvflann@@8		; cvflann::anyimpl::base_any_policy::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AU?$typed_base_any_policy@_N@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<bool> `RTTI Type Descriptor'
PUBLIC	??_7?$small_any_policy@H@anyimpl@cvflann@@6B@	; cvflann::anyimpl::small_any_policy<int>::`vftable'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$typed_base_any_policy@_N@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<bool>::`RTTI Base Class Array'
PUBLIC	??_7?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::`vftable'
PUBLIC	??_R0?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_string<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$typed_base_any_policy@_N@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<bool>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AU?$small_any_policy@_N@anyimpl@cvflann@@@8 ; cvflann::anyimpl::small_any_policy<bool> `RTTI Type Descriptor'
PUBLIC	??_R0?AU?$small_any_policy@H@anyimpl@cvflann@@@8 ; cvflann::anyimpl::small_any_policy<int> `RTTI Type Descriptor'
PUBLIC	??_R0?AUbase_any_policy@anyimpl@cvflann@@@8	; cvflann::anyimpl::base_any_policy `RTTI Type Descriptor'
PUBLIC	??_R2?$small_any_policy@H@anyimpl@cvflann@@8	; cvflann::anyimpl::small_any_policy<int>::`RTTI Base Class Array'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R2?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::`RTTI Base Class Array'
PUBLIC	??_R2?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Array'
PUBLIC	??_R4?$small_any_policy@I@anyimpl@cvflann@@6B@	; cvflann::anyimpl::small_any_policy<unsigned int>::`RTTI Complete Object Locator'
PUBLIC	??_7?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`vftable'
PUBLIC	??_R0?AU?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > `RTTI Type Descriptor'
PUBLIC	??_7?$small_any_policy@PEBD@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::small_any_policy<char const *>::`vftable'
PUBLIC	??_R3?$typed_base_any_policy@I@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$typed_base_any_policy@I@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R3?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	??_R2?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$typed_base_any_policy@I@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R2?$typed_base_any_policy@PEBD@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<char const *>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0_N@8					; bool `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$small_any_policy@M@anyimpl@cvflann@@8 ; cvflann::anyimpl::small_any_policy<float>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$small_any_policy@_N@anyimpl@cvflann@@6B@	; cvflann::anyimpl::small_any_policy<bool>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$small_any_policy@H@anyimpl@cvflann@@8	; cvflann::anyimpl::small_any_policy<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::`vftable'
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	??_R4?$small_any_policy@PEBD@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::small_any_policy<char const *>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Class Hierarchy Descriptor'
EXTRN	__imp_?imshow@cv@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV_InputArray@1@@Z:PROC
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp___std_terminate:PROC
EXTRN	__imp__purecall:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	atexit:PROC
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QEBAPEBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QEBAPEBDXZ:PROC
EXTRN	__imp___std_exception_copy:PROC
EXTRN	??_M@YAXPEAX_K1P6AX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QEBAPEBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QEBAPEBGXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?rdstate@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp__Mbrtowc:PROC
EXTRN	??_V@YAXPEAX_K@Z:PROC				; operator delete[]
EXTRN	__imp___std_exception_destroy:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp___CxxFrameHandler4:PROC
EXTRN	_purecall:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@I@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_N@Z:PROC
EXTRN	__imp_?waitKey@cv@@YAHH@Z:PROC
EXTRN	__imp_?fastFree@cv@@YAXPEAX@Z:PROC
EXTRN	__imp_?putText@cv@@YAXAEBV_InputOutputArray@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$Point_@H@1@HNV?$Scalar_@N@1@HH_N@Z:PROC
EXTRN	__imp_?destroyWindow@cv@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC
EXTRN	__imp_?deallocate@Mat@cv@@QEAAXXZ:PROC
EXTRN	__imp_?namedWindow@cv@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:PROC
EXTRN	__imp_??0VideoCapture@cv@@QEAA@XZ:PROC
EXTRN	__imp_??1VideoCapture@cv@@UEAA@XZ:PROC
EXTRN	__imp_?open@VideoCapture@cv@@UEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:PROC
EXTRN	__imp_?isOpened@VideoCapture@cv@@UEBA_NXZ:PROC
EXTRN	__imp_?release@VideoCapture@cv@@UEAAXXZ:PROC
EXTRN	__imp_?read@VideoCapture@cv@@UEAA_NAEBV_OutputArray@2@@Z:PROC
EXTRN	__imp_?get@VideoCapture@cv@@UEBANH@Z:PROC
;	COMDAT ??_R3?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8 DD 00H ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R4?$small_any_policy@PEBD@anyimpl@cvflann@@6B@
rdata$r	SEGMENT
??_R4?$small_any_policy@PEBD@anyimpl@cvflann@@6B@ DD 01H ; cvflann::anyimpl::small_any_policy<char const *>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AU?$small_any_policy@PEBD@anyimpl@cvflann@@@8
	DD	imagerel ??_R3?$small_any_policy@PEBD@anyimpl@cvflann@@8
	DD	imagerel ??_R4?$small_any_policy@PEBD@anyimpl@cvflann@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@6B@
CONST	SEGMENT
??_7?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@6B@ DQ FLAT:??_R4?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::`vftable'
	DQ	FLAT:?static_delete@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
	DQ	FLAT:?copy_from_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
	DQ	FLAT:?clone@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?move@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?get_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
	DQ	FLAT:?get_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
	DQ	FLAT:?get_size@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAA_KXZ
	DQ	FLAT:?type@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
	DQ	FLAT:?print@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
	DQ	FLAT:??_E?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R3?$small_any_policy@H@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$small_any_policy@H@anyimpl@cvflann@@8 DD 00H	; cvflann::anyimpl::small_any_policy<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$small_any_policy@H@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R4?$small_any_policy@_N@anyimpl@cvflann@@6B@
rdata$r	SEGMENT
??_R4?$small_any_policy@_N@anyimpl@cvflann@@6B@ DD 01H	; cvflann::anyimpl::small_any_policy<bool>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AU?$small_any_policy@_N@anyimpl@cvflann@@@8
	DD	imagerel ??_R3?$small_any_policy@_N@anyimpl@cvflann@@8
	DD	imagerel ??_R4?$small_any_policy@_N@anyimpl@cvflann@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$small_any_policy@M@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$small_any_policy@M@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$small_any_policy@M@anyimpl@cvflann@@@8 ; cvflann::anyimpl::small_any_policy<float>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$small_any_policy@M@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R0_N@8
data$r	SEGMENT
??_R0_N@8 DQ	FLAT:??_7type_info@@6B@			; bool `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'._N', 00H
data$r	ENDS
;	COMDAT ??_R3?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8 DD 00H ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R2?$typed_base_any_policy@PEBD@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$typed_base_any_policy@PEBD@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<char const *>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$typed_base_any_policy@I@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$typed_base_any_policy@I@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$typed_base_any_policy@I@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$typed_base_any_policy@I@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R2?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_R3?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8 DD 00H ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$typed_base_any_policy@I@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$typed_base_any_policy@I@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@I@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$typed_base_any_policy@I@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$typed_base_any_policy@I@anyimpl@cvflann@@8 DD 00H ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$typed_base_any_policy@I@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_7?$small_any_policy@PEBD@anyimpl@cvflann@@6B@
CONST	SEGMENT
??_7?$small_any_policy@PEBD@anyimpl@cvflann@@6B@ DQ FLAT:??_R4?$small_any_policy@PEBD@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::small_any_policy<char const *>::`vftable'
	DQ	FLAT:?static_delete@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEAPEAX@Z
	DQ	FLAT:?copy_from_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
	DQ	FLAT:?clone@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?move@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?get_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
	DQ	FLAT:?get_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
	DQ	FLAT:?get_size@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@UEAA_KXZ
	DQ	FLAT:?type@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
	DQ	FLAT:?print@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
	DQ	FLAT:??_E?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AU?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$big_any_policy@V?$basic_string@DU?$char_traits@D@s'
	DB	'td@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_7?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@6B@
CONST	SEGMENT
??_7?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@6B@ DQ FLAT:??_R4?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`vftable'
	DQ	FLAT:?static_delete@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
	DQ	FLAT:?copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
	DQ	FLAT:?clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?move@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?get_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
	DQ	FLAT:?get_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
	DQ	FLAT:?get_size@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAA_KXZ
	DQ	FLAT:?type@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
	DQ	FLAT:?print@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
	DQ	FLAT:??_E?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$small_any_policy@I@anyimpl@cvflann@@6B@
rdata$r	SEGMENT
??_R4?$small_any_policy@I@anyimpl@cvflann@@6B@ DD 01H	; cvflann::anyimpl::small_any_policy<unsigned int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AU?$small_any_policy@I@anyimpl@cvflann@@@8
	DD	imagerel ??_R3?$small_any_policy@I@anyimpl@cvflann@@8
	DD	imagerel ??_R4?$small_any_policy@I@anyimpl@cvflann@@6B@
rdata$r	ENDS
;	COMDAT ??_R2?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2?$small_any_policy@H@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$small_any_policy@H@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$small_any_policy@H@anyimpl@cvflann@@8 ; cvflann::anyimpl::small_any_policy<int>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@H@anyimpl@cvflann@@8
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AUbase_any_policy@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AUbase_any_policy@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::base_any_policy `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AUbase_any_policy@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AU?$small_any_policy@H@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$small_any_policy@H@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::small_any_policy<int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$small_any_policy@H@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AU?$small_any_policy@_N@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$small_any_policy@_N@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::small_any_policy<bool> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$small_any_policy@_N@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8 DD 00H ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R3?$typed_base_any_policy@_N@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$typed_base_any_policy@_N@anyimpl@cvflann@@8 DD 00H ; cvflann::anyimpl::typed_base_any_policy<bool>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$typed_base_any_policy@_N@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D'
	DB	'@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@6B@
CONST	SEGMENT
??_7?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@6B@ DQ FLAT:??_R4?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::`vftable'
	DQ	FLAT:?static_delete@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
	DQ	FLAT:?copy_from_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
	DQ	FLAT:?clone@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?move@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?get_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
	DQ	FLAT:?get_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
	DQ	FLAT:?get_size@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAA_KXZ
	DQ	FLAT:?type@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
	DQ	FLAT:?print@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
	DQ	FLAT:??_E?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R2?$typed_base_any_policy@_N@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$typed_base_any_policy@_N@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@_N@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<bool>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$small_any_policy@H@anyimpl@cvflann@@6B@
CONST	SEGMENT
??_7?$small_any_policy@H@anyimpl@cvflann@@6B@ DQ FLAT:??_R4?$small_any_policy@H@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::small_any_policy<int>::`vftable'
	DQ	FLAT:?static_delete@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEAPEAX@Z
	DQ	FLAT:?copy_from_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
	DQ	FLAT:?clone@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?move@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?get_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
	DQ	FLAT:?get_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
	DQ	FLAT:?get_size@?$typed_base_any_policy@H@anyimpl@cvflann@@UEAA_KXZ
	DQ	FLAT:?type@?$typed_base_any_policy@H@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
	DQ	FLAT:?print@?$small_any_policy@H@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
	DQ	FLAT:??_E?$small_any_policy@H@anyimpl@cvflann@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AU?$typed_base_any_policy@_N@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$typed_base_any_policy@_N@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::typed_base_any_policy<bool> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$typed_base_any_policy@_N@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R3base_any_policy@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3base_any_policy@anyimpl@cvflann@@8 DD 00H		; cvflann::anyimpl::base_any_policy::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2base_any_policy@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$small_any_policy@PEBD@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$small_any_policy@PEBD@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::small_any_policy<char const *> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$small_any_policy@PEBD@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AU?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimp'
	DB	'l@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8 DD imagerel ??_R0?AUbase_any_policy@anyimpl@cvflann@@@8 ; cvflann::anyimpl::base_any_policy::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3base_any_policy@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R3?$small_any_policy@M@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$small_any_policy@M@anyimpl@cvflann@@8 DD 00H	; cvflann::anyimpl::small_any_policy<float>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$small_any_policy@M@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
CONST	ENDS
;	COMDAT ??_R3?$typed_base_any_policy@PEBD@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$typed_base_any_policy@PEBD@anyimpl@cvflann@@8 DD 00H ; cvflann::anyimpl::typed_base_any_policy<char const *>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$typed_base_any_policy@PEBD@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R3?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8 DD 00H ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$typed_base_any_policy@H@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$typed_base_any_policy@H@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::typed_base_any_policy<int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$typed_base_any_policy@H@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R2base_any_policy@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2base_any_policy@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8 ; cvflann::anyimpl::base_any_policy::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$typed_base_any_policy@PEBD@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<char const *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$typed_base_any_policy@PEBD@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$big_any_policy@W4flann_centers_init_t@cvflann@@@an'
	DB	'yimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AUempty_any@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AUempty_any@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::empty_any `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AUempty_any@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$typed_base_any_policy@H@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$typed_base_any_policy@H@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@H@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<int>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$typed_base_any_policy@M@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$typed_base_any_policy@M@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$typed_base_any_policy@M@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<float>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$typed_base_any_policy@M@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R0?AW4flann_centers_init_t@cvflann@@@8
data$r	SEGMENT
??_R0?AW4flann_centers_init_t@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; enum cvflann::flann_centers_init_t `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AW4flann_centers_init_t@cvflann@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$typed_base_any_policy@M@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$typed_base_any_policy@M@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@M@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<float>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$small_any_policy@PEBD@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$small_any_policy@PEBD@anyimpl@cvflann@@8 DD 00H	; cvflann::anyimpl::small_any_policy<char const *>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$small_any_policy@PEBD@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_7?$small_any_policy@M@anyimpl@cvflann@@6B@
CONST	SEGMENT
??_7?$small_any_policy@M@anyimpl@cvflann@@6B@ DQ FLAT:??_R4?$small_any_policy@M@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::small_any_policy<float>::`vftable'
	DQ	FLAT:?static_delete@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEAPEAX@Z
	DQ	FLAT:?copy_from_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
	DQ	FLAT:?clone@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?move@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?get_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
	DQ	FLAT:?get_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
	DQ	FLAT:?get_size@?$typed_base_any_policy@M@anyimpl@cvflann@@UEAA_KXZ
	DQ	FLAT:?type@?$typed_base_any_policy@M@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
	DQ	FLAT:?print@?$small_any_policy@M@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
	DQ	FLAT:??_E?$small_any_policy@M@anyimpl@cvflann@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R3?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8 DD 00H ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R4base_any_policy@anyimpl@cvflann@@6B@
rdata$r	SEGMENT
??_R4base_any_policy@anyimpl@cvflann@@6B@ DD 01H	; cvflann::anyimpl::base_any_policy::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AUbase_any_policy@anyimpl@cvflann@@@8
	DD	imagerel ??_R3base_any_policy@anyimpl@cvflann@@8
	DD	imagerel ??_R4base_any_policy@anyimpl@cvflann@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$small_any_policy@I@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$small_any_policy@I@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::small_any_policy<unsigned int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$small_any_policy@I@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AU?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$typed_base_any_policy@V?$basic_string@DU?$char_tra'
	DB	'its@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_7?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@6B@
CONST	SEGMENT
??_7?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@6B@ DQ FLAT:??_R4?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::`vftable'
	DQ	FLAT:?static_delete@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
	DQ	FLAT:?copy_from_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
	DQ	FLAT:?clone@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?move@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?get_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
	DQ	FLAT:?get_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
	DQ	FLAT:?get_size@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAA_KXZ
	DQ	FLAT:?type@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
	DQ	FLAT:?print@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
	DQ	FLAT:??_E?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R3?$typed_base_any_policy@M@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$typed_base_any_policy@M@anyimpl@cvflann@@8 DD 00H ; cvflann::anyimpl::typed_base_any_policy<float>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$typed_base_any_policy@M@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$typed_base_any_policy@I@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$typed_base_any_policy@I@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::typed_base_any_policy<unsigned int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$typed_base_any_policy@I@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$typed_base_any_policy@_N@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$typed_base_any_policy@_N@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$typed_base_any_policy@_N@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<bool>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$typed_base_any_policy@_N@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R3?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8 DD 00H ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AU?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyim'
	DB	'pl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$small_any_policy@I@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$small_any_policy@I@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$small_any_policy@I@anyimpl@cvflann@@8 ; cvflann::anyimpl::small_any_policy<unsigned int>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@I@anyimpl@cvflann@@8
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$small_any_policy@_N@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$small_any_policy@_N@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$small_any_policy@_N@anyimpl@cvflann@@@8 ; cvflann::anyimpl::small_any_policy<bool>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$small_any_policy@_N@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R3?$typed_base_any_policy@H@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$typed_base_any_policy@H@anyimpl@cvflann@@8 DD 00H ; cvflann::anyimpl::typed_base_any_policy<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$typed_base_any_policy@H@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_7base_any_policy@anyimpl@cvflann@@6B@
CONST	SEGMENT
??_7base_any_policy@anyimpl@cvflann@@6B@ DQ FLAT:??_R4base_any_policy@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::base_any_policy::`vftable'
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:??_Ebase_any_policy@anyimpl@cvflann@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R2?$small_any_policy@M@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$small_any_policy@M@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$small_any_policy@M@anyimpl@cvflann@@8 ; cvflann::anyimpl::small_any_policy<float>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@M@anyimpl@cvflann@@8
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AU?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$typed_base_any_policy@W4flann_centers_init_t@cvfla'
	DB	'nn@@@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$small_any_policy@PEBD@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$small_any_policy@PEBD@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$small_any_policy@PEBD@anyimpl@cvflann@@8 ; cvflann::anyimpl::small_any_policy<char const *>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@8
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$small_any_policy@I@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$small_any_policy@I@anyimpl@cvflann@@8 DD 00H	; cvflann::anyimpl::small_any_policy<unsigned int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$small_any_policy@I@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R4?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@6B@
rdata$r	SEGMENT
??_R4?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@6B@ DD 01H ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AU?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@@8
	DD	imagerel ??_R3?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8
	DD	imagerel ??_R4?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AW4flann_algorithm_t@cvflann@@@8
data$r	SEGMENT
??_R0?AW4flann_algorithm_t@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; enum cvflann::flann_algorithm_t `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AW4flann_algorithm_t@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AU?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$typed_base_any_policy@W4flann_algorithm_t@cvflann@'
	DB	'@@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AU?$typed_base_any_policy@M@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$typed_base_any_policy@M@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::typed_base_any_policy<float> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$typed_base_any_policy@M@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$typed_base_any_policy@PEBD@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$typed_base_any_policy@PEBD@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::typed_base_any_policy<char const *> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$typed_base_any_policy@PEBD@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8 DD 00H ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$small_any_policy@PEBD@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$small_any_policy@PEBD@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$small_any_policy@PEBD@anyimpl@cvflann@@@8 ; cvflann::anyimpl::small_any_policy<char const *>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$small_any_policy@PEBD@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R0I@8
data$r	SEGMENT
??_R0I@8 DQ	FLAT:??_7type_info@@6B@			; unsigned int `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.I', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@6B@
rdata$r	SEGMENT
??_R4?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@6B@ DD 01H ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AU?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@@8
	DD	imagerel ??_R3?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@8
	DD	imagerel ??_R4?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@6B@
rdata$r	ENDS
;	COMDAT ??_R0H@8
data$r	SEGMENT
??_R0H@8 DQ	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.H', 00H
data$r	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_R4?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@6B@
rdata$r	SEGMENT
??_R4?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@6B@ DD 01H ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AU?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@@8
	DD	imagerel ??_R3?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8
	DD	imagerel ??_R4?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@6B@
rdata$r	ENDS
;	COMDAT ??_7?$small_any_policy@I@anyimpl@cvflann@@6B@
CONST	SEGMENT
??_7?$small_any_policy@I@anyimpl@cvflann@@6B@ DQ FLAT:??_R4?$small_any_policy@I@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::small_any_policy<unsigned int>::`vftable'
	DQ	FLAT:?static_delete@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEAPEAX@Z
	DQ	FLAT:?copy_from_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
	DQ	FLAT:?clone@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?move@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?get_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
	DQ	FLAT:?get_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
	DQ	FLAT:?get_size@?$typed_base_any_policy@I@anyimpl@cvflann@@UEAA_KXZ
	DQ	FLAT:?type@?$typed_base_any_policy@I@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
	DQ	FLAT:?print@?$small_any_policy@I@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
	DQ	FLAT:??_E?$small_any_policy@I@anyimpl@cvflann@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R3?$small_any_policy@_N@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R3?$small_any_policy@_N@anyimpl@cvflann@@8 DD 00H	; cvflann::anyimpl::small_any_policy<bool>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$small_any_policy@_N@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R2?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AU?$small_any_policy@M@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$small_any_policy@M@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::small_any_policy<float> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$small_any_policy@M@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AU?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@@8
data$r	SEGMENT
??_R0?AU?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@@8 DQ FLAT:??_7type_info@@6B@ ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AU?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@'
	DB	'@anyimpl@cvflann@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@@8 ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R4?$small_any_policy@H@anyimpl@cvflann@@6B@
rdata$r	SEGMENT
??_R4?$small_any_policy@H@anyimpl@cvflann@@6B@ DD 01H	; cvflann::anyimpl::small_any_policy<int>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AU?$small_any_policy@H@anyimpl@cvflann@@@8
	DD	imagerel ??_R3?$small_any_policy@H@anyimpl@cvflann@@8
	DD	imagerel ??_R4?$small_any_policy@H@anyimpl@cvflann@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$small_any_policy@I@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$small_any_policy@I@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$small_any_policy@I@anyimpl@cvflann@@@8 ; cvflann::anyimpl::small_any_policy<unsigned int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$small_any_policy@I@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$typed_base_any_policy@H@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$typed_base_any_policy@H@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$typed_base_any_policy@H@anyimpl@cvflann@@@8 ; cvflann::anyimpl::typed_base_any_policy<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$typed_base_any_policy@H@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$small_any_policy@H@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$small_any_policy@H@anyimpl@cvflann@@8 DD imagerel ??_R0?AU?$small_any_policy@H@anyimpl@cvflann@@@8 ; cvflann::anyimpl::small_any_policy<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$small_any_policy@H@anyimpl@cvflann@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0M@8
data$r	SEGMENT
??_R0M@8 DQ	FLAT:??_7type_info@@6B@			; float `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.M', 00H
data$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_R2?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@8 ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MEHHJOD@N?5de?5matriculas?3?5@
CONST	SEGMENT
??_C@_0BC@MEHHJOD@N?5de?5matriculas?3?5@ DB 'N de matriculas: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JJLIBGIM@77?9QR?998@
CONST	SEGMENT
??_C@_08JJLIBGIM@77?9QR?998@ DB '77-QR-98', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NHHODHJD@Matricula?3?5@
CONST	SEGMENT
??_C@_0M@NHHODHJD@Matricula?3?5@ DB 'Matricula: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07LFLALKLI@FRAME?3?5@
CONST	SEGMENT
??_C@_07LFLALKLI@FRAME?3?5@ DB 'FRAME: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JDABLFJH@Frame?5?$CFd?3?5A?5matricula?5n?C?$KDo?5foi?5@
CONST	SEGMENT
??_C@_0CL@JDABLFJH@Frame?5?$CFd?3?5A?5matricula?5n?C?$KDo?5foi?5@ DB 'Fra'
	DB	'me %d: A matricula n', 0c3H, 0a3H, 'o foi detectada.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FNBPBDIB@Fase?53?5concluida?6?6@
CONST	SEGMENT
??_C@_0BD@FNBPBDIB@Fase?53?5concluida?6?6@ DB 'Fase 3 concluida', 0aH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EKELLDGB@Fase?52?5concluida?6@
CONST	SEGMENT
??_C@_0BC@EKELLDGB@Fase?52?5concluida?6@ DB 'Fase 2 concluida', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EGGIHDDP@gray?4pgm@
CONST	SEGMENT
??_C@_08EGGIHDDP@gray?4pgm@ DB 'gray.pgm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02LDNLGICJ@VC@
CONST	SEGMENT
??_C@_02LDNLGICJ@VC@ DB 'VC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GGBHFKB@Erro?5ao?5abrir?5o?5ficheiro?5de?5v?o?$LP@
CONST	SEGMENT
??_C@_0CG@GGBHFKB@Erro?5ao?5abrir?5o?5ficheiro?5de?5v?o?$LP@ DB 'Erro ao '
	DB	'abrir o ficheiro de v', 0efH, 0bfH, 0bdH, 'deo!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NMCHEKHG@video1?4mp4@
CONST	SEGMENT
??_C@_0L@NMCHEKHG@video1?4mp4@ DB 'video1.mp4', 00H	; `string'
CONST	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$small_any_policy@_N@anyimpl@cvflann@@6B@
CONST	SEGMENT
??_7?$small_any_policy@_N@anyimpl@cvflann@@6B@ DQ FLAT:??_R4?$small_any_policy@_N@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::small_any_policy<bool>::`vftable'
	DQ	FLAT:?static_delete@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEAPEAX@Z
	DQ	FLAT:?copy_from_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
	DQ	FLAT:?clone@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?move@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DQ	FLAT:?get_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
	DQ	FLAT:?get_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
	DQ	FLAT:?get_size@?$typed_base_any_policy@_N@anyimpl@cvflann@@UEAA_KXZ
	DQ	FLAT:?type@?$typed_base_any_policy@_N@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
	DQ	FLAT:?print@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
	DQ	FLAT:??_E?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0M@LLFGKPEG@?$FLempty_any?$FN@
CONST	SEGMENT
??_C@_0M@LLFGKPEG@?$FLempty_any?$FN@ DB '[empty_any]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2?$small_any_policy@_N@anyimpl@cvflann@@8
rdata$r	SEGMENT
??_R2?$small_any_policy@_N@anyimpl@cvflann@@8 DD imagerel ??_R1A@?0A@EA@?$small_any_policy@_N@anyimpl@cvflann@@8 ; cvflann::anyimpl::small_any_policy<bool>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$typed_base_any_policy@_N@anyimpl@cvflann@@8
	DD	imagerel ??_R1A@?0A@EA@base_any_policy@anyimpl@cvflann@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@6B@
rdata$r	SEGMENT
??_R4?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@6B@ DD 01H ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AU?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@@8
	DD	imagerel ??_R3?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@8
	DD	imagerel ??_R4?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@6B@
rdata$r	ENDS
;	COMDAT ??_R0PEBD@8
data$r	SEGMENT
??_R0PEBD@8 DQ	FLAT:??_7type_info@@6B@			; char const * `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.PEBD', 00H
data$r	ENDS
;	COMDAT ??_R4?$small_any_policy@M@anyimpl@cvflann@@6B@
rdata$r	SEGMENT
??_R4?$small_any_policy@M@anyimpl@cvflann@@6B@ DD 01H	; cvflann::anyimpl::small_any_policy<float>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AU?$small_any_policy@M@anyimpl@cvflann@@@8
	DD	imagerel ??_R3?$small_any_policy@M@anyimpl@cvflann@@8
	DD	imagerel ??_R4?$small_any_policy@M@anyimpl@cvflann@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??1?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??1?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??_G?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEAXI@Z ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
PUBLIC	??1?$typed_base_any_policy@I@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::~typed_base_any_policy<unsigned int>
PUBLIC	??1?$small_any_policy@I@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::small_any_policy<unsigned int>::~small_any_policy<unsigned int>
PUBLIC	??_G?$small_any_policy@I@anyimpl@cvflann@@UEAAPEAXI@Z ; cvflann::anyimpl::small_any_policy<unsigned int>::`scalar deleting destructor'
PUBLIC	??1?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::~typed_base_any_policy<enum cvflann::flann_centers_init_t>
PUBLIC	??1?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::~big_any_policy<enum cvflann::flann_centers_init_t>
PUBLIC	??_G?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::`scalar deleting destructor'
PUBLIC	??1?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::~typed_base_any_policy<enum cvflann::flann_algorithm_t>
PUBLIC	??1?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::~big_any_policy<enum cvflann::flann_algorithm_t>
PUBLIC	??_G?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::`scalar deleting destructor'
PUBLIC	??1?$typed_base_any_policy@_N@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::typed_base_any_policy<bool>::~typed_base_any_policy<bool>
PUBLIC	??1?$small_any_policy@_N@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::small_any_policy<bool>::~small_any_policy<bool>
PUBLIC	??_G?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEAXI@Z ; cvflann::anyimpl::small_any_policy<bool>::`scalar deleting destructor'
PUBLIC	??1?$typed_base_any_policy@M@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::typed_base_any_policy<float>::~typed_base_any_policy<float>
PUBLIC	??1?$small_any_policy@M@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::small_any_policy<float>::~small_any_policy<float>
PUBLIC	??_G?$small_any_policy@M@anyimpl@cvflann@@UEAAPEAXI@Z ; cvflann::anyimpl::small_any_policy<float>::`scalar deleting destructor'
PUBLIC	??1?$typed_base_any_policy@H@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::typed_base_any_policy<int>::~typed_base_any_policy<int>
PUBLIC	??1?$small_any_policy@H@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::small_any_policy<int>::~small_any_policy<int>
PUBLIC	??_G?$small_any_policy@H@anyimpl@cvflann@@UEAAPEAXI@Z ; cvflann::anyimpl::small_any_policy<int>::`scalar deleting destructor'
PUBLIC	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	?get_size@?$typed_base_any_policy@H@anyimpl@cvflann@@UEAA_KXZ ; cvflann::anyimpl::typed_base_any_policy<int>::get_size
PUBLIC	?type@?$typed_base_any_policy@H@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ; cvflann::anyimpl::typed_base_any_policy<int>::type
PUBLIC	?static_delete@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<int>::static_delete
PUBLIC	?copy_from_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<int>::copy_from_value
PUBLIC	?clone@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<int>::clone
PUBLIC	?move@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<int>::move
PUBLIC	?get_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<int>::get_value
PUBLIC	?get_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ; cvflann::anyimpl::small_any_policy<int>::get_value
PUBLIC	?print@?$small_any_policy@H@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ; cvflann::anyimpl::small_any_policy<int>::print
PUBLIC	?get_size@?$typed_base_any_policy@M@anyimpl@cvflann@@UEAA_KXZ ; cvflann::anyimpl::typed_base_any_policy<float>::get_size
PUBLIC	?type@?$typed_base_any_policy@M@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ; cvflann::anyimpl::typed_base_any_policy<float>::type
PUBLIC	?static_delete@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<float>::static_delete
PUBLIC	?copy_from_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<float>::copy_from_value
PUBLIC	?clone@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<float>::clone
PUBLIC	?move@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<float>::move
PUBLIC	?get_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<float>::get_value
PUBLIC	?get_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ; cvflann::anyimpl::small_any_policy<float>::get_value
PUBLIC	?print@?$small_any_policy@M@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ; cvflann::anyimpl::small_any_policy<float>::print
PUBLIC	?get_size@?$typed_base_any_policy@_N@anyimpl@cvflann@@UEAA_KXZ ; cvflann::anyimpl::typed_base_any_policy<bool>::get_size
PUBLIC	?type@?$typed_base_any_policy@_N@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ; cvflann::anyimpl::typed_base_any_policy<bool>::type
PUBLIC	?static_delete@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<bool>::static_delete
PUBLIC	?copy_from_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<bool>::copy_from_value
PUBLIC	?clone@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<bool>::clone
PUBLIC	?move@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<bool>::move
PUBLIC	?get_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<bool>::get_value
PUBLIC	?get_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ; cvflann::anyimpl::small_any_policy<bool>::get_value
PUBLIC	?print@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ; cvflann::anyimpl::small_any_policy<bool>::print
PUBLIC	?get_size@?$typed_base_any_policy@I@anyimpl@cvflann@@UEAA_KXZ ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::get_size
PUBLIC	?type@?$typed_base_any_policy@I@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::type
PUBLIC	?static_delete@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<unsigned int>::static_delete
PUBLIC	?copy_from_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<unsigned int>::copy_from_value
PUBLIC	?clone@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<unsigned int>::clone
PUBLIC	?move@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<unsigned int>::move
PUBLIC	?get_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<unsigned int>::get_value
PUBLIC	?get_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ; cvflann::anyimpl::small_any_policy<unsigned int>::get_value
PUBLIC	?print@?$small_any_policy@I@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ; cvflann::anyimpl::small_any_policy<unsigned int>::print
PUBLIC	??1?$typed_base_any_policy@PEBD@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::typed_base_any_policy<char const *>::~typed_base_any_policy<char const *>
PUBLIC	??1?$small_any_policy@PEBD@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::small_any_policy<char const *>::~small_any_policy<char const *>
PUBLIC	??_G?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEAXI@Z ; cvflann::anyimpl::small_any_policy<char const *>::`scalar deleting destructor'
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??0?$Matx@N$03$00@cv@@QEAA@XZ			; cv::Matx<double,4,1>::Matx<double,4,1>
PUBLIC	?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXQEAD0Urandom_access_iterator_tag@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct
PUBLIC	?get_size@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@UEAA_KXZ ; cvflann::anyimpl::typed_base_any_policy<char const *>::get_size
PUBLIC	?type@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ; cvflann::anyimpl::typed_base_any_policy<char const *>::type
PUBLIC	?static_delete@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<char const *>::static_delete
PUBLIC	?copy_from_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<char const *>::copy_from_value
PUBLIC	?clone@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<char const *>::clone
PUBLIC	?move@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<char const *>::move
PUBLIC	?get_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ; cvflann::anyimpl::small_any_policy<char const *>::get_value
PUBLIC	?get_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ; cvflann::anyimpl::small_any_policy<char const *>::get_value
PUBLIC	?print@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ; cvflann::anyimpl::small_any_policy<char const *>::print
PUBLIC	??1?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::~typed_base_any_policy<cvflann::anyimpl::empty_any>
PUBLIC	??1?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAA@XZ ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::~big_any_policy<cvflann::anyimpl::empty_any>
PUBLIC	??_G?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::`scalar deleting destructor'
PUBLIC	??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const *,unsigned __int64>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
PUBLIC	??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z	; std::_UIntegral_to_buff<char,unsigned int>
PUBLIC	??0?$Vec@N$03@cv@@QEAA@XZ			; cv::Vec<double,4>::Vec<double,4>
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBAXQEADQEBD_K212@Z ; <lambda_f3a66ab6a0570788f31503db83886f49>::operator()
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?get_size@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAA_KXZ ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::get_size
PUBLIC	?type@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::type
PUBLIC	?static_delete@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::static_delete
PUBLIC	?copy_from_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::copy_from_value
PUBLIC	?clone@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::clone
PUBLIC	?move@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::move
PUBLIC	?get_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::get_value
PUBLIC	?get_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::get_value
PUBLIC	?print@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::print
PUBLIC	??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
PUBLIC	??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z	; std::_Deallocate<16,0>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits,0>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
PUBLIC	??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$_Get_unwrapped@AEAPEAD@std@@YAPEADAEAPEAD@Z	; std::_Get_unwrapped<char * &>
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??0?$Scalar_@N@cv@@QEAA@NNNN@Z			; cv::Scalar_<double>::Scalar_<double>
PUBLIC	??0?$Point_@H@cv@@QEAA@HH@Z			; cv::Point_<int>::Point_<int>
PUBLIC	??0?$Size_@H@cv@@QEAA@XZ			; cv::Size_<int>::Size_<int>
PUBLIC	??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z		; std::end<char,21>
PUBLIC	??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ; std::_Integral_to_string<char,int>
PUBLIC	??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ; std::_Adl_verify_range<char *,char *>
PUBLIC	??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z		; std::_Min_value<unsigned __int64>
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?move@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::move
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ; std::_Narrow_char_traits<char,int>::length
PUBLIC	?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Narrow_char_traits<char,int>::copy
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
PUBLIC	??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z		; std::_Max_value<unsigned __int64>
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?get_size@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAA_KXZ ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::get_size
PUBLIC	?type@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::type
PUBLIC	?static_delete@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::static_delete
PUBLIC	?copy_from_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::copy_from_value
PUBLIC	?clone@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::clone
PUBLIC	?move@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::move
PUBLIC	?get_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::get_value
PUBLIC	?get_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::get_value
PUBLIC	?get_size@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAA_KXZ ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::get_size
PUBLIC	?type@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::type
PUBLIC	?static_delete@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::static_delete
PUBLIC	?copy_from_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::copy_from_value
PUBLIC	?clone@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::clone
PUBLIC	?move@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::move
PUBLIC	?get_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::get_value
PUBLIC	?get_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::get_value
PUBLIC	?get_size@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAA_KXZ ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::get_size
PUBLIC	?type@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::type
PUBLIC	?static_delete@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::static_delete
PUBLIC	?copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::copy_from_value
PUBLIC	?clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::clone
PUBLIC	?move@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::move
PUBLIC	?get_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::get_value
PUBLIC	?get_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::get_value
PUBLIC	main
PUBLIC	vc_trab_fase1
PUBLIC	vc_binary_blob_labelling
PUBLIC	??1_InputOutputArray@cv@@QEAA@XZ		; cv::_InputOutputArray::~_InputOutputArray
PUBLIC	?print@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::print
PUBLIC	?print@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::print
PUBLIC	?print@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::print
PUBLIC	??_Gbase_any_policy@anyimpl@cvflann@@UEAAPEAXI@Z ; cvflann::anyimpl::base_any_policy::`scalar deleting destructor'
PUBLIC	??1base_any_policy@anyimpl@cvflann@@UEAA@XZ	; cvflann::anyimpl::base_any_policy::~base_any_policy
PUBLIC	??6anyimpl@cvflann@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBUempty_any@01@@Z ; cvflann::anyimpl::operator<<
PUBLIC	??0MatStep@cv@@QEAA@_K@Z			; cv::MatStep::MatStep
PUBLIC	??AMatSize@cv@@QEBAAEBHH@Z			; cv::MatSize::operator[]
PUBLIC	??0MatSize@cv@@QEAA@PEAH@Z			; cv::MatSize::MatSize
PUBLIC	?total@Mat@cv@@QEBA_KXZ				; cv::Mat::total
PUBLIC	?empty@Mat@cv@@QEBA_NXZ				; cv::Mat::empty
PUBLIC	?release@Mat@cv@@QEAAXXZ			; cv::Mat::release
PUBLIC	?__autoclassinit2@Mat@cv@@QEAAX_K@Z		; cv::Mat::__autoclassinit2
PUBLIC	??1Mat@cv@@QEAA@XZ				; cv::Mat::~Mat
PUBLIC	??0Mat@cv@@QEAA@XZ				; cv::Mat::Mat
PUBLIC	??0_InputOutputArray@cv@@QEAA@AEAVMat@1@@Z	; cv::_InputOutputArray::_InputOutputArray
PUBLIC	??1_OutputArray@cv@@QEAA@XZ			; cv::_OutputArray::~_OutputArray
PUBLIC	??0_OutputArray@cv@@QEAA@AEAVMat@1@@Z		; cv::_OutputArray::_OutputArray
PUBLIC	??0_OutputArray@cv@@QEAA@XZ			; cv::_OutputArray::_OutputArray
PUBLIC	??1_InputArray@cv@@QEAA@XZ			; cv::_InputArray::~_InputArray
PUBLIC	??0_InputArray@cv@@QEAA@AEBVMat@1@@Z		; cv::_InputArray::_InputArray
PUBLIC	??0_InputArray@cv@@QEAA@XZ			; cv::_InputArray::_InputArray
PUBLIC	?init@_InputArray@cv@@IEAAXHPEBX@Z		; cv::_InputArray::init
PUBLIC	?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ; std::to_string
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	??$_Convert_size@_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64>
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?max@?$numeric_limits@_J@std@@SA_JXZ		; std::numeric_limits<__int64>::max
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	printf
PUBLIC	_vfprintf_l
PUBLIC	__local_stdio_printf_options
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?policy@?$SinglePolicy@I@anyimpl@cvflann@@0U?$small_any_policy@I@23@A ; cvflann::anyimpl::SinglePolicy<unsigned int>::policy
PUBLIC	?policy@?$SinglePolicy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_algorithm_t@cvflann@@@23@A ; cvflann::anyimpl::SinglePolicy<enum cvflann::flann_algorithm_t>::policy
PUBLIC	?policy@?$SinglePolicy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@Uempty_any@anyimpl@cvflann@@@23@A ; cvflann::anyimpl::SinglePolicy<cvflann::anyimpl::empty_any>::policy
PUBLIC	?policy@?$SinglePolicy@_N@anyimpl@cvflann@@0U?$small_any_policy@_N@23@A ; cvflann::anyimpl::SinglePolicy<bool>::policy
PUBLIC	?policy@?$SinglePolicy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@0U?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@23@A ; cvflann::anyimpl::SinglePolicy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::policy
PUBLIC	?policy@?$SinglePolicy@H@anyimpl@cvflann@@0U?$small_any_policy@H@23@A ; cvflann::anyimpl::SinglePolicy<int>::policy
PUBLIC	?policy@?$SinglePolicy@M@anyimpl@cvflann@@0U?$small_any_policy@M@23@A ; cvflann::anyimpl::SinglePolicy<float>::policy
PUBLIC	?policy@?$SinglePolicy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_centers_init_t@cvflann@@@23@A ; cvflann::anyimpl::SinglePolicy<enum cvflann::flann_centers_init_t>::policy
PUBLIC	?policy@?$SinglePolicy@PEBD@anyimpl@cvflann@@0U?$small_any_policy@PEBD@23@A ; cvflann::anyimpl::SinglePolicy<char const *>::policy
PUBLIC	__real@3e19999a
PUBLIC	__real@3f7851ec
PUBLIC	__real@3f7c28f6
PUBLIC	__real@3f847ae147ae147b
PUBLIC	__real@3fbc28f5c28f5c29
PUBLIC	__real@3fc3333333333333
PUBLIC	__real@3fd3333333333333
PUBLIC	__real@3fd999999999999a
PUBLIC	__real@3fe2e147ae147ae1
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@41200000
PUBLIC	__real@42c80000
PUBLIC	__real@430c0000
PUBLIC	__xmm@00000000000000000000000042ff0000
PUBLIC	__xmm@0000000000000000406fe00000000000
PUBLIC	__xmm@406fe00000000000406fe00000000000
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_E?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z:PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::`vector deleting destructor'
EXTRN	??_E?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z:PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::`vector deleting destructor'
EXTRN	??_E?$small_any_policy@I@anyimpl@cvflann@@UEAAPEAXI@Z:PROC ; cvflann::anyimpl::small_any_policy<unsigned int>::`vector deleting destructor'
EXTRN	??_E?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEAXI@Z:PROC ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`vector deleting destructor'
EXTRN	??_E?$small_any_policy@H@anyimpl@cvflann@@UEAAPEAXI@Z:PROC ; cvflann::anyimpl::small_any_policy<int>::`vector deleting destructor'
EXTRN	??_Ebase_any_policy@anyimpl@cvflann@@UEAAPEAXI@Z:PROC ; cvflann::anyimpl::base_any_policy::`vector deleting destructor'
EXTRN	??_E?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEAXI@Z:PROC ; cvflann::anyimpl::small_any_policy<char const *>::`vector deleting destructor'
EXTRN	??_E?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z:PROC ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::`vector deleting destructor'
EXTRN	??_E?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEAXI@Z:PROC ; cvflann::anyimpl::small_any_policy<bool>::`vector deleting destructor'
EXTRN	??_E?$small_any_policy@M@anyimpl@cvflann@@UEAAPEAXI@Z:PROC ; cvflann::anyimpl::small_any_policy<float>::`vector deleting destructor'
EXTRN	??1VideoCapture@cv@@UEAA@XZ:PROC		; cv::VideoCapture::~VideoCapture
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__std_terminate:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	sqrt:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+43
	DD	imagerel $unwind$??_G?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$small_any_policy@I@anyimpl@cvflann@@UEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+43
	DD	imagerel $unwind$??_G?$small_any_policy@I@anyimpl@cvflann@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+43
	DD	imagerel $unwind$??_G?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+43
	DD	imagerel $unwind$??_G?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+43
	DD	imagerel $unwind$??_G?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$small_any_policy@M@anyimpl@cvflann@@UEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+43
	DD	imagerel $unwind$??_G?$small_any_policy@M@anyimpl@cvflann@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$small_any_policy@H@anyimpl@cvflann@@UEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+43
	DD	imagerel $unwind$??_G?$small_any_policy@H@anyimpl@cvflann@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+43
	DD	imagerel $unwind$??_G?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+43
	DD	imagerel $unwind$??_G?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD imagerel $LN77
	DD	imagerel $LN77+369
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+59
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DD imagerel $LN15
	DD	imagerel $LN15+50
	DD	imagerel $unwind$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBAXQEADQEBD_K212@Z DD imagerel $LN11
	DD	imagerel $LN11+86
	DD	imagerel $unwind$??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBAXQEADQEBD_K212@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN22
	DD	imagerel $LN22+48
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN22+48
	DD	imagerel $LN22+197
	DD	imagerel $chain$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN22+197
	DD	imagerel $LN22+235
	DD	imagerel $chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD imagerel $LN29
	DD	imagerel $LN29+59
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD imagerel $LN29+59
	DD	imagerel $LN29+209
	DD	imagerel $chain$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD imagerel $LN29+209
	DD	imagerel $LN29+247
	DD	imagerel $chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?static_delete@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z DD imagerel $LN8
	DD	imagerel $LN8+53
	DD	imagerel $unwind$?static_delete@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy_from_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$?copy_from_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clone@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$?clone@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD imagerel $LN18
	DD	imagerel $LN18+53
	DD	imagerel $unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD imagerel $LN24
	DD	imagerel $LN24+89
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD imagerel $LN73
	DD	imagerel $LN73+380
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN65
	DD	imagerel $LN65+303
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD imagerel $LN83
	DD	imagerel $LN83+71
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD imagerel $LN83+71
	DD	imagerel $LN83+257
	DD	imagerel $chain$1$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD imagerel $LN83+257
	DD	imagerel $LN83+399
	DD	imagerel $chain$2$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD imagerel $LN34
	DD	imagerel $LN34+148
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN99
	DD	imagerel $LN99+458
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+59
	DD	imagerel $unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DD imagerel $LN37
	DD	imagerel $LN37+224
	DD	imagerel $unwind$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN8
	DD	imagerel $LN8+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+36
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN5
	DD	imagerel $LN5+23
	DD	imagerel $unwind$?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN22
	DD	imagerel $LN22+64
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN27
	DD	imagerel $LN27+89
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD imagerel $LN44
	DD	imagerel $LN44+230
	DD	imagerel $unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z DD imagerel $LN9
	DD	imagerel $LN9+72
	DD	imagerel $unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN13
	DD	imagerel $LN13+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN13+35
	DD	imagerel $LN13+98
	DD	imagerel $chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN13+98
	DD	imagerel $LN13+128
	DD	imagerel $chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z DD imagerel $LN7
	DD	imagerel $LN7+42
	DD	imagerel $unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN77
	DD	imagerel $LN77+340
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN28
	DD	imagerel $LN28+96
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN24
	DD	imagerel $LN24+122
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+62
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z DD imagerel $LN36
	DD	imagerel $LN36+129
	DD	imagerel $unwind$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN50
	DD	imagerel $LN50+203
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN16
	DD	imagerel $LN16+59
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN31
	DD	imagerel $LN31+96
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN13
	DD	imagerel $LN13+48
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN20
	DD	imagerel $LN20+49
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN20+49
	DD	imagerel $LN20+115
	DD	imagerel $chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD imagerel $LN20+115
	DD	imagerel $LN20+142
	DD	imagerel $chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN18
	DD	imagerel $LN18+48
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN18+48
	DD	imagerel $LN18+111
	DD	imagerel $chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN18+111
	DD	imagerel $LN18+141
	DD	imagerel $chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?static_delete@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z DD imagerel $LN8
	DD	imagerel $LN8+53
	DD	imagerel $unwind$?static_delete@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy_from_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+44
	DD	imagerel $unwind$?copy_from_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clone@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+47
	DD	imagerel $unwind$?clone@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?static_delete@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z DD imagerel $LN8
	DD	imagerel $LN8+53
	DD	imagerel $unwind$?static_delete@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy_from_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+44
	DD	imagerel $unwind$?copy_from_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clone@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+47
	DD	imagerel $unwind$?clone@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?static_delete@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z DD imagerel $LN42
	DD	imagerel $LN42+133
	DD	imagerel $unwind$?static_delete@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z DD imagerel $LN8
	DD	imagerel $LN8+57
	DD	imagerel $unwind$?copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z@4HA DD imagerel ?dtor$0@?0??copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z@4HA
	DD	imagerel ?dtor$0@?0??copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DD imagerel $LN8
	DD	imagerel $LN8+57
	DD	imagerel $unwind$?clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z@4HA DD imagerel ?dtor$0@?0??clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z@4HA
	DD	imagerel ?dtor$0@?0??clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z@4HA+29
	DD	imagerel $unwind$?dtor$0@?0??clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?move@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DD imagerel $LN49
	DD	imagerel $LN49+154
	DD	imagerel $unwind$?move@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN1191
	DD	imagerel $LN1191+5646
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_trab_fase1 DD imagerel $LN25
	DD	imagerel $LN25+257
	DD	imagerel $unwind$vc_trab_fase1
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_binary_blob_labelling DD imagerel $LN176
	DD	imagerel $LN176+1138
	DD	imagerel $unwind$vc_binary_blob_labelling
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbase_any_policy@anyimpl@cvflann@@UEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+43
	DD	imagerel $unwind$??_Gbase_any_policy@anyimpl@cvflann@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??6anyimpl@cvflann@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBUempty_any@01@@Z DD imagerel $LN4
	DD	imagerel $LN4+30
	DD	imagerel $unwind$??6anyimpl@cvflann@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBUempty_any@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?release@Mat@cv@@QEAAXXZ DD imagerel $LN12
	DD	imagerel $LN12+106
	DD	imagerel $unwind$?release@Mat@cv@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Mat@cv@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+125
	DD	imagerel $unwind$??1Mat@cv@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD imagerel $LN41
	DD	imagerel $LN41+224
	DD	imagerel $unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN13
	DD	imagerel $LN13+43
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN8
	DD	imagerel $LN8+62
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN11
	DD	imagerel $LN11+62
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN11
	DD	imagerel $LN11+30
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN16
	DD	imagerel $LN16+68
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+30
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN13
	DD	imagerel $LN13+68
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+68
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+30
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN5
	DD	imagerel $LN5+51
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+85
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??policy$initializer$@?$SinglePolicy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__F?policy@?$SinglePolicy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@Uempty_any@anyimpl@cvflann@@@23@A@@YAXXZ ; ??policy$initializer$@?$SinglePolicy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA
;	COMDAT __xmm@406fe00000000000406fe00000000000
CONST	SEGMENT
__xmm@406fe00000000000406fe00000000000 DB 00H, 00H, 00H, 00H, 00H, 0e0H, 'o'
	DB	'@', 00H, 00H, 00H, 00H, 00H, 0e0H, 'o@'
CONST	ENDS
;	COMDAT __xmm@0000000000000000406fe00000000000
CONST	SEGMENT
__xmm@0000000000000000406fe00000000000 DB 00H, 00H, 00H, 00H, 00H, 0e0H, 'o'
	DB	'@', 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000000000000042ff0000
CONST	SEGMENT
__xmm@00000000000000000000000042ff0000 DB 00H, 00H, 0ffH, 'B', 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@430c0000
CONST	SEGMENT
__real@430c0000 DD 0430c0000r			; 140
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe2e147ae147ae1
CONST	SEGMENT
__real@3fe2e147ae147ae1 DQ 03fe2e147ae147ae1r	; 0.59
CONST	ENDS
;	COMDAT __real@3fd999999999999a
CONST	SEGMENT
__real@3fd999999999999a DQ 03fd999999999999ar	; 0.4
CONST	ENDS
;	COMDAT __real@3fd3333333333333
CONST	SEGMENT
__real@3fd3333333333333 DQ 03fd3333333333333r	; 0.3
CONST	ENDS
;	COMDAT __real@3fc3333333333333
CONST	SEGMENT
__real@3fc3333333333333 DQ 03fc3333333333333r	; 0.15
CONST	ENDS
;	COMDAT __real@3fbc28f5c28f5c29
CONST	SEGMENT
__real@3fbc28f5c28f5c29 DQ 03fbc28f5c28f5c29r	; 0.11
CONST	ENDS
;	COMDAT __real@3f847ae147ae147b
CONST	SEGMENT
__real@3f847ae147ae147b DQ 03f847ae147ae147br	; 0.01
CONST	ENDS
;	COMDAT __real@3f7c28f6
CONST	SEGMENT
__real@3f7c28f6 DD 03f7c28f6r			; 0.985
CONST	ENDS
;	COMDAT __real@3f7851ec
CONST	SEGMENT
__real@3f7851ec DD 03f7851ecr			; 0.97
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT ?policy@?$SinglePolicy@PEBD@anyimpl@cvflann@@0U?$small_any_policy@PEBD@23@A
_DATA	SEGMENT
?policy@?$SinglePolicy@PEBD@anyimpl@cvflann@@0U?$small_any_policy@PEBD@23@A DQ FLAT:??_7?$small_any_policy@PEBD@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::SinglePolicy<char const *>::policy
_DATA	ENDS
;	COMDAT ?policy@?$SinglePolicy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_centers_init_t@cvflann@@@23@A
_DATA	SEGMENT
?policy@?$SinglePolicy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_centers_init_t@cvflann@@@23@A DQ FLAT:??_7?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::SinglePolicy<enum cvflann::flann_centers_init_t>::policy
_DATA	ENDS
;	COMDAT ?policy@?$SinglePolicy@M@anyimpl@cvflann@@0U?$small_any_policy@M@23@A
_DATA	SEGMENT
?policy@?$SinglePolicy@M@anyimpl@cvflann@@0U?$small_any_policy@M@23@A DQ FLAT:??_7?$small_any_policy@M@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::SinglePolicy<float>::policy
_DATA	ENDS
;	COMDAT ?policy@?$SinglePolicy@H@anyimpl@cvflann@@0U?$small_any_policy@H@23@A
_DATA	SEGMENT
?policy@?$SinglePolicy@H@anyimpl@cvflann@@0U?$small_any_policy@H@23@A DQ FLAT:??_7?$small_any_policy@H@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::SinglePolicy<int>::policy
_DATA	ENDS
;	COMDAT ?policy@?$SinglePolicy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@0U?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@23@A
_DATA	SEGMENT
?policy@?$SinglePolicy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@0U?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@23@A DQ FLAT:??_7?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::SinglePolicy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::policy
_DATA	ENDS
;	COMDAT ?policy@?$SinglePolicy@_N@anyimpl@cvflann@@0U?$small_any_policy@_N@23@A
_DATA	SEGMENT
?policy@?$SinglePolicy@_N@anyimpl@cvflann@@0U?$small_any_policy@_N@23@A DQ FLAT:??_7?$small_any_policy@_N@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::SinglePolicy<bool>::policy
_DATA	ENDS
;	COMDAT ?policy@?$SinglePolicy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@Uempty_any@anyimpl@cvflann@@@23@A
_DATA	SEGMENT
?policy@?$SinglePolicy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@Uempty_any@anyimpl@cvflann@@@23@A DQ FLAT:??_7?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::SinglePolicy<cvflann::anyimpl::empty_any>::policy
_DATA	ENDS
;	COMDAT ?policy@?$SinglePolicy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_algorithm_t@cvflann@@@23@A
_DATA	SEGMENT
?policy@?$SinglePolicy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_algorithm_t@cvflann@@@23@A DQ FLAT:??_7?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::SinglePolicy<enum cvflann::flann_algorithm_t>::policy
_DATA	ENDS
;	COMDAT ?policy@?$SinglePolicy@I@anyimpl@cvflann@@0U?$small_any_policy@I@23@A
_DATA	SEGMENT
?policy@?$SinglePolicy@I@anyimpl@cvflann@@0U?$small_any_policy@I@23@A DQ FLAT:??_7?$small_any_policy@I@anyimpl@cvflann@@6B@ ; cvflann::anyimpl::SinglePolicy<unsigned int>::policy
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0exception@std@@QEAA@AEBV01@@Z DB 02H
	DB	'H'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0exception@std@@QEAA@AEBV01@@Z DB 060H
	DD	imagerel $ip2state$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0exception@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1exception@std@@UEAA@XZ DB 02H
	DB	'$'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1exception@std@@UEAA@XZ DB 060H
	DD	imagerel $ip2state$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1exception@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_Gexception@std@@UEAAPEAXI@Z DB 02H
	DB	':'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_Gexception@std@@UEAAPEAXI@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??_Gexception@std@@UEAAPEAXI@Z DB 068H
	DD	imagerel $stateUnwindMap$??_Gexception@std@@UEAAPEAXI@Z
	DD	imagerel $ip2state$??_Gexception@std@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 040a19H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??_Gexception@std@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_Gbad_alloc@std@@UEAAPEAXI@Z DB 02H
	DB	':'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_Gbad_alloc@std@@UEAAPEAXI@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DB 068H
	DD	imagerel $stateUnwindMap$??_Gbad_alloc@std@@UEAAPEAXI@Z
	DD	imagerel $ip2state$??_Gbad_alloc@std@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 040a19H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??_Gbad_alloc@std@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	'$'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_alloc@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_alloc@std@@UEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1bad_alloc@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_alloc@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DB 02H
	DB	':'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DB 068H
	DD	imagerel $stateUnwindMap$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
	DD	imagerel $ip2state$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 040a19H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	'$'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1bad_array_new_length@std@@UEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1bad_array_new_length@std@@UEAA@XZ
	DD	imagerel $ip2state$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1bad_array_new_length@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 02H
	DB	'H'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DB 068H
	DD	imagerel $stateUnwindMap$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 02H
	DB	'H'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DB 068H
	DD	imagerel $stateUnwindMap$??0bad_alloc@std@@QEAA@AEBV01@@Z
	DD	imagerel $ip2state$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1Mat@cv@@QEAA@XZ DB 02H
	DB	'H'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1Mat@cv@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1Mat@cv@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Mat@cv@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1Mat@cv@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?release@Mat@cv@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??6anyimpl@cvflann@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBUempty_any@01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbase_any_policy@anyimpl@cvflann@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_binary_blob_labelling DD 0b2919H
	DD	09b3417H
	DD	0900117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0470H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_trab_fase1 DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$main DB 'P'
	DB	0a1H, 02H
	DB	00H
	DB	0baH
	DB	04H
	DB	'('
	DB	06H
	DB	'x'
	DB	08H
	DB	'('
	DB	04H
	DB	0e9H, 02H
	DB	0cH
	DB	'.'
	DB	04H
	DB	'p'
	DB	08H
	DB	'=', 03H
	DB	0eH
	DB	0e1H, 019H
	DB	010H
	DB	0fdH, 02H
	DB	012H
	DB	0e0H
	DB	014H
	DB	'4'
	DB	016H
	DB	'N'
	DB	018H
	DB	'=', 02H
	DB	016H
	DB	0dH, 08H
	DB	0eH
	DB	0e9H, 02H
	DB	'$'
	DB	')', 02H
	DB	0eH
	DB	'%', 07H
	DB	'&'
	DB	'R'
	DB	'('
	DB	'i', 02H
	DB	'&'
	DB	'!', 04H
	DB	0eH
	DB	0a5H, 03H
	DB	','
	DB	'*'
	DB	0eH
	DB	0b2H
	DB	01aH
	DB	0eH
	DB	01cH
	DB	0eH
	DB	01eH
	DB	0eH
	DB	' '
	DB	0eH
	DB	'"'
	DB	01cH
	DB	'*'
	DB	0eH
	DB	'"'
	DB	01cH
	DB	0eH
	DB	'f'
	DB	'.'
	DB	01cH
	DB	0eH
	DB	'p'
	DB	'"'
	DB	'('
	DB	0eH
	DB	'Z'
	DB	08H
	DB	0e0H
	DB	02H
	DB	'p'
	DB	'0'
	DB	'~'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$main DB 030H
	DB	0aH
	DD	imagerel __imp_??1VideoCapture@cv@@UEAA@XZ
	DB	0c1H
	DB	010H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	010H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	05H
	DB	076H
	DD	imagerel __imp___std_terminate
	DB	0d0H
	DB	0a2H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	06H
	DB	0daH
	DD	imagerel ??1Mat@cv@@QEAA@XZ
	DB	0c1H
	DB	0eH
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	06H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	02H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	01H
	DB	05H
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	0bH
	DB	03aH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0c1H
	DB	02H
	DB	076H
	DD	imagerel __imp___std_terminate
	DB	0d6H
	DD	imagerel __imp___std_terminate
	DB	06dH
	DB	02H
	DD	imagerel __imp___std_terminate
	DB	03dH
	DB	03H
	DD	imagerel __imp___std_terminate
	DB	0dH
	DB	04H
	DD	imagerel __imp___std_terminate
	DB	065H
	DB	04H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	041H
	DB	03H
	DB	0e5H
	DB	04H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	081H
	DB	04H
	DB	042H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0e0H
	DB	076H
	DD	imagerel __imp___std_terminate
	DB	015H
	DB	06H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	021H
	DB	07H
	DB	095H
	DB	06H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DB	0a1H
	DB	07H
	DB	03dH
	DB	09H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$main DB 028H
	DD	imagerel $stateUnwindMap$main
	DD	imagerel $ip2state$main
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	0195619H
	DD	050b845H
	DD	051a83dH
	DD	0529838H
	DD	0538833H
	DD	054782eH
	DD	055682aH
	DD	0b47426H
	DD	0b36426H
	DD	0b23426H
	DD	0ac0126H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$main
	DD	04faH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?move@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DB 04H
	DB	0fcH
	DB	00H
	DB	'*'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?move@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?move@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DB 028H
	DD	imagerel $stateUnwindMap$?move@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DD	imagerel $ip2state$?move@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?move@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DD 060f11H
	DD	09640fH
	DD	06340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?move@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DB 04H
	DB	'*'
	DB	00H
	DB	' '
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DB 028H
	DD	imagerel $stateUnwindMap$?clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
	DD	imagerel $ip2state$?clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DD 040a11H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z DB 04H
	DB	'*'
	DB	00H
	DB	' '
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0??copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z DB 028H
	DD	imagerel $stateUnwindMap$?copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
	DD	imagerel $ip2state$?copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z DD 040a11H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?static_delete@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z DB 02H
	DB	0fcH
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?static_delete@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?static_delete@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z DB 028H
	DD	imagerel $stateUnwindMap$?static_delete@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
	DD	imagerel $ip2state$?static_delete@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?static_delete@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z DD 040a11H
	DD	06340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?static_delete@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clone@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy_from_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?static_delete@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clone@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy_from_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?static_delete@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 021H
	DD	imagerel $LN18
	DD	imagerel $LN18+48
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 020521H
	DD	087405H
	DD	imagerel $LN18
	DD	imagerel $LN18+48
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 040a01H
	DD	09340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+49
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD 020521H
	DD	083405H
	DD	imagerel $LN20
	DD	imagerel $LN20+49
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z DD 040a01H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	0b2H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 062b01H
	DD	0a642bH
	DD	070043208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z DB 02H
	DB	0f4H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z DB 068H
	DD	imagerel $stateUnwindMap$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z
	DD	imagerel $ip2state$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z DD 040a19H
	DD	07340aH
	DD	07006320aH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 04H
	DB	','
	DB	00H
	DB	'<'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 068H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 04H
	DB	'X'
	DB	00H
	DB	'H'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 02H
	DB	0cH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DB 028H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 040f11H
	DD	07340fH
	DD	0700b320fH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 02H
	DB	0b2H
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DB 068H
	DD	imagerel $stateUnwindMap$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
	DD	imagerel $ip2state$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 020619H
	DD	030023206H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DB 06H
	DB	0b1H, 02H
	DB	00H
	DB	0aeH
	DB	02H
	DB	08aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DB 028H
	DD	imagerel $stateUnwindMap$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
	DD	imagerel $ip2state$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 081011H
	DD	0d3410H
	DD	0f00c3210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020521H
	DD	083405H
	DD	imagerel $LN13
	DD	imagerel $LN13+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 040a01H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z DD 085001H
	DD	065450H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DB 02H
	DB	'r'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DB 028H
	DD	imagerel $stateUnwindMap$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
	DD	imagerel $ip2state$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 010411H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 02H
	DB	'6'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a01H
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0eH
	DB	0e2H
	DB	00H
	DB	'T'
	DB	02H
	DB	0b6H
	DB	06H
	DB	0d8H
	DB	04H
	DB	'L'
	DB	0aH
	DB	'('
	DB	0cH
	DB	'2'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	011H
	DB	080H
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DB	091H, 05H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 02H
	DB	04H
	DB	04H
	DB	06H
	DD	imagerel $handlerMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 0cH
	DB	0aH
	DD	imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	03aH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DB	040H
	DB	030H
	DB	038H
	DB	07eH
	DD	imagerel __imp___std_terminate
	DB	02eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DB 038H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 081619H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD 021H
	DD	imagerel $LN83
	DD	imagerel $LN83+71
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD 040a21H
	DD	0df40aH
	DD	0cc405H
	DD	imagerel $LN83
	DD	imagerel $LN83+71
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD 081001H
	DD	0e3410H
	DD	0e00c5210H
	DD	07008d00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DB 06H
	DB	019H, 02H
	DB	00H
	DB	0b0H
	DB	02H
	DB	08aH
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
	DD	imagerel $ip2state$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 081011H
	DD	0c3410H
	DD	0f00c3210H
	DD	07008e00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DB 06H
	DB	'U', 02H
	DB	00H
	DB	0e4H
	DB	02H
	DB	'f'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
	DD	imagerel $ip2state$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD 0a1411H
	DD	0e3414H
	DD	0f0103214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 02H
	DB	'\'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z DD 010419H
	DD	04204H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clone@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy_from_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?static_delete@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD 021H
	DD	imagerel $LN29
	DD	imagerel $LN29+59
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD 041521H
	DD	09f415H
	DD	086405H
	DD	imagerel $LN29
	DD	imagerel $LN29+59
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD 061001H
	DD	0b7410H
	DD	0a3410H
	DD	0e00c5210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 021H
	DD	imagerel $LN22
	DD	imagerel $LN22+48
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 041521H
	DD	096415H
	DD	083405H
	DD	imagerel $LN22
	DD	imagerel $LN22+48
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 061001H
	DD	0be410H
	DD	0a7410H
	DD	0f00c5210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBAXQEADQEBD_K212@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DB 06H
	DB	'e', 02H
	DB	00H
	DB	0d0H
	DB	02H
	DB	'f'
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DB 02H
	DB	0eH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DB 028H
	DD	imagerel $stateUnwindMap$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
	DD	imagerel $ip2state$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD 0a1611H
	DD	0d5416H
	DD	0c3416H
	DD	0f0123216H
	DD	0c00ee010H
	DD	0600b700cH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$small_any_policy@H@anyimpl@cvflann@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$small_any_policy@M@anyimpl@cvflann@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$small_any_policy@I@anyimpl@cvflann@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??policy$initializer$@?$SinglePolicy@PEBD@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__F?policy@?$SinglePolicy@PEBD@anyimpl@cvflann@@0U?$small_any_policy@PEBD@23@A@@YAXXZ ; ??policy$initializer$@?$SinglePolicy@PEBD@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??policy$initializer$@?$SinglePolicy@H@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__F?policy@?$SinglePolicy@H@anyimpl@cvflann@@0U?$small_any_policy@H@23@A@@YAXXZ ; ??policy$initializer$@?$SinglePolicy@H@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??policy$initializer$@?$SinglePolicy@M@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__F?policy@?$SinglePolicy@M@anyimpl@cvflann@@0U?$small_any_policy@M@23@A@@YAXXZ ; ??policy$initializer$@?$SinglePolicy@M@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??policy$initializer$@?$SinglePolicy@_N@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__F?policy@?$SinglePolicy@_N@anyimpl@cvflann@@0U?$small_any_policy@_N@23@A@@YAXXZ ; ??policy$initializer$@?$SinglePolicy@_N@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??policy$initializer$@?$SinglePolicy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__F?policy@?$SinglePolicy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_algorithm_t@cvflann@@@23@A@@YAXXZ ; ??policy$initializer$@?$SinglePolicy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??policy$initializer$@?$SinglePolicy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__F?policy@?$SinglePolicy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_centers_init_t@cvflann@@@23@A@@YAXXZ ; ??policy$initializer$@?$SinglePolicy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??policy$initializer$@?$SinglePolicy@I@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__F?policy@?$SinglePolicy@I@anyimpl@cvflann@@0U?$small_any_policy@I@23@A@@YAXXZ ; ??policy$initializer$@?$SinglePolicy@I@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??policy$initializer$@?$SinglePolicy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA DQ FLAT:??__F?policy@?$SinglePolicy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@0U?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@23@A@@YAXXZ ; ??policy$initializer$@?$SinglePolicy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@0P6AXXZEA@@3P6AXXZEA
CRT$XCU	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$dead$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 170  :         (void)_Size;
; 171  :         return _Where;

	mov	rax, rdx

; 172  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$dead$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 642  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, rdx
	mov	rsi, rcx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 644  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 954  :     {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	rbx, rax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;
; 961  :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
__formal$ = 24
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 66   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 67   :         _Data._What = _Message;
; 68   :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rdx
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 72   :     {

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, rdx
	mov	rbx, rcx
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rbx], rcx

; 71   :         : _Data()

	lea	rdx, QWORD PTR [rbx+8]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rdx], xmm0

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	call	QWORD PTR __imp___std_exception_copy

; 74   :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 89   :     {

$LN5:
	sub	rsp, 40					; 00000028H
	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	npad	1

; 91   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rdx, QWORD PTR [rcx+8]
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	test	rdx, rdx
	cmovne	rax, rdx

; 96   :     }

	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, edx
	mov	rdi, rcx

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	npad	1
	test	bl, 1
	je	SHORT $LN7@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN7@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 130  :     {

	lea	rax, OFFSET FLAT:??_7bad_alloc@std@@6B@

; 65   :         : _Data()

	mov	QWORD PTR [rcx+16], 0

; 130  :     {

	mov	QWORD PTR [rcx], rax

; 131  :     }

	mov	rax, rcx

; 67   :         _Data._What = _Message;

	mov	QWORD PTR [rcx+8], rdx

; 131  :     }

	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, edx
	mov	rdi, rcx

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	npad	1
	test	bl, 1
	je	SHORT $LN10@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN10@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\vcruntime_exception.h
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN8:
	sub	rsp, 40					; 00000028H

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 67   :         _Data._What = _Message;

	lea	rax, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	QWORD PTR [rcx+16], 0
	mov	QWORD PTR [rcx+8], rax

; 141  :     {

	lea	rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rcx], rax

; 142  :     }

	mov	rax, rcx
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN16:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, edx
	mov	rdi, rcx

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	npad	1
	test	bl, 1
	je	SHORT $LN13@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN13@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN11:
	sub	rsp, 40					; 00000028H

; 89   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 90   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 322  : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN4:
	sub	rsp, 72					; 00000048H

; 323  :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN3@Throw_bad_:
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, rdx
	mov	rbx, rcx

; 72   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rbx], rcx

; 71   :         : _Data()

	lea	rdx, QWORD PTR [rbx+8]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rdx], xmm0

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	call	QWORD PTR __imp___std_exception_copy
	npad	1
	lea	rax, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, rdx
	mov	rbx, rcx

; 72   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rbx], rcx

; 71   :         : _Data()

	lea	rdx, QWORD PTR [rbx+8]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rdx], xmm0

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	call	QWORD PTR __imp___std_exception_copy
	npad	1
	lea	rax, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 649  :         return LLONG_MAX;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 650  :     }

	ret	0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 8
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 51   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 106  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN13:
	sub	rsp, 40					; 00000028H

; 107  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 108  :     _Bytes += _Non_user_size;

	add	QWORD PTR [rdx], 39			; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rax, QWORD PTR [rcx]
	mov	rdx, QWORD PTR [rax-8]

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rdx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN7@Adjust_man

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	QWORD PTR [rcx], rdx

; 127  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@Adjust_man:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN11@Adjust_man:
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ??$_Convert_size@_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K@std@@YA_K_K@Z PROC			; std::_Convert_size<unsigned __int64>, COMDAT

; 987  :     // convert size_t to size_t, unchanged
; 988  :     return _Len;

	mov	rax, rcx

; 989  : }

	ret	0
??$_Convert_size@_K@std@@YA_K_K@Z ENDP			; std::_Convert_size<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 1061 :     void _Orphan_all() noexcept {}

	ret	0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT

; 1063 :     void _Alloc_proxy(const _Fake_allocator&) noexcept {}

	ret	0
?_Alloc_proxy@_Container_base0@std@@QEAAXAEBU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1251 :     _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	rax, rcx
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1254 :     void _Release() noexcept {}

	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\string
;	COMDAT ?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 32
_Buff$3 = 40
__$ArrayPad$ = 64
__$ReturnUdt$ = 96
_Val$ = 104
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z PROC ; std::to_string, COMDAT

; 504  : _NODISCARD inline string to_string(int _Val) { // convert int to string

$LN41:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	r8d, edx

; 493  :     if (_Val < 0) {

	lea	r9, QWORD PTR _Buff$3[rsp+21]

; 504  : _NODISCARD inline string to_string(int _Val) { // convert int to string

	mov	rbx, rcx

; 493  :     if (_Val < 0) {

	test	edx, edx
	jns	SHORT $LL19@to_string

; 458  :     auto _UVal_trunc = _UVal;

	neg	r8d
	npad	4
$LL14@to_string:

; 459  : #else // ^^^ _WIN64 ^^^ // vvv !_WIN64 vvv
; 460  : 
; 461  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 462  :     if
; 463  :         _CONSTEXPR_IF(_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 464  :             while (_UVal > 0xFFFFFFFFU) {
; 465  :                 auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 466  :                 _UVal /= 1000000000;
; 467  : 
; 468  :                 for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 469  :                     *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 470  :                     _UVal_chunk /= 10;
; 471  :                 }
; 472  :             }
; 473  :         }
; 474  : 
; 475  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 476  : #endif // _WIN64
; 477  : 
; 478  :     do {
; 479  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 480  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 481  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL14@to_string

; 495  :         *--_RNext = '-';

	dec	r9
	mov	BYTE PTR [r9], 45			; 0000002dH

; 496  :     } else {

	jmp	SHORT $LN7@to_string
	npad	13
$LL19@to_string:

; 479  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 480  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 481  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL19@to_string
$LN7@to_string:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2405 :         if (_First != _Last) {

	lea	rax, QWORD PTR _Buff$3[rsp+21]

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0

; 2405 :         if (_First != _Last) {

	cmp	r9, rax
	je	SHORT $LN38@to_string

; 2406 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));

	lea	r8, QWORD PTR _Buff$3[rsp+21]
	mov	rdx, r9
	sub	r8, r9
	mov	rcx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN38@to_string:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\string

; 506  : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
?to_string@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@H@Z ENDP ; std::to_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ?init@_InputArray@cv@@IEAAXHPEBX@Z
_TEXT	SEGMENT
this$ = 8
_flags$ = 16
_obj$ = 24
?init@_InputArray@cv@@IEAAXHPEBX@Z PROC			; cv::_InputArray::init, COMDAT

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	DWORD PTR [rcx], edx
	mov	QWORD PTR [rcx+8], r8
	ret	0
?init@_InputArray@cv@@IEAAXHPEBX@Z ENDP			; cv::_InputArray::init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ??0_InputArray@cv@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_InputArray@cv@@QEAA@XZ PROC				; cv::_InputArray::_InputArray, COMDAT
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	DWORD PTR [rcx], eax
	mov	QWORD PTR [rcx+8], rax

; 101  : inline _InputArray::_InputArray() { init(0 + NONE, 0); }

	mov	rax, rcx
	ret	0
??0_InputArray@cv@@QEAA@XZ ENDP				; cv::_InputArray::_InputArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ??0_InputArray@cv@@QEAA@AEBVMat@1@@Z
_TEXT	SEGMENT
this$ = 8
m$ = 16
??0_InputArray@cv@@QEAA@AEBVMat@1@@Z PROC		; cv::_InputArray::_InputArray, COMDAT
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	xor	eax, eax
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	DWORD PTR [rcx], 16842752		; 01010000H
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	mov	QWORD PTR [rcx+16], rax
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 103  : inline _InputArray::_InputArray(const Mat& m) { init(MAT+ACCESS_READ, &m); }

	mov	rax, rcx

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	QWORD PTR [rcx+8], rdx

; 103  : inline _InputArray::_InputArray(const Mat& m) { init(MAT+ACCESS_READ, &m); }

	ret	0
??0_InputArray@cv@@QEAA@AEBVMat@1@@Z ENDP		; cv::_InputArray::_InputArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ??1_InputArray@cv@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1_InputArray@cv@@QEAA@XZ PROC				; cv::_InputArray::~_InputArray, COMDAT

; 181  : inline _InputArray::~_InputArray() {}

	ret	0
??1_InputArray@cv@@QEAA@XZ ENDP				; cv::_InputArray::~_InputArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ??0_OutputArray@cv@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_OutputArray@cv@@QEAA@XZ PROC			; cv::_OutputArray::_OutputArray, COMDAT
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	xor	eax, eax
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	DWORD PTR [rcx], 33554432		; 02000000H
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	mov	QWORD PTR [rcx+16], rax
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	QWORD PTR [rcx+8], rax

; 203  : inline _OutputArray::_OutputArray() { init(NONE + ACCESS_WRITE, 0); }

	mov	rax, rcx
	ret	0
??0_OutputArray@cv@@QEAA@XZ ENDP			; cv::_OutputArray::_OutputArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ??0_OutputArray@cv@@QEAA@AEAVMat@1@@Z
_TEXT	SEGMENT
this$ = 8
m$ = 16
??0_OutputArray@cv@@QEAA@AEAVMat@1@@Z PROC		; cv::_OutputArray::_OutputArray, COMDAT
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	xor	eax, eax
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	DWORD PTR [rcx], 33619968		; 02010000H
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	mov	QWORD PTR [rcx+16], rax
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 205  : inline _OutputArray::_OutputArray(Mat& m) { init(MAT+ACCESS_WRITE, &m); }

	mov	rax, rcx

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	QWORD PTR [rcx+8], rdx

; 205  : inline _OutputArray::_OutputArray(Mat& m) { init(MAT+ACCESS_WRITE, &m); }

	ret	0
??0_OutputArray@cv@@QEAA@AEAVMat@1@@Z ENDP		; cv::_OutputArray::_OutputArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1_OutputArray@cv@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1_OutputArray@cv@@QEAA@XZ PROC			; cv::_OutputArray::~_OutputArray, COMDAT
	ret	0
??1_OutputArray@cv@@QEAA@XZ ENDP			; cv::_OutputArray::~_OutputArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ??0_InputOutputArray@cv@@QEAA@AEAVMat@1@@Z
_TEXT	SEGMENT
this$ = 8
m$ = 16
??0_InputOutputArray@cv@@QEAA@AEAVMat@1@@Z PROC		; cv::_InputOutputArray::_InputOutputArray, COMDAT
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	xor	eax, eax
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	DWORD PTR [rcx], 50397184		; 03010000H
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	mov	QWORD PTR [rcx+16], rax
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 331  : inline _InputOutputArray::_InputOutputArray(Mat& m) { init(MAT+ACCESS_RW, &m); }

	mov	rax, rcx

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	QWORD PTR [rcx+8], rdx

; 331  : inline _InputOutputArray::_InputOutputArray(Mat& m) { init(MAT+ACCESS_RW, &m); }

	ret	0
??0_InputOutputArray@cv@@QEAA@AEAVMat@1@@Z ENDP		; cv::_InputOutputArray::_InputOutputArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ??0Mat@cv@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Mat@cv@@QEAA@XZ PROC					; cv::Mat::Mat, COMDAT

; 466  :     : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),

	xor	edx, edx
	mov	QWORD PTR [rcx], 1124007936		; 42ff0000H
	mov	DWORD PTR [rcx+8], edx
	lea	rax, QWORD PTR [rcx+8]

; 1468 :     : p(_p) {}

	mov	QWORD PTR [rcx+64], rax

; 1544 :     p = buf; p[0] = s; p[1] = 0;

	lea	rax, QWORD PTR [rcx+80]
	mov	QWORD PTR [rcx+72], rax

; 466  :     : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),

	mov	DWORD PTR [rcx+12], edx
	mov	QWORD PTR [rcx+16], rdx
	mov	QWORD PTR [rcx+24], rdx
	mov	QWORD PTR [rcx+32], rdx

; 467  :       datalimit(0), allocator(0), u(0), size(&rows), step(0)

	mov	QWORD PTR [rcx+40], rdx
	mov	QWORD PTR [rcx+48], rdx
	mov	QWORD PTR [rcx+56], rdx

; 1544 :     p = buf; p[0] = s; p[1] = 0;

	mov	QWORD PTR [rax], rdx
	mov	rax, QWORD PTR [rcx+72]
	mov	QWORD PTR [rax+8], rdx

; 468  : {}

	mov	rax, rcx
	ret	0
??0Mat@cv@@QEAA@XZ ENDP					; cv::Mat::Mat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ??1Mat@cv@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Mat@cv@@QEAA@XZ PROC					; cv::Mat::~Mat, COMDAT

; 751  : {

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 865  :     if( u && CV_XADD(&u->refcount, -1) == 1 )

	mov	rcx, QWORD PTR [rcx+56]
	test	rcx, rcx
	je	SHORT $LN8@Mat
	mov	eax, -1
	lock xadd DWORD PTR [rcx+20], eax
	cmp	eax, 1
	jne	SHORT $LN8@Mat

; 866  :         deallocate();

	mov	rcx, rbx
	call	QWORD PTR __imp_?deallocate@Mat@cv@@QEAAXXZ
$LN8@Mat:

; 867  :     u = NULL;

	xor	r8d, r8d
	mov	QWORD PTR [rbx+56], r8

; 868  :     datastart = dataend = datalimit = data = 0;

	mov	QWORD PTR [rbx+16], r8
	mov	QWORD PTR [rbx+40], r8
	mov	QWORD PTR [rbx+32], r8
	mov	QWORD PTR [rbx+24], r8

; 869  :     for(int i = 0; i < dims; i++)

	mov	ecx, r8d
	cmp	DWORD PTR [rbx+4], ecx
	jle	SHORT $LN6@Mat
	mov	edx, r8d
	npad	4
$LL7@Mat:

; 870  :         size.p[i] = 0;

	mov	rax, QWORD PTR [rbx+64]
	mov	DWORD PTR [rdx+rax], r8d

; 869  :     for(int i = 0; i < dims; i++)

	inc	ecx
	lea	rdx, QWORD PTR [rdx+4]
	cmp	ecx, DWORD PTR [rbx+4]
	jl	SHORT $LL7@Mat
$LN6@Mat:

; 752  :     release();
; 753  :     if( step.p != step.buf )

	mov	rcx, QWORD PTR [rbx+72]
	lea	rax, QWORD PTR [rbx+80]
	cmp	rcx, rax
	je	SHORT $LN2@Mat

; 754  :         fastFree(step.p);

	call	QWORD PTR __imp_?fastFree@cv@@YAXPEAX@Z
	npad	1
$LN2@Mat:

; 755  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1Mat@cv@@QEAA@XZ ENDP					; cv::Mat::~Mat
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@Mat@cv@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@Mat@cv@@QEAAX_K@Z PROC		; cv::Mat::__autoclassinit2, COMDAT
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [rcx], xmm0
	movups	XMMWORD PTR [rcx+16], xmm0
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	XMMWORD PTR [rcx+48], xmm0
	movups	XMMWORD PTR [rcx+64], xmm0
	movups	XMMWORD PTR [rcx+80], xmm0
	ret	0
?__autoclassinit2@Mat@cv@@QEAAX_K@Z ENDP		; cv::Mat::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ?release@Mat@cv@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?release@Mat@cv@@QEAAXXZ PROC				; cv::Mat::release, COMDAT

; 864  : {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 865  :     if( u && CV_XADD(&u->refcount, -1) == 1 )

	mov	rcx, QWORD PTR [rcx+56]
	test	rcx, rcx
	je	SHORT $LN5@release
	mov	eax, -1
	lock xadd DWORD PTR [rcx+20], eax
	cmp	eax, 1
	jne	SHORT $LN5@release

; 866  :         deallocate();

	mov	rcx, rbx
	call	QWORD PTR __imp_?deallocate@Mat@cv@@QEAAXXZ
$LN5@release:

; 867  :     u = NULL;

	xor	r8d, r8d

; 868  :     datastart = dataend = datalimit = data = 0;
; 869  :     for(int i = 0; i < dims; i++)

	mov	ecx, r8d
	mov	QWORD PTR [rbx+56], r8
	mov	QWORD PTR [rbx+16], r8
	mov	QWORD PTR [rbx+40], r8
	mov	QWORD PTR [rbx+32], r8
	mov	QWORD PTR [rbx+24], r8
	cmp	DWORD PTR [rbx+4], ecx
	jle	SHORT $LN3@release
	mov	edx, r8d
	npad	4
$LL4@release:

; 870  :         size.p[i] = 0;

	mov	rax, QWORD PTR [rbx+64]
	lea	rdx, QWORD PTR [rdx+4]
	inc	ecx
	mov	DWORD PTR [rdx+rax-4], r8d
	cmp	ecx, DWORD PTR [rbx+4]
	jl	SHORT $LL4@release
$LN3@release:

; 871  : #ifdef _DEBUG
; 872  :     flags = MAGIC_VAL;
; 873  :     dims = rows = cols = 0;
; 874  :     if(step.p != step.buf)
; 875  :     {
; 876  :         fastFree(step.p);
; 877  :         step.p = step.buf;
; 878  :         size.p = &rows;
; 879  :     }
; 880  : #endif
; 881  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?release@Mat@cv@@QEAAXXZ ENDP				; cv::Mat::release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ?empty@Mat@cv@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@Mat@cv@@QEBA_NXZ PROC				; cv::Mat::empty, COMDAT

; 960  :     return data == 0 || total() == 0 || dims == 0;

	cmp	QWORD PTR [rcx+16], 0
	je	SHORT $LN3@empty

; 966  :     if( dims <= 2 )

	movsxd	r9, DWORD PTR [rcx+4]
	cmp	r9d, 2
	jg	SHORT $LN9@empty

; 967  :         return (size_t)rows * cols;

	movsxd	rdx, DWORD PTR [rcx+12]
	movsxd	rax, DWORD PTR [rcx+8]
	imul	rdx, rax
	jmp	SHORT $LN5@empty
$LN9@empty:

; 968  :     size_t p = 1;

	mov	edx, 1

; 969  :     for( int i = 0; i < dims; i++ )

	mov	r8, r9
	test	r9d, r9d
	jle	SHORT $LN5@empty

; 1490 :     return p[i];

	mov	rcx, QWORD PTR [rcx+64]
$LL15@empty:

; 970  :         p *= size[i];

	movsxd	rax, DWORD PTR [rcx]
	lea	rcx, QWORD PTR [rcx+4]
	imul	rdx, rax
	sub	r8, 1
	jne	SHORT $LL15@empty
$LN5@empty:

; 960  :     return data == 0 || total() == 0 || dims == 0;

	test	rdx, rdx
	je	SHORT $LN3@empty
	test	r9d, r9d
	je	SHORT $LN3@empty
	xor	al, al

; 961  : }

	ret	0
$LN3@empty:

; 960  :     return data == 0 || total() == 0 || dims == 0;

	mov	al, 1

; 961  : }

	ret	0
?empty@Mat@cv@@QEBA_NXZ ENDP				; cv::Mat::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ?total@Mat@cv@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?total@Mat@cv@@QEBA_KXZ PROC				; cv::Mat::total, COMDAT

; 966  :     if( dims <= 2 )

	movsxd	rdx, DWORD PTR [rcx+4]
	cmp	edx, 2
	jg	SHORT $LN5@total

; 967  :         return (size_t)rows * cols;

	movsxd	rax, DWORD PTR [rcx+12]
	movsxd	rcx, DWORD PTR [rcx+8]
	imul	rax, rcx

; 971  :     return p;
; 972  : }

	ret	0
$LN5@total:

; 968  :     size_t p = 1;

	mov	eax, 1

; 969  :     for( int i = 0; i < dims; i++ )

	mov	r8, rdx
	test	edx, edx
	jle	SHORT $LN3@total

; 1490 :     return p[i];

	mov	rdx, QWORD PTR [rcx+64]
	npad	10
$LL11@total:

; 970  :         p *= size[i];

	movsxd	rcx, DWORD PTR [rdx]
	lea	rdx, QWORD PTR [rdx+4]
	imul	rax, rcx
	sub	r8, 1
	jne	SHORT $LL11@total
$LN3@total:

; 971  :     return p;
; 972  : }

	ret	0
?total@Mat@cv@@QEBA_KXZ ENDP				; cv::Mat::total
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ??0MatSize@cv@@QEAA@PEAH@Z
_TEXT	SEGMENT
this$ = 8
_p$ = 16
??0MatSize@cv@@QEAA@PEAH@Z PROC				; cv::MatSize::MatSize, COMDAT

; 1468 :     : p(_p) {}

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx
	ret	0
??0MatSize@cv@@QEAA@PEAH@Z ENDP				; cv::MatSize::MatSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ??AMatSize@cv@@QEBAAEBHH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??AMatSize@cv@@QEBAAEBHH@Z PROC				; cv::MatSize::operator[], COMDAT

; 1486 :     CV_DbgAssert(i < dims());
; 1487 : #ifdef __OPENCV_BUILD
; 1488 :     CV_DbgAssert(i >= 0);
; 1489 : #endif
; 1490 :     return p[i];

	mov	rax, QWORD PTR [rcx]
	movsxd	rdx, edx
	lea	rax, QWORD PTR [rax+rdx*4]

; 1491 : }

	ret	0
??AMatSize@cv@@QEBAAEBHH@Z ENDP				; cv::MatSize::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
;	COMDAT ??0MatStep@cv@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 8
s$dead$ = 16
??0MatStep@cv@@QEAA@_K@Z PROC				; cv::MatStep::MatStep, COMDAT

; 1544 :     p = buf; p[0] = s; p[1] = 0;

	lea	rax, QWORD PTR [rcx+8]
	xor	edx, edx
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx

; 1545 : }

	mov	rax, rcx
	ret	0
??0MatStep@cv@@QEAA@_K@Z ENDP				; cv::MatStep::MatStep
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ??6anyimpl@cvflann@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBUempty_any@01@@Z
_TEXT	SEGMENT
out$ = 48
__formal$dead$ = 56
??6anyimpl@cvflann@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBUempty_any@01@@Z PROC ; cvflann::anyimpl::operator<<, COMDAT

; 37   : {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 38   :     out << "[empty_any]";

	lea	rdx, OFFSET FLAT:??_C@_0M@LLFGKPEG@?$FLempty_any?$FN@
	mov	rbx, rcx
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 39   :     return out;

	mov	rax, rbx

; 40   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??6anyimpl@cvflann@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEAV23@AEBUempty_any@01@@Z ENDP ; cvflann::anyimpl::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ??1base_any_policy@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1base_any_policy@anyimpl@cvflann@@UEAA@XZ PROC	; cvflann::anyimpl::base_any_policy::~base_any_policy, COMDAT

; 53   :     virtual ~base_any_policy() {}

	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1base_any_policy@anyimpl@cvflann@@UEAA@XZ ENDP	; cvflann::anyimpl::base_any_policy::~base_any_policy
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbase_any_policy@anyimpl@cvflann@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbase_any_policy@anyimpl@cvflann@@UEAAPEAXI@Z PROC	; cvflann::anyimpl::base_any_policy::`scalar deleting destructor', COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN4@scalar
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_Gbase_any_policy@anyimpl@cvflann@@UEAAPEAXI@Z ENDP	; cvflann::anyimpl::base_any_policy::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?print@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
out$ = 16
src$ = 24
?print@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::print, COMDAT

; 107  :     out << int(*reinterpret_cast<flann_centers_init_t const*>(*src));

	mov	rax, QWORD PTR [r8]
	mov	rcx, rdx
	mov	edx, DWORD PTR [rax]
	rex_jmp	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
?print@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::print
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?print@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
out$ = 16
src$ = 24
?print@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::print, COMDAT

; 112  :     out << int(*reinterpret_cast<flann_algorithm_t const*>(*src));

	mov	rax, QWORD PTR [r8]
	mov	rcx, rdx
	mov	edx, DWORD PTR [rax]
	rex_jmp	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
?print@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::print
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?print@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
out$ = 16
src$ = 24
?print@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z PROC ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::print, COMDAT

; 116  : {

	mov	rax, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 3576 :         return _Mypair._Myval2._Myptr();

	mov	rdx, QWORD PTR [r8]

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@print

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rdx]
$LN6@print:
; File C:\opencv\build\include\opencv2\flann\any.h

; 117  :     out << (*reinterpret_cast<cv::String const*>(*src)).c_str();

	mov	rcx, rax
	jmp	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
?print@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::print
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1_InputOutputArray@cv@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1_InputOutputArray@cv@@QEAA@XZ PROC			; cv::_InputOutputArray::~_InputOutputArray, COMDAT
	ret	0
??1_InputOutputArray@cv@@QEAA@XZ ENDP			; cv::_InputOutputArray::~_InputOutputArray
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
;	COMDAT vc_binary_blob_labelling
_TEXT	SEGMENT
bytesperline$1$ = 32
tv3854 = 40
tv3852 = 48
tv3847 = 56
tv3875 = 64
tv3862 = 72
tv3859 = 80
tv3829 = 88
datadst$1$ = 96
nlabels$GSCopy$1$ = 104
labeltable$ = 112
__$ArrayPad$ = 1136
original$ = 1216
converted$ = 1224
nlabels$ = 1232
vc_binary_blob_labelling PROC				; COMDAT

; 16   : {

$LN176:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 1152				; 00000480H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 17   : 	unsigned char* datasrc = (unsigned char*)original->data;
; 18   : 	unsigned char* datadst = (unsigned char*)converted->data;

	mov	r13, QWORD PTR [rdx]
	mov	rbx, rdx

; 19   : 	int width = original->width;
; 20   : 	int height = original->height;
; 21   : 	int bytesperline = original->bytesperline;

	mov	eax, DWORD PTR [rcx+24]
	mov	rsi, rcx
	mov	ebp, DWORD PTR [rcx+8]

; 22   : 	int channels = original->channels;
; 23   : 	int x, y, a, b;
; 24   : 	long int i, size;
; 25   : 	long int posX, posA, posB, posC, posD;
; 26   : 	int labeltable[256] = { 0 }; //Primeiro elemento do array = 0

	xor	edx, edx
	mov	edi, DWORD PTR [rcx+12]
	mov	r14d, DWORD PTR [rcx+16]
	lea	rcx, QWORD PTR labeltable$[rsp]
	mov	QWORD PTR nlabels$GSCopy$1$[rsp], r8
	mov	r8d, 1024				; 00000400H
	mov	QWORD PTR datadst$1$[rsp], r13
	mov	DWORD PTR bytesperline$1$[rsp], eax
	call	memset

; 27   : 	int labelarea[256] = { 0 };
; 28   : 	int label = 1; // Etiqueta inicial.

	mov	r12d, 1
	mov	r15d, r12d

; 29   : 	int num, tmplabel;
; 30   : 	OVC* blobs; // Apontador para array de blobs (objectos) que ser� retornado desta fun��o.
; 31   : 
; 32   : 	// Verificao de erros
; 33   : 	if ((original->width <= 0) || (original->height <= 0) || (original->data == NULL))

	test	ebp, ebp
	jle	$LN48@vc_binary_
	test	edi, edi
	jle	$LN48@vc_binary_
	mov	rdx, QWORD PTR [rsi]
	test	rdx, rdx
	je	$LN48@vc_binary_

; 35   : 	if ((original->width != converted->width) || (original->height != converted->height) || (original->channels != converted->channels))

	cmp	ebp, DWORD PTR [rbx+8]
	jne	$LN48@vc_binary_
	cmp	edi, DWORD PTR [rbx+12]
	jne	$LN48@vc_binary_
	cmp	r14d, DWORD PTR [rbx+16]
	jne	$LN48@vc_binary_

; 36   : 		return NULL;
; 37   : 	if (channels != 1)

	cmp	r14d, r12d
	jne	$LN48@vc_binary_

; 38   : 		return NULL;
; 39   : 
; 40   : 	// Copia dados da imagem binaria para imagem grayscale
; 41   : 	memcpy(datadst, datasrc, bytesperline * height);

	mov	eax, DWORD PTR bytesperline$1$[rsp]
	mov	rcx, r13
	imul	eax, edi
	movsxd	rbx, eax
	mov	r8, rbx
	call	memcpy

; 42   : 
; 43   : 	// Todos os pixeis de plano de fundo devem obrigatoriamente ter valor 0
; 44   : 	// Todos os pixeis de primeiro plano devem obrigatoriamente ter valor 255
; 45   : 	// Seria atribuidas etiquetas no intervalo [1,254]
; 46   : 	// Este algoritmo esta assim limitado a 255 labels
; 47   : 	//Default do array de destino
; 48   : 	for (i = 0, size = bytesperline * height; i < size; i++)

	test	rbx, rbx
	jle	SHORT $LN3@vc_binary_
	mov	rax, r13
$LL109@vc_binary_:

; 49   : 		if (datadst[i] != 0)

	cmp	BYTE PTR [rax], 0
	je	SHORT $LN163@vc_binary_

; 50   : 			datadst[i] = 255;

	mov	BYTE PTR [rax], 255			; 000000ffH
$LN163@vc_binary_:

; 42   : 
; 43   : 	// Todos os pixeis de plano de fundo devem obrigatoriamente ter valor 0
; 44   : 	// Todos os pixeis de primeiro plano devem obrigatoriamente ter valor 255
; 45   : 	// Seria atribuidas etiquetas no intervalo [1,254]
; 46   : 	// Este algoritmo esta assim limitado a 255 labels
; 47   : 	//Default do array de destino
; 48   : 	for (i = 0, size = bytesperline * height; i < size; i++)

	inc	rax
	sub	rbx, r12
	jne	SHORT $LL109@vc_binary_
$LN3@vc_binary_:

; 51   : 
; 52   : 	// Limpa os rebordos da imagem binaria (deixa de ser necessário verificar se o kernel esta dentro da imagem)
; 53   : 	for (y = 0; y < height; y++)

	movsxd	r9, DWORD PTR bytesperline$1$[rsp]
	lea	esi, DWORD PTR [rbp-1]
	movsxd	r8, esi
	mov	rax, r13
	mov	rcx, rdi
	npad	9
$LL7@vc_binary_:

; 54   : 	{
; 55   : 		datadst[y * bytesperline + 0 * channels] = 0;

	mov	BYTE PTR [rax], 0

; 56   : 		datadst[y * bytesperline + (width - 1) * channels] = 0;

	mov	BYTE PTR [r8+rax], 0
	add	rax, r9
	sub	rcx, r12
	jne	SHORT $LL7@vc_binary_

; 156  : 				labeltable[b] = 0;

	lea	r8d, DWORD PTR [rdi-1]
	mov	rcx, r13
	mov	eax, r8d
	imul	eax, r9d
	movsxd	rdx, eax
	mov	rax, rbp
	npad	12
$LL10@vc_binary_:

; 57   : 	}
; 58   : 
; 59   : 	for (x = 0; x < width; x++)
; 60   : 	{
; 61   : 		datadst[0 * bytesperline + x * channels] = 0;
; 62   : 		datadst[(height - 1) * bytesperline + x * channels] = 0;

	mov	BYTE PTR [rcx], 0
	mov	BYTE PTR [rdx+rcx], 0
	lea	rcx, QWORD PTR [rcx+1]
	sub	rax, r12
	jne	SHORT $LL10@vc_binary_

; 63   : 	}
; 64   : 
; 65   : 	
; 66   : 	// Efectua a etiquetagem
; 67   : 	for (y = 1; y < height - 1; y++)

	cmp	r8d, r12d
	jle	$LN30@vc_binary_
	lea	rdx, QWORD PTR [r13-1]
	mov	QWORD PTR tv3875[rsp], r9
	lea	eax, DWORD PTR [r8-1]
	add	rdx, r9
	mov	QWORD PTR tv3859[rsp], rdx
	lea	r13, QWORD PTR [r9-1]
	mov	r14, r12
	mov	QWORD PTR tv3847[rsp], rax
	mov	r10, r9
	mov	QWORD PTR tv3862[rsp], rax
	mov	rcx, r9
$LL13@vc_binary_:

; 68   : 		for (x = 1; x < width - 1; x++)

	cmp	esi, r12d
	jle	$LN11@vc_binary_
	lea	rcx, QWORD PTR [r14+r13]
	mov	r9, r14
	sub	r9, rcx
	lea	r11, QWORD PTR [rdx+r14]
	dec	r9
	lea	ebp, DWORD PTR [rsi-1]
	mov	r8, r10
	mov	QWORD PTR tv3852[rsp], r9
	sub	r8, rcx
	mov	rdi, r14
	add	r8, r14
	sub	rdi, rcx
	mov	rbx, r14
	mov	QWORD PTR tv3854[rsp], r8
	sub	rbx, rcx
$LL16@vc_binary_:

; 69   : 		{
; 70   : 			// Kernel:
; 71   : 			// A B C
; 72   : 			// D X
; 73   : 
; 74   : 			posA = (y - 1) * bytesperline + (x - 1) * channels; // A
; 75   : 			posB = (y - 1) * bytesperline + x * channels;		// B
; 76   : 			posC = (y - 1) * bytesperline + (x + 1) * channels; // C
; 77   : 			posD = y * bytesperline + (x - 1) * channels;		// D
; 78   : 			posX = y * bytesperline + x * channels;				// X
; 79   : 
; 80   : 
; 81   : 			// Se o pixel foi marcado
; 82   : 			if (datadst[posX] != 0)

	cmp	BYTE PTR [r11+r8], 0
	je	$LN14@vc_binary_

; 83   : 			{
; 84   : 				if ((datadst[posA] == 0) && (datadst[posB] == 0) && (datadst[posC] == 0) && (datadst[posD] == 0))

	movzx	eax, BYTE PTR [r11+r9]
	test	al, al
	jne	SHORT $LN54@vc_binary_
	cmp	BYTE PTR [r11+rbx], al
	jne	SHORT $LN54@vc_binary_
	cmp	BYTE PTR [r11+rdi+1], al
	jne	SHORT $LN54@vc_binary_
	cmp	BYTE PTR [r11], al
	jne	SHORT $LN54@vc_binary_

; 85   : 				{
; 86   : 					datadst[posX] = label;
; 87   : 					labeltable[label] = label;

	movsxd	rax, r15d
	mov	BYTE PTR [r11+r8], r15b
	mov	DWORD PTR labeltable$[rsp+rax*4], r15d

; 88   : 					label++;

	inc	r15d

; 89   : 				}

	jmp	$LN14@vc_binary_
$LN54@vc_binary_:

; 90   : 				else
; 91   : 				{
; 92   : 					num = 255;

	mov	edx, 255				; 000000ffH

; 93   : 
; 94   : 					//getchar();
; 95   : 					// Se A esta marcado
; 96   : 					if (datadst[posA] != 0)

	test	al, al
	je	SHORT $LN56@vc_binary_

; 97   : 						num = labeltable[datadst[posA]];

	mov	edx, DWORD PTR labeltable$[rsp+rax*4]
$LN56@vc_binary_:

; 98   : 					// Se B esta marcado, e o menor que a etiqueta "num"
; 99   : 					if ((datadst[posB] != 0) && (labeltable[datadst[posB]] < num))

	movzx	eax, BYTE PTR [r11+rbx]
	test	al, al
	je	SHORT $LN57@vc_binary_
	mov	ecx, DWORD PTR labeltable$[rsp+rax*4]
	cmp	ecx, edx
	cmovl	edx, ecx
$LN57@vc_binary_:

; 100  : 						num = labeltable[datadst[posB]];
; 101  : 					// Se C esta marcado, e o menor que a etiqueta "num"
; 102  : 					if ((datadst[posC] != 0) && (labeltable[datadst[posC]] < num))

	movzx	eax, BYTE PTR [r11+rdi+1]
	test	al, al
	je	SHORT $LN58@vc_binary_
	mov	ecx, DWORD PTR labeltable$[rsp+rax*4]
	cmp	ecx, edx
	cmovl	edx, ecx
$LN58@vc_binary_:

; 103  : 						num = labeltable[datadst[posC]];
; 104  : 					// Se D esta marcado, e o menor que a etiqueta "num"
; 105  : 					if ((datadst[posD] != 0) && (labeltable[datadst[posD]] < num))

	movzx	eax, BYTE PTR [r11]
	test	al, al
	je	SHORT $LN59@vc_binary_
	mov	ecx, DWORD PTR labeltable$[rsp+rax*4]
	cmp	ecx, edx
	cmovl	edx, ecx
$LN59@vc_binary_:

; 106  : 						num = labeltable[datadst[posD]];
; 107  : 
; 108  : 					// Atribui a etiqueta ao pixel
; 109  : 					datadst[posX] = num;
; 110  : 					labeltable[num] = num;

	movsxd	rax, edx
	mov	BYTE PTR [r11+r8], dl
	mov	DWORD PTR labeltable$[rsp+rax*4], edx

; 111  : 
; 112  : 					// Actualiza a tabela de etiquetas
; 113  : 					if (datadst[posA] != 0)

	movzx	eax, BYTE PTR [r11+r9]
	test	al, al
	je	SHORT $LN18@vc_binary_

; 114  : 						if (labeltable[datadst[posA]] != num)

	mov	r9d, DWORD PTR labeltable$[rsp+rax*4]
	cmp	r9d, edx
	je	SHORT $LN18@vc_binary_

; 115  : 							for (tmplabel = labeltable[datadst[posA]], a = 1; a < label; a++)

	cmp	r15d, r12d
	jle	SHORT $LN18@vc_binary_
	lea	rcx, QWORD PTR labeltable$[rsp+4]
	lea	r8d, DWORD PTR [r15-1]
	npad	6
$LL112@vc_binary_:

; 116  : 								if (labeltable[a] == tmplabel)

	cmp	DWORD PTR [rcx], r9d
	jne	SHORT $LN164@vc_binary_

; 117  : 									labeltable[a] = num;

	mov	DWORD PTR [rcx], edx
$LN164@vc_binary_:

; 115  : 							for (tmplabel = labeltable[datadst[posA]], a = 1; a < label; a++)

	add	rcx, 4
	sub	r8, r12
	jne	SHORT $LL112@vc_binary_
$LN18@vc_binary_:

; 118  : 
; 119  : 					if (datadst[posB] != 0)

	movzx	eax, BYTE PTR [rbx+r11]
	test	al, al
	je	SHORT $LN21@vc_binary_

; 120  : 						if (labeltable[datadst[posB]] != num)

	mov	r9d, DWORD PTR labeltable$[rsp+rax*4]
	cmp	r9d, edx
	je	SHORT $LN21@vc_binary_

; 121  : 							for (tmplabel = labeltable[datadst[posB]], a = 1; a < label; a++)

	cmp	r15d, r12d
	jle	SHORT $LN21@vc_binary_
	lea	rcx, QWORD PTR labeltable$[rsp+4]
	lea	r8d, DWORD PTR [r15-1]
$LL115@vc_binary_:

; 122  : 								if (labeltable[a] == tmplabel)

	cmp	DWORD PTR [rcx], r9d
	jne	SHORT $LN165@vc_binary_

; 123  : 									labeltable[a] = num;

	mov	DWORD PTR [rcx], edx
$LN165@vc_binary_:

; 121  : 							for (tmplabel = labeltable[datadst[posB]], a = 1; a < label; a++)

	add	rcx, 4
	sub	r8, r12
	jne	SHORT $LL115@vc_binary_
$LN21@vc_binary_:

; 124  : 
; 125  : 					if (datadst[posC] != 0)

	movzx	r10d, BYTE PTR [rdi+r11+1]
	test	r10b, r10b
	je	SHORT $LN24@vc_binary_

; 126  : 						if (labeltable[datadst[posC]] != num)

	mov	r9d, DWORD PTR labeltable$[rsp+r10*4]
	cmp	r9d, edx
	je	SHORT $LN24@vc_binary_

; 127  : 							for (tmplabel = labeltable[datadst[posC]], a = 1; a < label; a++)

	cmp	r15d, r12d
	jle	SHORT $LN24@vc_binary_
	lea	rcx, QWORD PTR labeltable$[rsp+4]
	lea	r8d, DWORD PTR [r15-1]
$LL118@vc_binary_:

; 128  : 								if (labeltable[a] == tmplabel)

	cmp	DWORD PTR [rcx], r9d
	jne	SHORT $LN166@vc_binary_

; 129  : 									labeltable[a] = num;

	mov	DWORD PTR [rcx], edx
$LN166@vc_binary_:

; 127  : 							for (tmplabel = labeltable[datadst[posC]], a = 1; a < label; a++)

	add	rcx, 4
	sub	r8, r12
	jne	SHORT $LL118@vc_binary_
$LN24@vc_binary_:

; 130  : 
; 131  : 					if (datadst[posD] != 0)

	movzx	eax, BYTE PTR [r11]
	test	al, al
	je	SHORT $LN174@vc_binary_

; 132  : 						if (labeltable[datadst[posD]] != num)

	cmp	DWORD PTR labeltable$[rsp+rax*4], edx
	je	SHORT $LN174@vc_binary_

; 133  : 							for (tmplabel = labeltable[datadst[posC]], a = 1; a < label; a++)

	mov	r9d, DWORD PTR labeltable$[rsp+r10*4]
	cmp	r15d, r12d
	jle	SHORT $LN174@vc_binary_
	lea	rax, QWORD PTR labeltable$[rsp+4]
	lea	r8d, DWORD PTR [r15-1]
$LL121@vc_binary_:

; 134  : 								if (labeltable[a] == tmplabel)

	cmp	DWORD PTR [rax], r9d
	jne	SHORT $LN167@vc_binary_

; 135  : 									labeltable[a] = num;

	mov	DWORD PTR [rax], edx
$LN167@vc_binary_:

; 133  : 							for (tmplabel = labeltable[datadst[posC]], a = 1; a < label; a++)

	add	rax, 4
	sub	r8, r12
	jne	SHORT $LL121@vc_binary_
$LN174@vc_binary_:

; 68   : 		for (x = 1; x < width - 1; x++)

	mov	r9, QWORD PTR tv3852[rsp]
	mov	r8, QWORD PTR tv3854[rsp]
$LN14@vc_binary_:
	inc	r11
	sub	rbp, 1
	jne	$LL16@vc_binary_
	mov	rcx, QWORD PTR tv3875[rsp]
	mov	rax, QWORD PTR tv3862[rsp]
	mov	r10, rcx
	mov	rdx, QWORD PTR tv3859[rsp]
$LN11@vc_binary_:

; 63   : 	}
; 64   : 
; 65   : 	
; 66   : 	// Efectua a etiquetagem
; 67   : 	for (y = 1; y < height - 1; y++)

	add	r14, rcx
	sub	rax, r12
	mov	QWORD PTR tv3862[rsp], rax
	jne	$LL13@vc_binary_

; 136  : 				}
; 137  : 			}
; 138  : 		}
; 139  : 
; 140  : 	// Volta a etiquetar a imagem
; 141  : 	for (y = 1; y < height - 1; y++)

	mov	r10d, DWORD PTR bytesperline$1$[rsp]
	mov	r9d, r10d
	mov	r13, QWORD PTR datadst$1$[rsp]
	mov	rax, QWORD PTR tv3847[rsp]
$LL31@vc_binary_:

; 142  : 		for (x = 1; x < width - 1; x++)

	mov	edx, r12d
	cmp	esi, edx
	jle	SHORT $LN29@vc_binary_
	npad	8
$LL34@vc_binary_:

; 143  : 		{
; 144  : 			posX = y * bytesperline + x * channels; // X
; 145  : 
; 146  : 			if (datadst[posX] != 0)

	lea	eax, DWORD PTR [r9+rdx]
	movsxd	r8, eax
	movzx	eax, BYTE PTR [r8+r13]
	test	al, al
	je	SHORT $LN32@vc_binary_

; 147  : 				datadst[posX] = labeltable[datadst[posX]];

	movzx	ecx, BYTE PTR labeltable$[rsp+rax*4]
	mov	BYTE PTR [r8+r13], cl
$LN32@vc_binary_:

; 142  : 		for (x = 1; x < width - 1; x++)

	inc	edx
	cmp	edx, esi
	jl	SHORT $LL34@vc_binary_
	mov	rax, QWORD PTR tv3847[rsp]
$LN29@vc_binary_:

; 136  : 				}
; 137  : 			}
; 138  : 		}
; 139  : 
; 140  : 	// Volta a etiquetar a imagem
; 141  : 	for (y = 1; y < height - 1; y++)

	add	r9d, r10d
	sub	rax, r12
	mov	QWORD PTR tv3847[rsp], rax
	jne	SHORT $LL31@vc_binary_
$LN30@vc_binary_:

; 148  : 		}
; 149  : 
; 150  : 	// Contagem do numero de blobs
; 151  : 	// Passo 1: Eliminar, da tabela, etiquetas repetidas
; 152  : 	for (a = 1; a < label - 1; a++)

	lea	eax, DWORD PTR [r15-1]
	xor	r8d, r8d
	movsxd	r10, eax
	cmp	r10, r12
	jle	SHORT $LN36@vc_binary_

; 147  : 				datadst[posX] = labeltable[datadst[posX]];

	mov	r9d, 2
$LL37@vc_binary_:

; 153  : 		for (b = a + 1; b < label; b++)

	cmp	r9d, r15d
	jge	SHORT $LN35@vc_binary_
	lea	rcx, QWORD PTR labeltable$[rsp+4]
	mov	edx, r15d
	lea	rcx, QWORD PTR [rcx+r12*4]
	sub	edx, r9d
	npad	6
$LL40@vc_binary_:

; 154  : 		{
; 155  : 			if (labeltable[a] == labeltable[b])

	mov	eax, DWORD PTR [rcx]
	cmp	DWORD PTR labeltable$[rsp+r12*4], eax
	jne	SHORT $LN38@vc_binary_

; 156  : 				labeltable[b] = 0;

	mov	DWORD PTR [rcx], r8d
$LN38@vc_binary_:

; 153  : 		for (b = a + 1; b < label; b++)

	add	rcx, 4
	sub	rdx, 1
	jne	SHORT $LL40@vc_binary_
$LN35@vc_binary_:

; 148  : 		}
; 149  : 
; 150  : 	// Contagem do numero de blobs
; 151  : 	// Passo 1: Eliminar, da tabela, etiquetas repetidas
; 152  : 	for (a = 1; a < label - 1; a++)

	inc	r9d
	inc	r12
	cmp	r12, r10
	jl	SHORT $LL37@vc_binary_
$LN36@vc_binary_:

; 161  : 	for (a = 1; a < label; a++)

	cmp	r15d, 1
	jle	SHORT $LN42@vc_binary_

; 156  : 				labeltable[b] = 0;

	lea	rdx, QWORD PTR labeltable$[rsp]
	lea	rcx, QWORD PTR labeltable$[rsp+4]
	lea	r9d, DWORD PTR [r15-1]
$LL43@vc_binary_:

; 162  : 		if (labeltable[a] != 0)

	mov	eax, DWORD PTR [rcx]
	test	eax, eax
	je	SHORT $LN41@vc_binary_

; 163  : 		{
; 164  : 			labeltable[*nlabels] = labeltable[a]; // Organiza tabela de etiquetas
; 165  : 			(*nlabels)++;						  // Conta etiquetas

	inc	r8d
	mov	DWORD PTR [rdx], eax
	add	rdx, 4
$LN41@vc_binary_:

; 161  : 	for (a = 1; a < label; a++)

	add	rcx, 4
	sub	r9, 1
	jne	SHORT $LL43@vc_binary_
$LN42@vc_binary_:

; 157  : 		}
; 158  : 
; 159  : 	// Passo 2: Conta etiquetas e organiza a tabela de etiquetas, para que n�o hajam valores vazios (zero) entre etiquetas
; 160  : 	*nlabels = 0;

	mov	rbx, QWORD PTR nlabels$GSCopy$1$[rsp]
	mov	DWORD PTR [rbx], r8d

; 166  : 		}
; 167  : 
; 168  : 	// Se nao ha blobs
; 169  : 	if (*nlabels == 0)

	test	r8d, r8d
	je	SHORT $LN48@vc_binary_

; 170  : 		return NULL;
; 171  : 
; 172  : 	// Cria lista de blobs (objectos) e preenche a etiqueta
; 173  : 	blobs = (OVC*)calloc((*nlabels), sizeof(OVC));

	movsxd	rcx, r8d
	mov	edx, 36					; 00000024H
	call	QWORD PTR __imp_calloc

; 174  : 	if (blobs != NULL)

	test	rax, rax
	je	SHORT $LN48@vc_binary_

; 175  : 		for (a = 0; a < (*nlabels); a++)

	mov	ecx, DWORD PTR [rbx]
	test	ecx, ecx
	jle	SHORT $LN1@vc_binary_

; 156  : 				labeltable[b] = 0;

	lea	rdx, QWORD PTR labeltable$[rsp]
	mov	r9d, ecx
	lea	r8, QWORD PTR [rax+32]
$LL46@vc_binary_:

; 176  : 			blobs[a].label = labeltable[a];

	mov	ecx, DWORD PTR [rdx]
	lea	rdx, QWORD PTR [rdx+4]
	mov	DWORD PTR [r8], ecx
	lea	r8, QWORD PTR [r8+36]
	sub	r9, 1
	jne	SHORT $LL46@vc_binary_

; 177  : 	else
; 178  : 		return NULL;
; 179  : 
; 180  : 	//printf("Nº blobls: %d\n", *nlabels);
; 181  : 
; 182  : 	return blobs;

	jmp	SHORT $LN1@vc_binary_
$LN48@vc_binary_:

; 34   : 		return 0;

	xor	eax, eax
$LN1@vc_binary_:

; 183  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+1240]
	add	rsp, 1152				; 00000480H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
vc_binary_blob_labelling ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
;	COMDAT vc_trab_fase1
_TEXT	SEGMENT
original$ = 64
vc_trab_fase1 PROC					; COMDAT

; 188  : {

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 189  : 	//VARS
; 190  : 	int detected_y = -1;
; 191  : 	IVC* dilate, * prewitt; //GRAY
; 192  : 
; 193  : 	//Inicialize
; 194  : 	dilate = vc_image_new(original->width, original->height, 1, 255);

	mov	ebp, DWORD PTR [rcx+12]
	mov	r14, rcx
	mov	ebx, DWORD PTR [rcx+8]
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H
	call	QWORD PTR __imp_malloc

; 39   : 
; 40   : 	if (image == NULL)

	xor	edi, edi
	mov	rsi, rax
	test	rax, rax
	je	SHORT $LN23@vc_trab_fa

; 41   : 		return NULL;
; 42   : 	if ((levels <= 0) || (levels > 255))
; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rax+8], ebx

; 46   : 	image->height = height;
; 47   : 	image->channels = channels;
; 48   : 	image->levels = levels;
; 49   : 	image->bytesperline = image->width * image->channels;

	mov	DWORD PTR [rax+24], ebx

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	ebx, ebp
	mov	DWORD PTR [rax+12], ebp
	mov	DWORD PTR [rax+16], 1
	mov	DWORD PTR [rax+20], 255			; 000000ffH
	movsxd	rcx, ebx
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rsi], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN7@vc_trab_fa

; 71   : 		free(image);

	mov	rcx, rsi
	call	QWORD PTR __imp_free
$LN23@vc_trab_fa:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 195  : 	prewitt = vc_image_new(original->width, original->height, 1, 255);

	mov	rsi, rdi
$LN7@vc_trab_fa:
	mov	r15d, DWORD PTR [r14+12]
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 195  : 	prewitt = vc_image_new(original->width, original->height, 1, 255);

	mov	ebp, DWORD PTR [r14+8]
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	call	QWORD PTR __imp_malloc
	mov	rbx, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	je	SHORT $LN13@vc_trab_fa

; 41   : 		return NULL;
; 42   : 	if ((levels <= 0) || (levels > 255))
; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rax+8], ebp

; 46   : 	image->height = height;
; 47   : 	image->channels = channels;
; 48   : 	image->levels = levels;
; 49   : 	image->bytesperline = image->width * image->channels;

	mov	DWORD PTR [rax+24], ebp

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	ebp, r15d
	mov	DWORD PTR [rax+12], r15d
	mov	DWORD PTR [rax+16], 1
	mov	DWORD PTR [rax+20], 255			; 000000ffH
	movsxd	rcx, ebp
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rbx], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN17@vc_trab_fa

; 71   : 		free(image);

	mov	rcx, rbx
	call	QWORD PTR __imp_free

; 54   : 		return vc_image_free(image);

	jmp	SHORT $LN13@vc_trab_fa
$LN17@vc_trab_fa:

; 55   : 	}
; 56   : 
; 57   : 	return image;

	mov	rdi, rbx
$LN13@vc_trab_fa:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 198  : 	vc_gray_edge_prewitt(original, prewitt, 0.970);

	movss	xmm2, DWORD PTR __real@3f7851ec
	mov	rdx, rdi
	mov	rcx, r14
	call	vc_gray_edge_prewitt

; 199  : 	//char aux1[] = "fase1_prewitt.pgm";
; 200  : 	//vc_write_image(aux1, prewitt);
; 201  : 
; 202  : 	//Dilate
; 203  : 	vc_binary_dilate(prewitt, dilate, 3);

	mov	rdx, rsi
	mov	rcx, rdi
	call	vc_binary_dilate

; 204  : 	//char aux[] = "fase1_dilate.pgm";
; 205  : 	//vc_write_image(aux, dilate);
; 206  : 
; 207  : 	//Detecta a linha da matricula e retorna o valor
; 208  : 	detected_y = vc_trab_detect(dilate);

	mov	rcx, rsi

; 209  : 
; 210  : 	//Retorna valor do y detectado
; 211  : 	return detected_y;
; 212  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi

; 204  : 	//char aux[] = "fase1_dilate.pgm";
; 205  : 	//vc_write_image(aux, dilate);
; 206  : 
; 207  : 	//Detecta a linha da matricula e retorna o valor
; 208  : 	detected_y = vc_trab_detect(dilate);

	jmp	vc_trab_detect
vc_trab_fase1 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\opencv\build\include\opencv2\core\types.hpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp
;	COMDAT main
_TEXT	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main	PROC						; COMDAT

; 215  : {

$LN1191:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	mov	QWORD PTR [rax+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-1160]
	sub	rsp, 1376				; 00000560H
	movaps	XMMWORD PTR [rax-56], xmm6
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	movaps	XMMWORD PTR [rax-104], xmm9
	movaps	XMMWORD PTR [rax-120], xmm10
	movaps	XMMWORD PTR [rax-136], xmm11
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 216  : 	// V�deo
; 217  : 	char videofile[60] = "video1.mp4";

	movsd	xmm0, QWORD PTR ??_C@_0L@NMCHEKHG@video1?4mp4@
	movsd	QWORD PTR videofile$[rbp-256], xmm0
	movzx	eax, WORD PTR ??_C@_0L@NMCHEKHG@video1?4mp4@+8
	mov	WORD PTR videofile$[rbp-248], ax
	movzx	eax, BYTE PTR ??_C@_0L@NMCHEKHG@video1?4mp4@+10
	mov	BYTE PTR videofile$[rbp-246], al
	xorps	xmm0, xmm0
	xor	eax, eax
	movups	XMMWORD PTR videofile$[rbp-245], xmm0
	movups	XMMWORD PTR videofile$[rbp-229], xmm0
	movups	XMMWORD PTR videofile$[rbp-213], xmm0
	mov	BYTE PTR videofile$[rbp-197], al

; 218  : 	int nMatriculas = 0;
; 219  : 	cv::VideoCapture capture;

	lea	rcx, QWORD PTR capture$[rbp-256]
	call	QWORD PTR __imp_??0VideoCapture@cv@@QEAA@XZ
	npad	1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4201 :         _Mypair._Myval2._Mysize = 0;

	xor	r13d, r13d
	mov	QWORD PTR str$[rbp-240], r13

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR str$[rbp-232], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR str$[rbp-256], r13b

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T3[rbp-240], r13

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T3[rbp-232], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T3[rbp-256], r13b

; 325  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	lea	rax, QWORD PTR videofile$[rbp-256]
	mov	r8, -1
	npad	4
$LL1184@main:
	inc	r8
	cmp	BYTE PTR [rax+r8], 0
	jne	SHORT $LL1184@main

; 2892 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	rdx, QWORD PTR videofile$[rbp-256]
	lea	rcx, QWORD PTR $T3[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 235  : 	capture.open(videofile);

	xor	r8d, r8d
	lea	rdx, QWORD PTR $T3[rbp-256]
	lea	rcx, QWORD PTR capture$[rbp-256]
	call	QWORD PTR __imp_?open@VideoCapture@cv@@UEAA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
	npad	1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T3[rbp-232]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN57@main

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T3[rbp-256]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN68@main

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN68@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN68@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN57@main:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 241  : 	if (!capture.isOpened())

	lea	rcx, QWORD PTR capture$[rbp-256]
	call	QWORD PTR __imp_?isOpened@VideoCapture@cv@@UEBA_NXZ
	test	al, al
	jne	SHORT $LN4@main

; 242  : 	{
; 243  : 		std::cerr << "Erro ao abrir o ficheiro de v�deo!\n";

	lea	rdx, OFFSET FLAT:??_C@_0CG@GGBHFKB@Erro?5ao?5abrir?5o?5ficheiro?5de?5v?o?$LP@
	mov	rcx, QWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ebx, 1
	jmp	$LN968@main
$LN4@main:

; 244  : 		return 1;
; 245  : 	}
; 246  : 
; 247  : 	/* N�mero total de frames no v�deo */
; 248  : 	video.ntotalframes = (int)capture.get(cv::CAP_PROP_FRAME_COUNT);

	mov	edx, 7
	lea	rcx, QWORD PTR capture$[rbp-256]
	call	QWORD PTR __imp_?get@VideoCapture@cv@@UEBANH@Z
	cvttsd2si eax, xmm0
	mov	DWORD PTR video$$sroa$1778$1$[rsp], eax

; 249  : 	/* Frame rate do v�deo */
; 250  : 	video.fps = (int)capture.get(cv::CAP_PROP_FPS);

	mov	edx, 5
	lea	rcx, QWORD PTR capture$[rbp-256]
	call	QWORD PTR __imp_?get@VideoCapture@cv@@UEBANH@Z

; 251  : 	/* Resolu��o do v�deo */
; 252  : 	video.width = (int)capture.get(cv::CAP_PROP_FRAME_WIDTH);

	mov	edx, 3
	lea	rcx, QWORD PTR capture$[rbp-256]
	call	QWORD PTR __imp_?get@VideoCapture@cv@@UEBANH@Z
	cvttsd2si ebx, xmm0
	mov	DWORD PTR video$$sroa$1777$1$[rsp], ebx

; 253  : 	video.height = (int)capture.get(cv::CAP_PROP_FRAME_HEIGHT);

	mov	edx, 4
	lea	rcx, QWORD PTR capture$[rbp-256]
	call	QWORD PTR __imp_?get@VideoCapture@cv@@UEBANH@Z
	cvttsd2si esi, xmm0
	mov	DWORD PTR video$$sroa$1776$1$[rsp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T10[rbp-240], r13

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T10[rbp-232], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T10[rbp-256], 0

; 2892 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02LDNLGICJ@VC@
	lea	rcx, QWORD PTR $T10[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 256  : 	cv::namedWindow("VC", cv::WINDOW_AUTOSIZE);

	mov	r12d, 1
	mov	edx, r12d
	lea	rcx, QWORD PTR $T10[rbp-256]
	call	QWORD PTR __imp_?namedWindow@cv@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
	npad	1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T10[rbp-232]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN126@main

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T10[rbp-256]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN137@main

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN137@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN137@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN126@main:
	xorps	xmm0, xmm0
	movups	XMMWORD PTR frame$[rbp-192], xmm0
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 466  :     : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),

	movdqa	xmm0, XMMWORD PTR __xmm@00000000000000000000000042ff0000
	movdqa	XMMWORD PTR frame$[rbp-256], xmm0
	xorps	xmm1, xmm1
	movdqa	XMMWORD PTR frame$[rbp-240], xmm1
	xorps	xmm0, xmm0
	movdqa	XMMWORD PTR frame$[rbp-224], xmm0

; 467  :       datalimit(0), allocator(0), u(0), size(&rows), step(0)

	movdqa	XMMWORD PTR frame$[rbp-208], xmm1

; 1468 :     : p(_p) {}

	lea	rax, QWORD PTR frame$[rbp-248]
	mov	QWORD PTR frame$[rbp-192], rax

; 1544 :     p = buf; p[0] = s; p[1] = 0;

	lea	rax, QWORD PTR frame$[rbp-176]
	mov	QWORD PTR frame$[rbp-184], rax
	movdqa	XMMWORD PTR frame$[rbp-176], xmm0
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 263  : 	cv::Mat frame;

	movsd	xmm6, QWORD PTR __real@3fe2e147ae147ae1
	movsd	xmm7, QWORD PTR __real@3fd3333333333333
	movsd	xmm8, QWORD PTR __real@3fbc28f5c28f5c29
	movsd	xmm9, QWORD PTR __real@4008000000000000
	movss	xmm11, DWORD PTR __real@3f7851ec
	movsd	xmm10, QWORD PTR __real@3ff0000000000000
	npad	1
$LL2@main:
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	mov	QWORD PTR $T14[rbp-240], 0
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	DWORD PTR $T14[rbp-256], 33619968	; 02010000H
	lea	rax, QWORD PTR frame$[rbp-256]
	mov	QWORD PTR $T14[rbp-248], rax
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 267  : 		capture.read(frame);

	lea	rdx, QWORD PTR $T14[rbp-256]
	lea	rcx, QWORD PTR capture$[rbp-256]
	call	QWORD PTR __imp_?read@VideoCapture@cv@@UEAA_NAEBV_OutputArray@2@@Z
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 960  :     return data == 0 || total() == 0 || dims == 0;

	cmp	QWORD PTR frame$[rbp-240], 0
	je	$LN3@main

; 966  :     if( dims <= 2 )

	mov	r9d, DWORD PTR frame$[rbp-252]
	cmp	r9d, 2
	jg	SHORT $LN168@main

; 967  :         return (size_t)rows * cols;

	movsxd	rdx, DWORD PTR frame$[rbp-248]
	movsxd	rax, DWORD PTR frame$[rbp-244]
	imul	rdx, rax
	jmp	SHORT $LN164@main
$LN168@main:

; 968  :     size_t p = 1;

	mov	rdx, r12

; 969  :     for( int i = 0; i < dims; i++ )

	test	r9d, r9d
	jle	SHORT $LN164@main

; 968  :     size_t p = 1;

	mov	rcx, QWORD PTR frame$[rbp-192]
	mov	r8, r9
	npad	8
$LL1071@main:

; 970  :         p *= size[i];

	movsxd	rax, DWORD PTR [rcx]
	imul	rdx, rax

; 969  :     for( int i = 0; i < dims; i++ )

	lea	rcx, QWORD PTR [rcx+4]
	sub	r8, 1
	jne	SHORT $LL1071@main
$LN164@main:

; 960  :     return data == 0 || total() == 0 || dims == 0;

	test	rdx, rdx
	je	$LN3@main
	test	r9d, r9d
	je	$LN3@main
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 274  : 		video.nframe = (int)capture.get(cv::CAP_PROP_POS_FRAMES);

	mov	edx, r12d
	lea	rcx, QWORD PTR capture$[rbp-256]
	call	QWORD PTR __imp_?get@VideoCapture@cv@@UEBANH@Z
	cvttsd2si r14d, xmm0
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H
	call	QWORD PTR __imp_malloc
	mov	rdi, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	je	SHORT $LN1187@main

; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rax+8], ebx

; 46   : 	image->height = height;

	mov	DWORD PTR [rax+12], esi

; 47   : 	image->channels = channels;

	mov	DWORD PTR [rax+16], 3

; 48   : 	image->levels = levels;

	mov	DWORD PTR [rax+20], 255			; 000000ffH

; 49   : 	image->bytesperline = image->width * image->channels;

	lea	eax, DWORD PTR [rbx+rbx*2]
	mov	DWORD PTR [rdi+24], eax

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	mov	eax, ebx
	imul	eax, esi
	lea	eax, DWORD PTR [rax+rax*2]
	movsxd	rcx, eax
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rdi], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN172@main

; 71   : 		free(image);

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN1187@main:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 285  : 		memcpy(img->data, frame.data, (video.width * video.height * 3));

	mov	rdi, r13
$LN172@main:
	mov	eax, ebx
	imul	eax, esi
	lea	eax, DWORD PTR [rax+rax*2]
	cdqe
	mov	QWORD PTR tv6080[rbp-256], rax
	mov	r8, rax
	mov	rdx, QWORD PTR frame$[rbp-240]
	mov	rcx, QWORD PTR [rdi]
	call	memcpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c

; 1821 : 	for (x = 0; x < original->width; x++)

	mov	r10d, r13d
	mov	esi, DWORD PTR [rdi+8]
	test	esi, esi
	jle	SHORT $LN1160@main
	mov	eax, DWORD PTR [rdi+12]
	npad	9
$LL185@main:

; 1822 : 	{
; 1823 : 		for (y = 0; y < original->height; y++)

	mov	r9d, r13d
	mov	r15d, eax
	test	eax, eax
	jle	SHORT $LN183@main
	npad	6
$LL188@main:

; 1824 : 		{
; 1825 : 			pos = y * original->bytesperline + x * original->channels;

	mov	ecx, DWORD PTR [rdi+16]
	imul	ecx, r10d
	mov	eax, DWORD PTR [rdi+24]
	imul	eax, r9d
	add	ecx, eax

; 1826 : 			temp = original->data[pos];

	movsxd	r8, ecx
	mov	rcx, QWORD PTR [rdi]
	movzx	edx, BYTE PTR [r8+rcx]

; 1827 : 			original->data[pos] = original->data[pos + 2];

	movzx	eax, BYTE PTR [r8+rcx+2]
	mov	BYTE PTR [r8+rcx], al

; 1828 : 			original->data[pos + 2] = (unsigned char)temp;

	mov	rax, QWORD PTR [rdi]
	mov	BYTE PTR [r8+rax+2], dl

; 1822 : 	{
; 1823 : 		for (y = 0; y < original->height; y++)

	inc	r9d
	mov	eax, DWORD PTR [rdi+12]
	cmp	r9d, eax
	jl	SHORT $LL188@main
	mov	r15d, eax
$LN183@main:

; 1821 : 	for (x = 0; x < original->width; x++)

	inc	r10d
	mov	esi, DWORD PTR [rdi+8]
	cmp	r10d, esi
	jl	SHORT $LL185@main
	jmp	SHORT $LN184@main
$LN1160@main:
	mov	r15d, DWORD PTR [rdi+12]
$LN184@main:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 295  : 		gray = vc_image_new(img->width, img->height, 1, img->levels);               //imagem rgb para gray

	mov	r13d, DWORD PTR [rdi+20]
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H
	call	QWORD PTR __imp_malloc
	mov	rbx, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	je	SHORT $LN193@main

; 42   : 	if ((levels <= 0) || (levels > 255))

	lea	eax, DWORD PTR [r13-1]
	cmp	eax, 254				; 000000feH
	ja	SHORT $LN193@main

; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rbx+8], esi

; 46   : 	image->height = height;

	mov	DWORD PTR [rbx+12], r15d

; 47   : 	image->channels = channels;

	mov	DWORD PTR [rbx+16], r12d

; 48   : 	image->levels = levels;

	mov	DWORD PTR [rbx+20], r13d

; 49   : 	image->bytesperline = image->width * image->channels;

	mov	DWORD PTR [rbx+24], esi

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	r15d, esi
	movsxd	rcx, r15d
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rbx], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN190@main

; 71   : 		free(image);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN193@main:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 296  : 		equalize = vc_image_new(img->width, img->height, img->channels, img->levels);               //imagem rgb para gray

	xor	ebx, ebx
$LN190@main:
	mov	r13d, DWORD PTR [rdi+20]
	mov	r12d, DWORD PTR [rdi+16]
	mov	eax, DWORD PTR [rdi+12]
	mov	DWORD PTR height$1$[rsp], eax
	mov	r15d, DWORD PTR [rdi+8]
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H
	call	QWORD PTR __imp_malloc
	mov	rsi, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	je	SHORT $LN207@main

; 42   : 	if ((levels <= 0) || (levels > 255))

	lea	ecx, DWORD PTR [r13-1]
	cmp	ecx, 254				; 000000feH
	ja	SHORT $LN207@main

; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rax+8], r15d

; 46   : 	image->height = height;

	mov	eax, DWORD PTR height$1$[rsp]
	mov	DWORD PTR [rsi+12], eax

; 47   : 	image->channels = channels;

	mov	DWORD PTR [rsi+16], r12d

; 48   : 	image->levels = levels;

	mov	DWORD PTR [rsi+20], r13d

; 49   : 	image->bytesperline = image->width * image->channels;

	mov	ecx, r15d
	imul	ecx, r12d
	mov	DWORD PTR [rsi+24], ecx

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	r15d, eax
	imul	r15d, r12d
	movsxd	rcx, r15d
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rsi], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN207@main

; 71   : 		free(image);

	mov	rcx, rsi
	call	QWORD PTR __imp_free
$LN207@main:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 297  : 		license = vc_image_new(img->width, img->height, 1, img->levels);            //imagem com a matricula recortada

	mov	r13d, DWORD PTR [rdi+20]
	mov	esi, DWORD PTR [rdi+12]
	mov	r15d, DWORD PTR [rdi+8]
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H
	call	QWORD PTR __imp_malloc
	mov	r12, rax
	mov	QWORD PTR license$1$[rsp], rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	je	SHORT $LN213@main

; 42   : 	if ((levels <= 0) || (levels > 255))

	lea	eax, DWORD PTR [r13-1]
	cmp	eax, 254				; 000000feH
	ja	SHORT $LN213@main

; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [r12+8], r15d

; 46   : 	image->height = height;

	mov	DWORD PTR [r12+12], esi

; 47   : 	image->channels = channels;

	mov	DWORD PTR [r12+16], 1

; 48   : 	image->levels = levels;

	mov	DWORD PTR [r12+20], r13d

; 49   : 	image->bytesperline = image->width * image->channels;

	mov	DWORD PTR [r12+24], r15d

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	esi, r15d
	movsxd	rcx, esi
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r12], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN210@main

; 71   : 		free(image);

	mov	rcx, r12
	call	QWORD PTR __imp_free
$LN213@main:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 298  : 		result = vc_image_new(img->width, img->height, img->channels, img->levels); //imagem final com a matricula aplicada

	mov	QWORD PTR license$1$[rsp], 0
$LN210@main:
	mov	r13d, DWORD PTR [rdi+20]
	mov	r12d, DWORD PTR [rdi+16]
	mov	eax, DWORD PTR [rdi+12]
	mov	DWORD PTR height$1$[rsp], eax
	mov	r15d, DWORD PTR [rdi+8]
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H
	call	QWORD PTR __imp_malloc
	mov	rsi, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	je	SHORT $LN223@main

; 42   : 	if ((levels <= 0) || (levels > 255))

	lea	eax, DWORD PTR [r13-1]
	cmp	eax, 254				; 000000feH
	ja	SHORT $LN223@main

; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rsi+8], r15d

; 46   : 	image->height = height;

	mov	ecx, DWORD PTR height$1$[rsp]
	mov	DWORD PTR [rsi+12], ecx

; 47   : 	image->channels = channels;

	mov	DWORD PTR [rsi+16], r12d

; 48   : 	image->levels = levels;

	mov	DWORD PTR [rsi+20], r13d

; 49   : 	image->bytesperline = image->width * image->channels;

	mov	eax, r15d
	imul	eax, r12d
	mov	DWORD PTR [rsi+24], eax

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	r15d, ecx
	imul	r15d, r12d
	movsxd	rcx, r15d
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rsi], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN220@main

; 71   : 		free(image);

	mov	rcx, rsi
	call	QWORD PTR __imp_free
$LN223@main:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 299  : 		memcpy(result->data, img->data, img->bytesperline* img->height);           //Copia dos dados da imagem original

	xor	esi, esi
$LN220@main:
	mov	eax, DWORD PTR [rdi+24]
	imul	eax, DWORD PTR [rdi+12]
	movsxd	r8, eax
	mov	rdx, QWORD PTR [rdi]
	mov	rcx, QWORD PTR [rsi]
	call	memcpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c

; 420  : 	for (x = 0; x < original->width; x++)

	xor	r9d, r9d
	cmp	DWORD PTR [rdi+8], r9d
	jle	$LN232@main
	mov	eax, DWORD PTR [rdi+12]
	npad	5
$LL233@main:

; 421  : 	{
; 422  : 		for (y = 0; y < original->height; y++)

	xor	r10d, r10d
	test	eax, eax
	jle	$LN231@main
	npad	5
$LL236@main:

; 425  : 			posAux = y * converted->bytesperline + x * converted->channels;

	mov	r8d, r10d
	imul	r8d, DWORD PTR [rbx+24]
	mov	eax, r9d
	imul	eax, DWORD PTR [rbx+16]
	add	r8d, eax

; 423  : 		{
; 424  : 			pos = y * original->bytesperline + x * original->channels;

	mov	ecx, DWORD PTR [rdi+24]
	imul	ecx, r10d
	mov	eax, DWORD PTR [rdi+16]
	imul	eax, r9d
	add	ecx, eax

; 426  : 			converted->data[posAux] = ((0.3 * original->data[pos] + 0.59 * original->data[pos + 1] + 0.11 * original->data[pos + 2]) / 3);

	movsxd	rdx, ecx
	mov	rcx, QWORD PTR [rdi]
	movzx	eax, BYTE PTR [rdx+rcx+1]
	movd	xmm2, eax
	cvtdq2pd xmm2, xmm2
	mulsd	xmm2, xmm6
	movzx	eax, BYTE PTR [rdx+rcx]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	mulsd	xmm0, xmm7
	addsd	xmm2, xmm0
	movzx	eax, BYTE PTR [rdx+rcx+2]
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	mulsd	xmm1, xmm8
	addsd	xmm2, xmm1
	divsd	xmm2, xmm9
	cvttsd2si edx, xmm2
	movsxd	rcx, r8d
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rcx+rax], dl

; 421  : 	{
; 422  : 		for (y = 0; y < original->height; y++)

	inc	r10d
	mov	eax, DWORD PTR [rdi+12]
	cmp	r10d, eax
	jl	SHORT $LL236@main
$LN231@main:

; 420  : 	for (x = 0; x < original->width; x++)

	inc	r9d
	cmp	r9d, DWORD PTR [rdi+8]
	jl	$LL233@main
$LN232@main:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 305  : 		char i_gray[] = "gray.pgm";

	movsd	xmm0, QWORD PTR ??_C@_08EGGIHDDP@gray?4pgm@
	movsd	QWORD PTR i_gray$106[rbp-256], xmm0
	movzx	eax, BYTE PTR ??_C@_08EGGIHDDP@gray?4pgm@+8
	mov	BYTE PTR i_gray$106[rbp-248], al

; 306  : 		vc_write_image(i_gray, gray);

	mov	rdx, rbx
	lea	rcx, QWORD PTR i_gray$106[rbp-256]
	call	vc_write_image

; 194  : 	dilate = vc_image_new(original->width, original->height, 1, 255);

	mov	r13d, DWORD PTR [rbx+12]
	mov	r15d, DWORD PTR [rbx+8]
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H
	call	QWORD PTR __imp_malloc
	mov	r12, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	je	SHORT $LN1188@main

; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rax+8], r15d

; 46   : 	image->height = height;

	mov	DWORD PTR [rax+12], r13d

; 47   : 	image->channels = channels;

	mov	DWORD PTR [rax+16], 1

; 48   : 	image->levels = levels;

	mov	DWORD PTR [rax+20], 255			; 000000ffH

; 49   : 	image->bytesperline = image->width * image->channels;

	mov	DWORD PTR [rax+24], r15d

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	r15d, r13d
	movsxd	rcx, r15d
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r12], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN240@main

; 71   : 		free(image);

	mov	rcx, r12
	call	QWORD PTR __imp_free
$LN1188@main:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 195  : 	prewitt = vc_image_new(original->width, original->height, 1, 255);

	xor	r12d, r12d
$LN240@main:
	mov	eax, DWORD PTR [rbx+12]
	mov	DWORD PTR height$1$[rsp], eax
	mov	r13d, DWORD PTR [rbx+8]
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H
	call	QWORD PTR __imp_malloc
	mov	r15, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	jne	SHORT $LN251@main

; 41   : 		return NULL;

	xor	r13d, r13d
	mov	r15d, r13d
	jmp	SHORT $LN250@main
$LN251@main:

; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rax+8], r13d

; 46   : 	image->height = height;

	mov	eax, DWORD PTR height$1$[rsp]
	mov	DWORD PTR [r15+12], eax

; 47   : 	image->channels = channels;

	mov	DWORD PTR [r15+16], 1

; 48   : 	image->levels = levels;

	mov	DWORD PTR [r15+20], 255			; 000000ffH

; 49   : 	image->bytesperline = image->width * image->channels;

	mov	DWORD PTR [r15+24], r13d

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	r13d, eax
	movsxd	rcx, r13d
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r15], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN254@main

; 71   : 		free(image);

	mov	rcx, r15
	call	QWORD PTR __imp_free

; 54   : 		return vc_image_free(image);

	xor	r13d, r13d
	mov	r15d, r13d
	jmp	SHORT $LN250@main
$LN254@main:

; 55   : 	}
; 56   : 
; 57   : 	return image;

	xor	r13d, r13d
$LN250@main:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 198  : 	vc_gray_edge_prewitt(original, prewitt, 0.970);

	movaps	xmm2, xmm11
	mov	rdx, r15
	mov	rcx, rbx
	call	vc_gray_edge_prewitt

; 199  : 	//char aux1[] = "fase1_prewitt.pgm";
; 200  : 	//vc_write_image(aux1, prewitt);
; 201  : 
; 202  : 	//Dilate
; 203  : 	vc_binary_dilate(prewitt, dilate, 3);

	mov	rdx, r12
	mov	rcx, r15
	call	vc_binary_dilate

; 204  : 	//char aux[] = "fase1_dilate.pgm";
; 205  : 	//vc_write_image(aux, dilate);
; 206  : 
; 207  : 	//Detecta a linha da matricula e retorna o valor
; 208  : 	detected_y = vc_trab_detect(dilate);

	mov	rcx, r12
	call	vc_trab_detect

; 307  : 
; 308  : 		detected_line = vc_trab_fase1(gray);
; 309  : 		//
; 310  : 		if (detected_line != -1)

	cmp	eax, -1
	je	SHORT $LN6@main

; 311  : 		{
; 312  : 			//FASE 2
; 313  : 			blob = vc_trab_fase2(gray, license, detected_line);

	mov	r8d, eax
	mov	rdx, QWORD PTR license$1$[rsp]
	mov	rcx, rbx
	call	vc_trab_fase2
	mov	rbx, rax

; 314  : 			printf("Fase 2 concluida\n");

	lea	rcx, OFFSET FLAT:??_C@_0BC@EKELLDGB@Fase?52?5concluida?6@
	call	printf

; 315  : 
; 316  : 				
; 317  : 			//FASE 3
; 318  : 			vc_trab_fase3(img, result, license, blob);

	mov	r9, rbx
	mov	r8, QWORD PTR license$1$[rsp]
	mov	rdx, rsi
	mov	rcx, rdi
	call	vc_trab_fase3

; 319  : 			printf("Fase 3 concluida\n\n");

	lea	rcx, OFFSET FLAT:??_C@_0BD@FNBPBDIB@Fase?53?5concluida?6?6@
	call	printf
$LN6@main:

; 320  : 		}
; 321  : 		//else
; 322  : 			printf("Frame %d: A matricula não foi detectada.\n",video.nframe);

	mov	edx, r14d
	lea	rcx, OFFSET FLAT:??_C@_0CL@JDABLFJH@Frame?5?$CFd?3?5A?5matricula?5n?C?$KDo?5foi?5@
	call	printf
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c

; 1821 : 	for (x = 0; x < original->width; x++)

	mov	r10d, r13d
	cmp	DWORD PTR [rsi+8], 0
	jle	SHORT $LN262@main
	mov	eax, DWORD PTR [rsi+12]
	npad	1
$LL263@main:

; 1822 : 	{
; 1823 : 		for (y = 0; y < original->height; y++)

	mov	r9d, r13d
	test	eax, eax
	jle	SHORT $LN261@main
	npad	9
$LL266@main:

; 1826 : 			temp = original->data[pos];

	mov	r8, QWORD PTR [rsi]

; 1824 : 		{
; 1825 : 			pos = y * original->bytesperline + x * original->channels;

	mov	ecx, r9d
	imul	ecx, DWORD PTR [rsi+24]
	mov	eax, r10d
	imul	eax, DWORD PTR [rsi+16]
	add	ecx, eax

; 1826 : 			temp = original->data[pos];

	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rdx+r8]

; 1827 : 			original->data[pos] = original->data[pos + 2];

	movzx	eax, BYTE PTR [rdx+r8+2]
	mov	BYTE PTR [rdx+r8], al

; 1828 : 			original->data[pos + 2] = (unsigned char)temp;

	mov	rax, QWORD PTR [rsi]
	mov	BYTE PTR [rdx+rax+2], cl

; 1822 : 	{
; 1823 : 		for (y = 0; y < original->height; y++)

	inc	r9d
	mov	eax, DWORD PTR [rsi+12]
	cmp	r9d, eax
	jl	SHORT $LL266@main
$LN261@main:

; 1821 : 	for (x = 0; x < original->width; x++)

	inc	r10d
	cmp	r10d, DWORD PTR [rsi+8]
	jl	SHORT $LL263@main
$LN262@main:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 328  : 		memcpy(frame.data, result->data, (video.width * (video.height * 3)));

	mov	r8, QWORD PTR tv6080[rbp-256]
	mov	rdx, QWORD PTR [rsi]
	mov	rcx, QWORD PTR frame$[rbp-240]
	call	memcpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\string

; 492  :     const auto _UVal       = static_cast<_UTy>(_Val);

	mov	r15d, DWORD PTR video$$sroa$1778$1$[rsp]

; 493  :     if (_Val < 0) {

	lea	r9, QWORD PTR _Buff$108[rbp-235]
	mov	r8d, r15d

; 492  :     const auto _UVal       = static_cast<_UTy>(_Val);

	test	r15d, r15d

; 493  :     if (_Val < 0) {

	jns	SHORT $LL286@main

; 458  :     auto _UVal_trunc = _UVal;

	neg	r8d
	npad	6
$LL281@main:

; 459  : #else // ^^^ _WIN64 ^^^ // vvv !_WIN64 vvv
; 460  : 
; 461  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 462  :     if
; 463  :         _CONSTEXPR_IF(_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 464  :             while (_UVal > 0xFFFFFFFFU) {
; 465  :                 auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 466  :                 _UVal /= 1000000000;
; 467  : 
; 468  :                 for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 469  :                     *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 470  :                     _UVal_chunk /= 10;
; 471  :                 }
; 472  :             }
; 473  :         }
; 474  : 
; 475  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 476  : #endif // _WIN64
; 477  : 
; 478  :     do {
; 479  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 480  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 481  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL281@main

; 495  :         *--_RNext = '-';

	dec	r9
	mov	BYTE PTR [r9], 45			; 0000002dH

; 496  :     } else {

	jmp	SHORT $LN274@main
	npad	13
$LL286@main:

; 479  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 480  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 481  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL286@main
$LN274@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T16[rbp-240], r13

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T16[rbp-232], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T16[rbp-256], 0

; 2405 :         if (_First != _Last) {

	lea	rax, QWORD PTR _Buff$108[rbp-235]
	cmp	r9, rax
	je	SHORT $LN297@main

; 2406 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));

	lea	r8, QWORD PTR _Buff$108[rbp-235]
	sub	r8, r9
	mov	rdx, r9
	lea	rcx, QWORD PTR $T16[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
$LN297@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\string

; 493  :     if (_Val < 0) {

	lea	r9, QWORD PTR _Buff$107[rbp-235]

; 492  :     const auto _UVal       = static_cast<_UTy>(_Val);

	test	r14d, r14d

; 493  :     if (_Val < 0) {

	jns	SHORT $LL317@main

; 458  :     auto _UVal_trunc = _UVal;

	neg	r14d
	npad	8
$LL312@main:

; 459  : #else // ^^^ _WIN64 ^^^ // vvv !_WIN64 vvv
; 460  : 
; 461  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 462  :     if
; 463  :         _CONSTEXPR_IF(_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 464  :             while (_UVal > 0xFFFFFFFFU) {
; 465  :                 auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 466  :                 _UVal /= 1000000000;
; 467  : 
; 468  :                 for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 469  :                     *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 470  :                     _UVal_chunk /= 10;
; 471  :                 }
; 472  :             }
; 473  :         }
; 474  : 
; 475  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 476  : #endif // _WIN64
; 477  : 
; 478  :     do {
; 479  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r14d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r14b, cl
	add	r14b, 48				; 00000030H
	mov	BYTE PTR [r9], r14b

; 480  :         _UVal_trunc /= 10;

	mov	r14d, edx

; 481  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL312@main

; 495  :         *--_RNext = '-';

	dec	r9
	mov	BYTE PTR [r9], 45			; 0000002dH

; 496  :     } else {

	jmp	SHORT $LN305@main
	npad	13
$LL317@main:

; 479  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r14d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r14b, cl
	add	r14b, 48				; 00000030H
	mov	BYTE PTR [r9], r14b

; 480  :         _UVal_trunc /= 10;

	mov	r14d, edx

; 481  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL317@main
$LN305@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	rcx, r13
	mov	QWORD PTR $T18[rbp-240], rcx

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	edx, 15
	mov	QWORD PTR $T18[rbp-232], rdx

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T18[rbp-256], 0

; 2405 :         if (_First != _Last) {

	lea	rax, QWORD PTR _Buff$107[rbp-235]
	cmp	r9, rax
	je	SHORT $LN328@main

; 2406 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));

	lea	r8, QWORD PTR _Buff$107[rbp-235]
	sub	r8, r9
	mov	rdx, r9
	lea	rcx, QWORD PTR $T18[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	rdx, QWORD PTR $T18[rbp-232]
	mov	rcx, QWORD PTR $T18[rbp-240]
$LN328@main:

; 2767 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rax, rdx
	sub	rax, rcx

; 2768 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	r12d, 1
	cmp	rax, r12
	jb	SHORT $LN339@main

; 2769 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR $T18[rbp-240], rax

; 2143 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T18[rbp-256]

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 2144 :         if (_Large_string_engaged()) {

	cmovae	rax, QWORD PTR $T18[rbp-256]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	WORD PTR [rax+rcx], 47			; 0000002fH

; 2773 :             return *this;

	lea	rax, QWORD PTR $T18[rbp-256]
	jmp	SHORT $LN338@main
$LN339@main:

; 2774 :         }
; 2775 : 
; 2776 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], r12
	lea	r9, OFFSET FLAT:??_C@_01KMDKNFGN@?1@
	mov	rdx, r12
	lea	rcx, QWORD PTR $T18[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
$LN338@main:

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	QWORD PTR $T25[rbp-240], r13
	mov	QWORD PTR $T25[rbp-232], r13

; 2512 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rax]
	movups	XMMWORD PTR $T25[rbp-256], xmm0
	movups	xmm1, XMMWORD PTR [rax+16]
	movups	XMMWORD PTR $T25[rbp-240], xmm1

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rax+16], r13

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rax+24], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rax], 0
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 331  : 		str = std::string("FRAME: ").append(std::to_string(video.nframe) + "/" + std::to_string(video.ntotalframes));

	lea	r8, QWORD PTR $T16[rbp-256]
	lea	rdx, QWORD PTR $T25[rbp-256]
	lea	rcx, QWORD PTR $T28[rbp-256]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	mov	rdi, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T30[rbp-240], r13

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T30[rbp-232], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T30[rbp-256], 0

; 2892 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 7
	lea	rdx, OFFSET FLAT:??_C@_07LFLALKLI@FRAME?3?5@
	lea	rcx, QWORD PTR $T30[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	r9, rdi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+24], 16

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN376@main

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rdi]
$LN376@main:

; 2740 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rdi, QWORD PTR [rdi+16]

; 2767 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T30[rbp-240]
	mov	rdx, QWORD PTR $T30[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 2768 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rdi, rax
	ja	SHORT $LN381@main

; 2769 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+rdi]
	mov	QWORD PTR $T30[rbp-240], rax

; 2143 :         value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR $T30[rbp-256]

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 2144 :         if (_Large_string_engaged()) {

	cmovae	rbx, QWORD PTR $T30[rbp-256]

; 2771 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	add	rbx, rcx

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	r8, rdi
	mov	rdx, r9
	mov	rcx, rbx
	call	memmove

; 2772 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rdi+rbx], 0

; 2773 :             return *this;

	lea	rax, QWORD PTR $T30[rbp-256]
	jmp	SHORT $LN1178@main
$LN381@main:

; 2774 :         }
; 2775 : 
; 2776 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], rdi
	mov	rdx, rdi
	lea	rcx, QWORD PTR $T30[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>

; 2693 :         if (this != _STD addressof(_Right)) {

	lea	rcx, QWORD PTR str$[rbp-256]
	cmp	rcx, rax
	je	SHORT $LN391@main
$LN1178@main:

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rax+24], 16

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN396@main

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rax]
$LN396@main:

; 2658 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rax+16]
	lea	rcx, QWORD PTR str$[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
$LN391@main:

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T30[rbp-232]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN412@main

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T30[rbp-256]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN423@main

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN420@main
$LN423@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN412@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4217 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T30[rbp-240], r13

; 4218 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T30[rbp-232], 15

; 4219 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4220 :         // write can alias this
; 4221 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T30[rbp-256], 0

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T28[rbp-232]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN440@main

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T28[rbp-256]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN451@main

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN448@main
$LN451@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN440@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4217 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T28[rbp-240], r13

; 4218 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T28[rbp-232], 15

; 4219 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4220 :         // write can alias this
; 4221 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T28[rbp-256], 0

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T25[rbp-232]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN468@main

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T25[rbp-256]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN479@main

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN476@main
$LN479@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN468@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4217 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T25[rbp-240], r13

; 4218 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T25[rbp-232], 15

; 4219 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4220 :         // write can alias this
; 4221 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T25[rbp-256], 0

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T18[rbp-232]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN496@main

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T18[rbp-256]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN507@main

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN504@main
$LN507@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN496@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4217 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T18[rbp-240], r13

; 4218 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T18[rbp-232], 15

; 4219 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4220 :         // write can alias this
; 4221 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T18[rbp-256], 0

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T16[rbp-232]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN524@main

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T16[rbp-256]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN535@main

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN532@main
$LN535@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN524@main:
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	mov	QWORD PTR $T47[rbp-240], 0
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	DWORD PTR $T47[rbp-256], 50397184	; 03010000H
	lea	rax, QWORD PTR frame$[rbp-256]
	mov	QWORD PTR $T47[rbp-248], rax
	xorps	xmm0, xmm0
; File C:\opencv\build\include\opencv2\core\types.hpp

; 2160 :     this->val[0] = v0;

	movups	XMMWORD PTR $T43[rbp-256], xmm0
	xorps	xmm1, xmm1
	movups	XMMWORD PTR $T43[rbp-240], xmm1

; 1165 :     : x(_x), y(_y) {}

	mov	DWORD PTR $T45[rbp-256], 20
	mov	DWORD PTR $T45[rbp-252], 25
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 332  : 		cv::putText(frame, str, cv::Point(20, 25), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 0), 2);

	mov	BYTE PTR [rsp+64], 0
	mov	DWORD PTR [rsp+56], 8
	mov	DWORD PTR [rsp+48], 2
	lea	rax, QWORD PTR $T43[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	movsd	QWORD PTR [rsp+32], xmm10
	xor	r9d, r9d
	lea	r8, QWORD PTR $T45[rbp-256]
	lea	rdx, QWORD PTR str$[rbp-256]
	lea	rcx, QWORD PTR $T47[rbp-256]
	call	QWORD PTR __imp_?putText@cv@@YAXAEBV_InputOutputArray@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$Point_@H@1@HNV?$Scalar_@N@1@HH_N@Z
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	mov	QWORD PTR $T52[rbp-240], 0
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	DWORD PTR $T52[rbp-256], 50397184	; 03010000H
	lea	rax, QWORD PTR frame$[rbp-256]
	mov	QWORD PTR $T52[rbp-248], rax
; File C:\opencv\build\include\opencv2\core\types.hpp

; 2160 :     this->val[0] = v0;

	movaps	xmm0, XMMWORD PTR __xmm@406fe00000000000406fe00000000000
	movups	XMMWORD PTR $T48[rbp-256], xmm0

; 2161 :     this->val[1] = v1;
; 2162 :     this->val[2] = v2;

	movaps	xmm1, XMMWORD PTR __xmm@0000000000000000406fe00000000000
	movups	XMMWORD PTR $T48[rbp-240], xmm1

; 1165 :     : x(_x), y(_y) {}

	mov	DWORD PTR $T50[rbp-256], 20
	mov	DWORD PTR $T50[rbp-252], 25
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 333  : 		cv::putText(frame, str, cv::Point(20, 25), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(255, 255, 255), 1);

	mov	BYTE PTR [rsp+64], 0
	mov	DWORD PTR [rsp+56], 8
	mov	DWORD PTR [rsp+48], r12d
	lea	rax, QWORD PTR $T48[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	movsd	QWORD PTR [rsp+32], xmm10
	xor	r9d, r9d
	lea	r8, QWORD PTR $T50[rbp-256]
	lea	rdx, QWORD PTR str$[rbp-256]
	lea	rcx, QWORD PTR $T52[rbp-256]
	call	QWORD PTR __imp_?putText@cv@@YAXAEBV_InputOutputArray@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$Point_@H@1@HNV?$Scalar_@N@1@HH_N@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T53[rbp-240], r13

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T53[rbp-232], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T53[rbp-256], 0

; 2892 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 11
	lea	rdx, OFFSET FLAT:??_C@_0M@NHHODHJD@Matricula?3?5@
	lea	rcx, QWORD PTR $T53[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 2767 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T53[rbp-240]
	mov	rdx, QWORD PTR $T53[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 2768 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rax, 8
	jb	SHORT $LN607@main

; 2769 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR $T53[rbp-240], rax

; 2143 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T53[rbp-256]

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 2144 :         if (_Large_string_engaged()) {

	cmovae	rax, QWORD PTR $T53[rbp-256]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	rdx, 4051319171368957751		; 38392d52512d3737H
	mov	QWORD PTR [rax+rcx], rdx

; 2772 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rax+rcx+8], 0

; 2773 :             return *this;

	lea	rax, QWORD PTR $T53[rbp-256]
	jmp	SHORT $LN1179@main
$LN607@main:

; 2774 :         }
; 2775 : 
; 2776 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], 8
	lea	r9, OFFSET FLAT:??_C@_08JJLIBGIM@77?9QR?998@
	mov	edx, 8
	lea	rcx, QWORD PTR $T53[rbp-256]
	call	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>

; 2693 :         if (this != _STD addressof(_Right)) {

	lea	rcx, QWORD PTR str$[rbp-256]
	cmp	rcx, rax
	je	SHORT $LN617@main
$LN1179@main:

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rax+24], 16

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN622@main

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rax]
$LN622@main:

; 2658 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rax+16]
	lea	rcx, QWORD PTR str$[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
$LN617@main:

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T53[rbp-232]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN638@main

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T53[rbp-256]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN649@main

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN646@main
$LN649@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN638@main:
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	mov	QWORD PTR $T67[rbp-240], 0
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	DWORD PTR $T67[rbp-256], 50397184	; 03010000H
	lea	rax, QWORD PTR frame$[rbp-256]
	mov	QWORD PTR $T67[rbp-248], rax
	xorps	xmm0, xmm0
; File C:\opencv\build\include\opencv2\core\types.hpp

; 2160 :     this->val[0] = v0;

	movups	XMMWORD PTR $T63[rbp-256], xmm0
	xorps	xmm1, xmm1
	movups	XMMWORD PTR $T63[rbp-240], xmm1

; 1165 :     : x(_x), y(_y) {}

	mov	DWORD PTR $T65[rbp-256], 20
	mov	DWORD PTR $T65[rbp-252], 50		; 00000032H
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 335  : 		cv::putText(frame, str, cv::Point(20, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 0), 2);

	mov	BYTE PTR [rsp+64], 0
	mov	DWORD PTR [rsp+56], 8
	mov	DWORD PTR [rsp+48], 2
	lea	rax, QWORD PTR $T63[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	movsd	QWORD PTR [rsp+32], xmm10
	xor	r9d, r9d
	lea	r8, QWORD PTR $T65[rbp-256]
	lea	rdx, QWORD PTR str$[rbp-256]
	lea	rcx, QWORD PTR $T67[rbp-256]
	call	QWORD PTR __imp_?putText@cv@@YAXAEBV_InputOutputArray@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$Point_@H@1@HNV?$Scalar_@N@1@HH_N@Z
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	mov	QWORD PTR $T72[rbp-240], 0
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	DWORD PTR $T72[rbp-256], 50397184	; 03010000H
	lea	rax, QWORD PTR frame$[rbp-256]
	mov	QWORD PTR $T72[rbp-248], rax
; File C:\opencv\build\include\opencv2\core\types.hpp

; 2160 :     this->val[0] = v0;

	movaps	xmm0, XMMWORD PTR __xmm@406fe00000000000406fe00000000000
	movups	XMMWORD PTR $T68[rbp-256], xmm0

; 2161 :     this->val[1] = v1;
; 2162 :     this->val[2] = v2;

	movaps	xmm1, XMMWORD PTR __xmm@0000000000000000406fe00000000000
	movups	XMMWORD PTR $T68[rbp-240], xmm1

; 1165 :     : x(_x), y(_y) {}

	mov	DWORD PTR $T70[rbp-256], 20
	mov	DWORD PTR $T70[rbp-252], 50		; 00000032H
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 336  : 		cv::putText(frame, str, cv::Point(20, 50), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(255, 255, 255), 1);

	mov	BYTE PTR [rsp+64], 0
	mov	DWORD PTR [rsp+56], 8
	mov	DWORD PTR [rsp+48], r12d
	lea	rax, QWORD PTR $T68[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	movsd	QWORD PTR [rsp+32], xmm10
	xor	r9d, r9d
	lea	r8, QWORD PTR $T70[rbp-256]
	lea	rdx, QWORD PTR str$[rbp-256]
	lea	rcx, QWORD PTR $T72[rbp-256]
	call	QWORD PTR __imp_?putText@cv@@YAXAEBV_InputOutputArray@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$Point_@H@1@HNV?$Scalar_@N@1@HH_N@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\string

; 497  :         _RNext = _UIntegral_to_buff(_RNext, _UVal);

	lea	r9, QWORD PTR _Buff$109[rbp-235]

; 458  :     auto _UVal_trunc = _UVal;

	mov	r8d, r13d
	npad	6
$LL722@main:

; 459  : #else // ^^^ _WIN64 ^^^ // vvv !_WIN64 vvv
; 460  : 
; 461  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 462  :     if
; 463  :         _CONSTEXPR_IF(_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 464  :             while (_UVal > 0xFFFFFFFFU) {
; 465  :                 auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 466  :                 _UVal /= 1000000000;
; 467  : 
; 468  :                 for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 469  :                     *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 470  :                     _UVal_chunk /= 10;
; 471  :                 }
; 472  :             }
; 473  :         }
; 474  : 
; 475  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 476  : #endif // _WIN64
; 477  : 
; 478  :     do {
; 479  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 480  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 481  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL722@main
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	rdi, r13
	mov	QWORD PTR $T73[rbp-240], r13

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	r14d, 15
	mov	QWORD PTR $T73[rbp-232], r14

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T73[rbp-256], dl

; 2405 :         if (_First != _Last) {

	lea	rax, QWORD PTR _Buff$109[rbp-235]
	cmp	r9, rax
	je	SHORT $LN733@main

; 2406 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));

	lea	r8, QWORD PTR _Buff$109[rbp-235]
	sub	r8, r9
	mov	rdx, r9
	lea	rcx, QWORD PTR $T73[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	r14, QWORD PTR $T73[rbp-232]
	mov	rdi, QWORD PTR $T73[rbp-240]
$LN733@main:

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T76[rbp-240], r13

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T76[rbp-232], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T76[rsp], 0

; 2892 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 17
	lea	rdx, OFFSET FLAT:??_C@_0BC@MEHHJOD@N?5de?5matriculas?3?5@
	lea	rcx, QWORD PTR $T76[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1

; 2152 :         const value_type* _Result = _Bx._Buf;

	lea	r9, QWORD PTR $T73[rbp-256]

; 2153 :         if (_Large_string_engaged()) {

	mov	rsi, QWORD PTR $T73[rbp-256]

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	r14, 16

; 2153 :         if (_Large_string_engaged()) {

	cmovae	r9, rsi

; 2767 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR $T76[rbp-240]
	mov	rdx, QWORD PTR $T76[rbp-232]
	mov	rax, rdx
	sub	rax, rcx

; 2768 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rdi, rax
	ja	SHORT $LN755@main

; 2769 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rdi+rcx]
	mov	QWORD PTR $T76[rbp-240], rax

; 2143 :         value_type* _Result = _Bx._Buf;

	lea	rbx, QWORD PTR $T76[rsp]

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 2144 :         if (_Large_string_engaged()) {

	cmovae	rbx, QWORD PTR $T76[rsp]

; 2771 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	add	rbx, rcx

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	r8, rdi
	mov	rdx, r9
	mov	rcx, rbx
	call	memmove

; 2772 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rbx+rdi], 0

; 2773 :             return *this;

	lea	rax, QWORD PTR $T76[rsp]
	jmp	SHORT $LN1180@main
$LN755@main:

; 2774 :         }
; 2775 : 
; 2776 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+32], rdi
	mov	rdx, rdi
	lea	rcx, QWORD PTR $T76[rsp]
	call	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>

; 2693 :         if (this != _STD addressof(_Right)) {

	lea	rcx, QWORD PTR str$[rbp-256]
	mov	r14, QWORD PTR $T73[rbp-232]
	mov	rsi, QWORD PTR $T73[rbp-256]
	cmp	rcx, rax
	je	SHORT $LN765@main
$LN1180@main:

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, rax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rax+24], 16

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN770@main

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [rax]
$LN770@main:

; 2658 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rax+16]
	lea	rcx, QWORD PTR str$[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
$LN765@main:

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T76[rbp-232]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN786@main

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T76[rsp]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN797@main

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN794@main
$LN797@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN786@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4217 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T76[rbp-240], r13

; 4218 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T76[rbp-232], 15

; 4219 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4220 :         // write can alias this
; 4221 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T76[rsp], 0

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	r14, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN814@main

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	lea	rdx, QWORD PTR [r14+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rax, rsi

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN825@main

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rsi, QWORD PTR [rsi-8]
	sub	rax, rsi

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	$LN822@main
$LN825@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN814@main:
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	mov	QWORD PTR $T90[rbp-240], 0
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	DWORD PTR $T90[rbp-256], 50397184	; 03010000H
	lea	rax, QWORD PTR frame$[rbp-256]
	mov	QWORD PTR $T90[rbp-248], rax
	xorps	xmm0, xmm0
; File C:\opencv\build\include\opencv2\core\types.hpp

; 2160 :     this->val[0] = v0;

	movups	XMMWORD PTR $T86[rbp-256], xmm0
	xorps	xmm1, xmm1
	movups	XMMWORD PTR $T86[rbp-240], xmm1

; 1165 :     : x(_x), y(_y) {}

	mov	DWORD PTR $T88[rbp-256], 20
	mov	DWORD PTR $T88[rbp-252], 75		; 0000004bH
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 338  : 		cv::putText(frame, str, cv::Point(20, 75), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0, 0, 0), 2);

	mov	BYTE PTR [rsp+64], 0
	mov	DWORD PTR [rsp+56], 8
	mov	DWORD PTR [rsp+48], 2
	lea	rax, QWORD PTR $T86[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	movsd	QWORD PTR [rsp+32], xmm10
	xor	r9d, r9d
	lea	r8, QWORD PTR $T88[rbp-256]
	lea	rdx, QWORD PTR str$[rbp-256]
	lea	rcx, QWORD PTR $T90[rbp-256]
	call	QWORD PTR __imp_?putText@cv@@YAXAEBV_InputOutputArray@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$Point_@H@1@HNV?$Scalar_@N@1@HH_N@Z
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	mov	QWORD PTR $T95[rbp-240], 0
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	DWORD PTR $T95[rbp-256], 50397184	; 03010000H
	lea	rax, QWORD PTR frame$[rbp-256]
	mov	QWORD PTR $T95[rbp-248], rax
; File C:\opencv\build\include\opencv2\core\types.hpp

; 2160 :     this->val[0] = v0;

	movaps	xmm0, XMMWORD PTR __xmm@406fe00000000000406fe00000000000
	movups	XMMWORD PTR $T91[rbp-256], xmm0

; 2161 :     this->val[1] = v1;
; 2162 :     this->val[2] = v2;

	movaps	xmm1, XMMWORD PTR __xmm@0000000000000000406fe00000000000
	movups	XMMWORD PTR $T91[rbp-240], xmm1

; 1165 :     : x(_x), y(_y) {}

	mov	DWORD PTR $T93[rbp-256], 20
	mov	DWORD PTR $T93[rbp-252], 75		; 0000004bH
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 339  : 		cv::putText(frame, str, cv::Point(20, 75), cv::FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(255, 255, 255), 1);

	mov	BYTE PTR [rsp+64], 0
	mov	DWORD PTR [rsp+56], 8
	mov	DWORD PTR [rsp+48], r12d
	lea	rax, QWORD PTR $T91[rbp-256]
	mov	QWORD PTR [rsp+40], rax
	movsd	QWORD PTR [rsp+32], xmm10
	xor	r9d, r9d
	lea	r8, QWORD PTR $T93[rbp-256]
	lea	rdx, QWORD PTR str$[rbp-256]
	lea	rcx, QWORD PTR $T95[rbp-256]
	call	QWORD PTR __imp_?putText@cv@@YAXAEBV_InputOutputArray@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$Point_@H@1@HNV?$Scalar_@N@1@HH_N@Z
; File C:\opencv\build\include\opencv2\core\types.hpp

; 1682 :     : width(0), height(0) {}

	mov	QWORD PTR $T96[rbp-240], 0
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 92   : { flags = _flags; obj = (void*)_obj; }

	mov	DWORD PTR $T96[rbp-256], 16842752	; 01010000H
	lea	rax, QWORD PTR frame$[rbp-256]
	mov	QWORD PTR $T96[rbp-248], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T97[rbp-240], r13

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T97[rbp-232], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T97[rbp-256], 0

; 2892 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02LDNLGICJ@VC@
	lea	rcx, QWORD PTR $T97[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 342  : 		cv::imshow("VC", frame);

	lea	rdx, QWORD PTR $T96[rbp-256]
	lea	rcx, QWORD PTR $T97[rbp-256]
	call	QWORD PTR __imp_?imshow@cv@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBV_InputArray@1@@Z
	npad	1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T97[rbp-232]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN910@main

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T97[rbp-256]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN921@main

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN918@main
$LN921@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN910@main:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 345  : 		key = cv::waitKey(1);

	mov	ecx, r12d
	call	QWORD PTR __imp_?waitKey@cv@@YAHH@Z

; 264  : 	while (key != 'q')

	cmp	eax, 113				; 00000071H
	je	SHORT $LN3@main
	mov	ebx, DWORD PTR video$$sroa$1777$1$[rsp]
	mov	esi, DWORD PTR video$$sroa$1776$1$[rsp]
	jmp	$LL2@main
$LN420@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN448@main:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN476@main:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN504@main:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN532@main:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN646@main:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN794@main:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN822@main:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN918@main:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN3@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR $T101[rbp-240], r13

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR $T101[rbp-232], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T101[rbp-256], 0

; 2892 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02LDNLGICJ@VC@
	lea	rcx, QWORD PTR $T101[rbp-256]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 351  : 	cv::destroyWindow("VC");

	lea	rcx, QWORD PTR $T101[rbp-256]
	call	QWORD PTR __imp_?destroyWindow@cv@@YAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	npad	1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T101[rbp-232]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN950@main

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T101[rbp-256]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN961@main

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN961@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN961@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN950@main:
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 354  : 	capture.release();

	lea	rcx, QWORD PTR capture$[rbp-256]
	call	QWORD PTR __imp_?release@VideoCapture@cv@@UEAAXXZ

; 357  : 	return 0;

	mov	ebx, r13d
; File C:\opencv\build\include\opencv2\core\mat.inl.hpp

; 865  :     if( u && CV_XADD(&u->refcount, -1) == 1 )

	mov	rax, QWORD PTR frame$[rbp-200]
	test	rax, rax
	je	SHORT $LN974@main
	mov	rdi, -1
	lock xadd DWORD PTR [rax+20], edi
	cmp	edi, 1
	jne	SHORT $LN974@main

; 866  :         deallocate();

	lea	rcx, QWORD PTR frame$[rbp-256]
	call	QWORD PTR __imp_?deallocate@Mat@cv@@QEAAXXZ
$LN974@main:

; 867  :     u = NULL;

	mov	QWORD PTR frame$[rbp-200], r13

; 868  :     datastart = dataend = datalimit = data = 0;

	mov	QWORD PTR frame$[rbp-240], r13
	mov	QWORD PTR frame$[rbp-216], r13
	mov	QWORD PTR frame$[rbp-224], r13
	mov	QWORD PTR frame$[rbp-232], r13

; 869  :     for(int i = 0; i < dims; i++)

	mov	ecx, r13d
	cmp	DWORD PTR frame$[rbp-252], 0
	jle	SHORT $LN972@main
	mov	rdx, r13
	npad	5
$LL973@main:

; 870  :         size.p[i] = 0;

	mov	rax, QWORD PTR frame$[rbp-192]
	mov	DWORD PTR [rax+rdx], r13d

; 869  :     for(int i = 0; i < dims; i++)

	inc	ecx
	lea	rdx, QWORD PTR [rdx+4]
	cmp	ecx, DWORD PTR frame$[rbp-252]
	jl	SHORT $LL973@main
$LN972@main:

; 753  :     if( step.p != step.buf )

	lea	rax, QWORD PTR frame$[rbp-176]
	mov	rcx, QWORD PTR frame$[rbp-184]
	cmp	rcx, rax
	je	SHORT $LN967@main

; 754  :         fastFree(step.p);

	call	QWORD PTR __imp_?fastFree@cv@@YAXPEAX@Z
	npad	1
$LN967@main:
$LN968@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR str$[rbp-232]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN988@main

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR str$[rbp-256]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN999@main

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN999@main
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN999@main:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN988@main:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4217 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR str$[rbp-240], r13

; 4218 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR str$[rbp-232], 15

; 4219 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4220 :         // write can alias this
; 4221 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR str$[rbp-256], 0
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\main.cpp

; 357  : 	return 0;

	lea	rcx, QWORD PTR capture$[rbp-256]
	call	QWORD PTR __imp_??1VideoCapture@cv@@UEAA@XZ
	mov	eax, ebx

; 358  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+1376]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN1186@main:
main	ENDP
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$0 PROC
	lea	rcx, QWORD PTR capture$[rdx]
	rex_jmp	QWORD PTR __imp_??1VideoCapture@cv@@UEAA@XZ
main$dtor$0 ENDP
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$1 PROC
	lea	rcx, QWORD PTR str$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$1 ENDP
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$2 PROC
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$2 ENDP
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$3 PROC
	lea	rcx, QWORD PTR $T10[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$3 ENDP
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$4 PROC
	lea	rcx, QWORD PTR frame$[rdx]
	jmp	??1Mat@cv@@QEAA@XZ			; cv::Mat::~Mat
main$dtor$4 ENDP
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$5 PROC
	lea	rcx, QWORD PTR $T16[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$5 ENDP
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$6 PROC
	lea	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$6 ENDP
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$7 PROC
	lea	rcx, QWORD PTR $T25[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$7 ENDP
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$8 PROC
	lea	rcx, QWORD PTR $T28[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$8 ENDP
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$9 PROC
	lea	rcx, QWORD PTR $T30[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$9 ENDP
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$10 PROC
	lea	rcx, QWORD PTR $T53[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$10 ENDP
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$11 PROC
	lea	rcx, QWORD PTR $T73[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$11 ENDP
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$12 PROC
	lea	rcx, QWORD PTR $T76[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$12 ENDP
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$13 PROC
	lea	rcx, QWORD PTR $T97[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$13 ENDP
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$14 PROC
	lea	rcx, QWORD PTR $T101[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$14 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$0 PROC
	lea	rcx, QWORD PTR capture$[rdx]
	rex_jmp	QWORD PTR __imp_??1VideoCapture@cv@@UEAA@XZ
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$1 PROC
	lea	rcx, QWORD PTR str$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$1 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$2 PROC
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$2 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$3 PROC
	lea	rcx, QWORD PTR $T10[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$3 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$4 PROC
	lea	rcx, QWORD PTR frame$[rdx]
	jmp	??1Mat@cv@@QEAA@XZ			; cv::Mat::~Mat
main$dtor$4 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$5 PROC
	lea	rcx, QWORD PTR $T16[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$5 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$6 PROC
	lea	rcx, QWORD PTR $T18[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$6 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$7 PROC
	lea	rcx, QWORD PTR $T25[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$7 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$8 PROC
	lea	rcx, QWORD PTR $T28[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$8 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$9 PROC
	lea	rcx, QWORD PTR $T30[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$9 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$10 PROC
	lea	rcx, QWORD PTR $T53[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$10 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$11 PROC
	lea	rcx, QWORD PTR $T73[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$11 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$12 PROC
	lea	rcx, QWORD PTR $T76[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$12 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$13 PROC
	lea	rcx, QWORD PTR $T97[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$13 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
height$1$ = 80
height$1$ = 80
height$1$ = 80
license$1$ = 88
video$$sroa$1778$1$ = 96
video$$sroa$1777$1$ = 100
video$$sroa$1776$1$ = 104
$T76 = 112
$T18 = 144
$T30 = 176
$T53 = 208
$T45 = 240
$T50 = 248
$T65 = 256
$T70 = 264
$T88 = 272
$T93 = 280
$T73 = 288
$T25 = 320
tv6080 = 352
$T3 = 360
$T10 = 392
$T16 = 424
$T97 = 456
$T101 = 488
$T52 = 520
$T96 = 544
$T14 = 568
$T47 = 592
$T67 = 616
$T72 = 640
$T90 = 664
$T95 = 688
$T28 = 712
$T43 = 744
$T48 = 776
$T63 = 808
$T68 = 840
$T86 = 872
$T91 = 904
frame$ = 944
str$ = 1040
capture$ = 1072
i_gray$106 = 1120
_Buff$107 = 1136
_Buff$108 = 1160
videofile$ = 1184
_Buff$109 = 1248
__$ArrayPad$ = 1272
main$dtor$14 PROC
	lea	rcx, QWORD PTR $T101[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$14 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z PROC ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::get_value, COMDAT

; 101  :     virtual const void* get_value(void* const * src) CV_OVERRIDE { return *src; }

	mov	rax, QWORD PTR [rdx]
	ret	0
?get_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::get_value, COMDAT

; 100  :     virtual void* get_value(void** src) CV_OVERRIDE { return *src; }

	mov	rax, QWORD PTR [rdx]
	ret	0
?get_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\opencv\build\include\opencv2\flann\any.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\opencv\build\include\opencv2\flann\any.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?move@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
src$ = 56
dest$ = 64
?move@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::move, COMDAT

; 96   :     {

$LN49:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rsi, rdx

; 97   :         (*reinterpret_cast<T**>(dest))->~T();

	mov	rbx, QWORD PTR [r8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN18@move

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

	mov	rcx, QWORD PTR [rbx]

; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN29@move

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN26@move

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN29@move:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN18@move:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4217 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4218 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4219 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4220 :         // write can alias this
; 4221 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
; File C:\opencv\build\include\opencv2\flann\any.h

; 98   :         **reinterpret_cast<T**>(dest) = **reinterpret_cast<T* const*>(src);

	mov	r8, QWORD PTR [rsi]
	mov	rcx, QWORD PTR [rdi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2693 :         if (this != _STD addressof(_Right)) {

	cmp	rcx, r8
	je	SHORT $LN37@move

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, r8

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [r8+24], 16

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN42@move

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdx, QWORD PTR [r8]
$LN42@move:

; 2658 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [r8+16]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN37@move:
; File C:\opencv\build\include\opencv2\flann\any.h

; 99   :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN26@move:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN46@move:
?move@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
src$ = 56
$T1 = 64
dest$ = 64
?clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::clone, COMDAT

; 92   :     {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx

; 93   :         *dest = new T(**reinterpret_cast<T* const*>(src));

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rdx, QWORD PTR [rbx]
	mov	rcx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	QWORD PTR [rdi], rax

; 94   :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::clone
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
src$ = 56
$T1 = 64
dest$ = 64
?dtor$0@?0??clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z@4HA PROC ; `cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::clone'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z@4HA ENDP ; `cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::clone'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
src$ = 56
$T1 = 64
dest$ = 64
?dtor$0@?0??clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z@4HA PROC ; `cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::clone'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??clone@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z@4HA ENDP ; `cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::clone'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
src$ = 56
$T1 = 64
dest$ = 64
?copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::copy_from_value, COMDAT

; 88   :     {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r8
	mov	rbx, rdx

; 89   :         *dest = new T(*reinterpret_cast<T const*>(src));

	mov	ecx, 32					; 00000020H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rdx, rbx
	mov	rcx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	QWORD PTR [rdi], rax

; 90   :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::copy_from_value
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
src$ = 56
$T1 = 64
dest$ = 64
?dtor$0@?0??copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z@4HA PROC ; `cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::copy_from_value'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z@4HA ENDP ; `cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::copy_from_value'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
src$ = 56
$T1 = 64
dest$ = 64
?dtor$0@?0??copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z@4HA PROC ; `cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::copy_from_value'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR $T1[rbp]
	call	??3@YAXPEAX_K@Z				; operator delete
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??copy_from_value@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z@4HA ENDP ; `cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::copy_from_value'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\opencv\build\include\opencv2\flann\any.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?static_delete@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
x$ = 56
?static_delete@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::static_delete, COMDAT

; 83   :     {

$LN42:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 84   :         if (* x) delete (* reinterpret_cast<T**>(x));

	mov	rbx, QWORD PTR [rdx]
	test	rbx, rbx
	je	SHORT $LN7@static_del
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rbx+24]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN21@static_del

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

	mov	rcx, QWORD PTR [rbx]

; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN32@static_del

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN29@static_del

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN32@static_del:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN21@static_del:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4217 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4218 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4219 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4220 :         // write can alias this
; 4221 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
	mov	edx, 32					; 00000020H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN7@static_del:
; File C:\opencv\build\include\opencv2\flann\any.h

; 85   :         *x = NULL;

	mov	QWORD PTR [rdi], 0

; 86   :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN29@static_del:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN39@static_del:
?static_delete@?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::static_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?type@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
_TEXT	SEGMENT
this$ = 8
?type@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::type, COMDAT

; 60   :     virtual const std::type_info& type() CV_OVERRIDE { return typeid(T); }

	lea	rax, OFFSET FLAT:??_R0?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	ret	0
?type@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_size@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAA_KXZ
_TEXT	SEGMENT
this$ = 8
?get_size@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAA_KXZ PROC ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::get_size, COMDAT

; 59   :     virtual ::size_t get_size() CV_OVERRIDE { return sizeof(T); }

	mov	eax, 32					; 00000020H
	ret	0
?get_size@?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAA_KXZ ENDP ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::get_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::get_value, COMDAT

; 101  :     virtual const void* get_value(void* const * src) CV_OVERRIDE { return *src; }

	mov	rax, QWORD PTR [rdx]
	ret	0
?get_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::get_value, COMDAT

; 100  :     virtual void* get_value(void** src) CV_OVERRIDE { return *src; }

	mov	rax, QWORD PTR [rdx]
	ret	0
?get_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?move@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?move@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::move, COMDAT

; 97   :         (*reinterpret_cast<T**>(dest))->~T();
; 98   :         **reinterpret_cast<T**>(dest) = **reinterpret_cast<T* const*>(src);

	mov	rax, QWORD PTR [rdx]
	mov	rcx, QWORD PTR [r8]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 99   :     }

	ret	0
?move@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?clone@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
src$ = 56
dest$ = 64
?clone@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::clone, COMDAT

; 92   :     {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 93   :         *dest = new T(**reinterpret_cast<T* const*>(src));

	mov	ecx, 4
	mov	rdi, r8
	mov	rbx, rdx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, QWORD PTR [rbx]

; 94   :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	edx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], edx
	mov	QWORD PTR [rdi], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?clone@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::clone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?copy_from_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
src$ = 56
dest$ = 64
?copy_from_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::copy_from_value, COMDAT

; 88   :     {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 89   :         *dest = new T(*reinterpret_cast<T const*>(src));

	mov	ecx, 4
	mov	rdi, r8
	mov	rbx, rdx
	call	??2@YAPEAX_K@Z				; operator new
	mov	ecx, DWORD PTR [rbx]

; 90   :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rax], ecx
	mov	QWORD PTR [rdi], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?copy_from_value@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::copy_from_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?static_delete@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
x$ = 56
?static_delete@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::static_delete, COMDAT

; 83   :     {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 84   :         if (* x) delete (* reinterpret_cast<T**>(x));

	mov	rcx, QWORD PTR [rdx]
	mov	rbx, rdx
	test	rcx, rcx
	je	SHORT $LN6@static_del
	mov	edx, 4
	call	??3@YAXPEAX_K@Z				; operator delete

; 85   :         *x = NULL;

	mov	QWORD PTR [rbx], 0

; 86   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN6@static_del:

; 85   :         *x = NULL;

	mov	QWORD PTR [rdx], 0

; 86   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?static_delete@?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::static_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?type@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
_TEXT	SEGMENT
this$ = 8
?type@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::type, COMDAT

; 60   :     virtual const std::type_info& type() CV_OVERRIDE { return typeid(T); }

	lea	rax, OFFSET FLAT:??_R0?AW4flann_algorithm_t@cvflann@@@8
	ret	0
?type@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_size@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAA_KXZ
_TEXT	SEGMENT
this$ = 8
?get_size@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAA_KXZ PROC ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::get_size, COMDAT

; 59   :     virtual ::size_t get_size() CV_OVERRIDE { return sizeof(T); }

	mov	eax, 4
	ret	0
?get_size@?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAA_KXZ ENDP ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::get_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::get_value, COMDAT

; 101  :     virtual const void* get_value(void* const * src) CV_OVERRIDE { return *src; }

	mov	rax, QWORD PTR [rdx]
	ret	0
?get_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::get_value, COMDAT

; 100  :     virtual void* get_value(void** src) CV_OVERRIDE { return *src; }

	mov	rax, QWORD PTR [rdx]
	ret	0
?get_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?move@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?move@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::move, COMDAT

; 97   :         (*reinterpret_cast<T**>(dest))->~T();
; 98   :         **reinterpret_cast<T**>(dest) = **reinterpret_cast<T* const*>(src);

	mov	rax, QWORD PTR [rdx]
	mov	rcx, QWORD PTR [r8]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax

; 99   :     }

	ret	0
?move@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?clone@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
src$ = 56
dest$ = 64
?clone@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::clone, COMDAT

; 92   :     {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 93   :         *dest = new T(**reinterpret_cast<T* const*>(src));

	mov	ecx, 4
	mov	rdi, r8
	mov	rbx, rdx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, QWORD PTR [rbx]

; 94   :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	edx, DWORD PTR [rcx]
	mov	DWORD PTR [rax], edx
	mov	QWORD PTR [rdi], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?clone@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::clone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?copy_from_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
src$ = 56
dest$ = 64
?copy_from_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::copy_from_value, COMDAT

; 88   :     {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 89   :         *dest = new T(*reinterpret_cast<T const*>(src));

	mov	ecx, 4
	mov	rdi, r8
	mov	rbx, rdx
	call	??2@YAPEAX_K@Z				; operator new
	mov	ecx, DWORD PTR [rbx]

; 90   :     }

	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rax], ecx
	mov	QWORD PTR [rdi], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?copy_from_value@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::copy_from_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?static_delete@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
x$ = 56
?static_delete@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::static_delete, COMDAT

; 83   :     {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 84   :         if (* x) delete (* reinterpret_cast<T**>(x));

	mov	rcx, QWORD PTR [rdx]
	mov	rbx, rdx
	test	rcx, rcx
	je	SHORT $LN6@static_del
	mov	edx, 4
	call	??3@YAXPEAX_K@Z				; operator delete

; 85   :         *x = NULL;

	mov	QWORD PTR [rbx], 0

; 86   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN6@static_del:

; 85   :         *x = NULL;

	mov	QWORD PTR [rdx], 0

; 86   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?static_delete@?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::static_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?type@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
_TEXT	SEGMENT
this$ = 8
?type@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::type, COMDAT

; 60   :     virtual const std::type_info& type() CV_OVERRIDE { return typeid(T); }

	lea	rax, OFFSET FLAT:??_R0?AW4flann_centers_init_t@cvflann@@@8
	ret	0
?type@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_size@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAA_KXZ
_TEXT	SEGMENT
this$ = 8
?get_size@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAA_KXZ PROC ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::get_size, COMDAT

; 59   :     virtual ::size_t get_size() CV_OVERRIDE { return sizeof(T); }

	mov	eax, 4
	ret	0
?get_size@?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAA_KXZ ENDP ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::get_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@c_str

; 3576 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR [rcx]

; 3577 :     }

	ret	0
$LN8@c_str:

; 3576 :         return _Mypair._Myval2._Myptr();

	mov	rax, rcx

; 3577 :     }

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 2787 :     basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

$LN18:
	mov	QWORD PTR [rsp+16], rbx
	push	rsi
	sub	rsp, 48					; 00000030H
	mov	rsi, rcx

; 325  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	rbx, -1
$LL15@append:
	inc	rbx
	cmp	BYTE PTR [rdx+rbx], 0
	jne	SHORT $LL15@append

; 2768 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	r8, QWORD PTR [rsi+24]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, r8
	sub	rax, rcx
	cmp	rbx, rax
	ja	SHORT $LN6@append

; 2769 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [rsp+64], rdi
	lea	rax, QWORD PTR [rcx+rbx]
	mov	QWORD PTR [rsi+16], rax

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	rax, rsi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	r8, 16

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@append

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rsi]
$LN9@append:

; 2771 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	rdi, QWORD PTR [rax+rcx]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 2772 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rdi+rbx], 0

; 2788 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rax, rsi
	mov	rdi, QWORD PTR [rsp+64]

; 2789 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
$LN6@append:

; 2776 :         return _Reallocate_grow_by(

	mov	r9, rdx
	mov	QWORD PTR [rsp+32], rbx
	mov	rdx, rbx
	mov	rcx, rsi
	call	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>

; 2789 :     }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rsi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 2739 :     basic_string& append(const basic_string& _Right) {

$LN20:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2739 :     basic_string& append(const basic_string& _Right) {

	mov	rdi, rcx

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	r9, rdx

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN4@append

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r9, QWORD PTR [rdx]
$LN4@append:

; 2740 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rsi, QWORD PTR [rdx+16]

; 2768 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rdx, QWORD PTR [rdi+24]
	mov	rcx, QWORD PTR [rcx+16]
	mov	rax, rdx
	sub	rax, rcx
	cmp	rsi, rax
	ja	SHORT $LN9@append

; 2769 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [rsp+64], rbx
	lea	rax, QWORD PTR [rcx+rsi]
	mov	QWORD PTR [rdi+16], rax

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@append

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN12@append:

; 2771 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	rbx, QWORD PTR [rax+rcx]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	r8, rsi
	mov	rcx, rbx
	mov	rdx, r9
	call	memmove

; 2772 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rbx+rsi], 0

; 2740 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+64]

; 2741 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN9@append:

; 2776 :         return _Reallocate_grow_by(

	mov	rdx, rsi
	mov	QWORD PTR [rsp+32], rsi
	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>

; 2741 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 2692 :     basic_string& operator=(const basic_string& _Right) {

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2693 :         if (this != _STD addressof(_Right)) {

	cmp	rcx, rdx
	je	SHORT $LN11@operator

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdx

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN7@operator

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdx]
$LN7@operator:

; 2658 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]
	mov	rdx, rax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN11@operator:

; 2694 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});
; 2695 :         }
; 2696 : 
; 2697 :         return *this;
; 2698 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2628 :     ~basic_string() noexcept {

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rcx+24]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN12@basic_stri

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

	mov	rcx, QWORD PTR [rcx]

; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN23@basic_stri

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN20@basic_stri

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN23@basic_stri:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN12@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4217 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4218 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4219 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4220 :         // write can alias this
; 4221 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0

; 2636 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN20@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN28@basic_stri:
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 2512 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], al

; 2418 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2419 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2420 :     }

	mov	rax, rcx

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 2418 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2419 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2420 :     }

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2334 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t()) {

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 325  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	r8, -1

; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0
$LL13@basic_stri:

; 325  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL13@basic_stri

; 2892 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2335 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2336 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2337 :         _Tidy_init();
; 2338 :         assign(_Ptr);
; 2339 :         _Proxy._Release();
; 2340 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 2287 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2288 :         _Tidy_init();
; 2289 :     }

	mov	rax, rcx

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0

; 2287 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2288 :         _Tidy_init();
; 2289 :     }

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2271 :     basic_string(const basic_string& _Right)

$LN50:
	push	rbx
	push	rbp
	push	rdi
	sub	rsp, 32					; 00000020H

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	xor	eax, eax

; 2271 :     basic_string(const basic_string& _Right)

	mov	rdi, rdx

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	QWORD PTR [rcx+16], rax

; 2271 :     basic_string(const basic_string& _Right)

	mov	rbx, rcx

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	QWORD PTR [rcx+24], rax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2562 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	rbp, QWORD PTR [rdx+16]

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN11@basic_stri

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdx]
$LN11@basic_stri:
	mov	QWORD PTR [rsp+80], rsi

; 2565 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	rbp, 16
	jae	SHORT $LN8@basic_stri

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	xmm0, XMMWORD PTR [rdi]

; 2568 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	esi, 15

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	XMMWORD PTR [rcx], xmm0

; 2569 :             return;

	jmp	SHORT $LN7@basic_stri
$LN8@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2573 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	rsi, rbp
	or	rsi, 15
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

	cmp	rsi, rcx
	cmova	rsi, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2574 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	rcx, QWORD PTR [rsi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN22@basic_stri

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN48@basic_stri

; 51   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN31@basic_stri

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN23@basic_stri
$LN31@basic_stri:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN22@basic_stri:

; 179  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN23@basic_stri

; 51   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
$LN23@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2576 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	lea	r8, QWORD PTR [rbp+1]
	mov	QWORD PTR [rbx], rax

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, rdi
	mov	rcx, rax
	call	memcpy
$LN7@basic_stri:

; 2277 :     }

	mov	QWORD PTR [rbx+16], rbp
	mov	rax, rbx
	mov	QWORD PTR [rbx+24], rsi
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN48@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN46@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN36:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, edx
	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rcx+24]
	cmp	rdx, 16

; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN16@scalar

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

	mov	rcx, QWORD PTR [rcx]

; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN27@scalar

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN24@scalar

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN27@scalar:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN16@scalar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4217 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4218 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4219 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4220 :         // write can alias this
; 4221 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0
	test	dil, 1
	je	SHORT $LN2@scalar
	mov	edx, 32					; 00000020H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN24@scalar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN33@scalar:
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 122  :             return _Ok;

	movzx	eax, BYTE PTR [rcx+8]

; 123  :         }

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 110  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 111  : #if _HAS_EXCEPTIONS
; 112  :             if (!_STD uncaught_exception()) { // TRANSITION, ArchivedOS-12000909

	call	QWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN2@sentry

; 113  :                 this->_Myostr._Osfx();

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN2@sentry:

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rdx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios

; 80   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 80   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN10@sentry

; 81   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN10@sentry:

; 114  :             }
; 115  : #else // _HAS_EXCEPTIONS
; 116  :             this->_Myostr._Osfx();
; 117  : #endif // _HAS_EXCEPTIONS
; 118  :         }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 92   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

$LN24:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	QWORD PTR [rcx], rdx

; 72   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rdx, QWORD PTR [rdx]
	movsxd	rax, DWORD PTR [rdx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios

; 80   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rax+rbx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 73   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN8@sentry

; 74   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rbx]
$LN8@sentry:

; 93   :             if (!_Ostr.good()) {

	movsxd	rcx, DWORD PTR [rdx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xiosbase

; 299  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [rcx+rbx+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 93   :             if (!_Ostr.good()) {

	je	SHORT $LN2@sentry

; 94   :                 _Ok = false;

	xor	al, al

; 95   :                 return;

	jmp	SHORT $LN1@sentry
$LN2@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios

; 70   :         return _Tiestr;

	mov	rcx, QWORD PTR [rcx+rbx+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 99   :             if (!_Tied || _Tied == &_Ostr) {

	test	rcx, rcx
	je	SHORT $LN4@sentry
	cmp	rcx, rbx
	je	SHORT $LN4@sentry

; 101  :                 return;
; 102  :             }
; 103  : 
; 104  : 
; 105  :             _Tied->flush();

	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xiosbase

; 299  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [rcx+rbx+16], 0
	sete	al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

	jmp	SHORT $LN1@sentry
$LN4@sentry:

; 100  :                 _Ok = true;

	mov	al, 1
$LN1@sentry:

; 107  :         }

	mov	BYTE PTR [rdi+8], al
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Ostr$ = 56
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$ = 48
_Ostr$ = 56
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4243 :         return _Mypair._Get_first();

	mov	rax, rcx

; 4244 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 4239 :         return _Mypair._Get_first();

	mov	rax, rcx

; 4240 :     }

	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 4208 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN28:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rcx+24]
	cmp	rdx, 16

; 4209 :         _Mypair._Myval2._Orphan_all();
; 4210 :         if (_Mypair._Myval2._Large_string_engaged()) {

	jb	SHORT $LN10@Tidy_deall

; 4211 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

	mov	rcx, QWORD PTR [rcx]

; 4212 :             auto& _Al          = _Getal();
; 4213 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4214 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN21@Tidy_deall

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN18@Tidy_deall

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN21@Tidy_deall:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN10@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4217 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4218 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4219 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4220 :         // write can alias this
; 4221 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0

; 4222 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN18@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN25@Tidy_deall:
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0

; 4206 :     }

	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 3598 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 3599 :         const size_type _Storage_max = // can always store small string
; 3600 :             _Max_value(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3601 :         return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 3602 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3603 :         );
; 3604 :     }

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\utility
;	COMDAT ??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z PROC		; std::_Max_value<unsigned __int64>, COMDAT

; 37   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 38   : }

	ret	0
??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z ENDP		; std::_Max_value<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 3594 :         return _Mypair._Myval2._Mysize;

	mov	rax, QWORD PTR [rcx+16]

; 3595 :     }

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 325  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	r8, -1
	npad	9
$LL5@assign:
	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL5@assign

; 2892 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	jmp	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2872 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN77:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	r15, rdx
	mov	rbx, rcx

; 2873 :         // assign [_Ptr, _Ptr + _Count)
; 2874 :         if (_Count <= _Mypair._Myval2._Myres) {

	mov	r14, QWORD PTR [rcx+24]
	cmp	r8, r14
	ja	SHORT $LN2@assign

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	rdi, rcx

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	r14, 16

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@assign

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rcx]
$LN5@assign:

; 2875 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2876 :             _Mypair._Myval2._Mysize = _Count;

	mov	QWORD PTR [rcx+16], rsi

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	rcx, rdi
	call	memmove

; 2877 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 2878 :             _Traits::assign(_Old_ptr[_Count], _Elem());

	mov	BYTE PTR [rsi+rdi], 0

; 2879 :             return *this;

	jmp	$LN72@assign
$LN2@assign:

; 4129 :         if (_New_size > max_size()) {

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rdi
	ja	$LN74@assign

; 4109 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rcx, rsi
	or	rcx, 15
	cmp	rcx, rdi

; 4110 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN18@assign

; 4111 :             return _Max;
; 4112 :         }
; 4113 : 
; 4114 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rdx, r14
	shr	rdx, 1
	mov	rax, rdi
	sub	rax, rdx
	cmp	r14, rax
	ja	SHORT $LN18@assign

; 4115 :             return _Max;
; 4116 :         }
; 4117 : 
; 4118 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rdx+r14]
	mov	rdi, rcx
	cmp	rcx, rax
	cmovb	rdi, rax
$LN18@assign:

; 4136 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rcx, rdi
	add	rcx, 1
	mov	rax, -1
	cmovb	rcx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN27@assign

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN75@assign

; 51   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN36@assign

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbp, QWORD PTR [rax+39]
	and	rbp, -32				; ffffffffffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbp-8], rax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN26@assign
$LN36@assign:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN27@assign:

; 179  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN28@assign

; 51   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rbp, rax

; 180  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN26@assign
$LN28@assign:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	ebp, ebp
$LN26@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4138 :         _Mypair._Myval2._Mysize = _New_size;

	mov	QWORD PTR [rbx+16], rsi

; 4139 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rdi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	r8, rsi
	mov	rdx, r15
	mov	rcx, rbp
	call	memcpy

; 2886 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [rsi+rbp], 0

; 4141 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	r14, 16
	jb	SHORT $LN13@assign

; 4142 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, QWORD PTR [r14+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN67@assign

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN64@assign

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN67@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN13@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2882 :         return _Reallocate_for(

	mov	QWORD PTR [rbx], rbp
$LN72@assign:

; 2887 :             },
; 2888 :             _Ptr);
; 2889 :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN64@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN75@assign:

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN74@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4130 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
	int	3
$LN71@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Count$ = 64
_Ptr$ = 72
??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z PROC ; <lambda_66f57f934f28d61049862f64df852ff0>::operator(), COMDAT

; 2884 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

$LN7:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rcx, rbx
	mov	rdx, r9
	call	memcpy

; 2885 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2886 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [rbx+rdi], 0

; 2887 :             },

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z ENDP ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
_Count$ = 80
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 2765 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN13:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	mov	rsi, r8

; 2766 :         // append [_Ptr, _Ptr + _Count)
; 2767 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rcx, QWORD PTR [rcx+16]

; 2768 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	r8, QWORD PTR [rdi+24]
	mov	rax, r8
	sub	rax, rcx
	cmp	rsi, rax
	ja	SHORT $LN2@append

; 2769 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [rsp+64], rbx
	lea	rax, QWORD PTR [rcx+rsi]
	mov	QWORD PTR [rdi+16], rax

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	r8, 16

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@append

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN5@append:

; 2770 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2771 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	lea	rbx, QWORD PTR [rax+rcx]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	r8, rsi
	mov	rcx, rbx
	call	memmove

; 2772 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rbx+rsi], 0

; 2773 :             return *this;

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+64]

; 2777 :             _Count,
; 2778 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2779 :                 const size_type _Count) {
; 2780 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2781 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2782 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2783 :             },
; 2784 :             _Ptr, _Count);
; 2785 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN2@append:

; 2774 :         }
; 2775 : 
; 2776 :         return _Reallocate_grow_by(

	mov	r9, rdx
	mov	QWORD PTR [rsp+32], rsi
	mov	rdx, rsi
	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>

; 2777 :             _Count,
; 2778 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2779 :                 const size_type _Count) {
; 2780 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2781 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2782 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2783 :             },
; 2784 :             _Ptr, _Count);
; 2785 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Ptr$ = 80
_Count$ = 88
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z PROC ; <lambda_65e615be2a453ca0576c979606f46740>::operator(), COMDAT

; 2779 :                 const size_type _Count) {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, r8
	mov	rbx, rdx

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, rax
	mov	rcx, rbx
	mov	r8, r9

; 2779 :                 const size_type _Count) {

	mov	rdi, r9

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	call	memcpy
	mov	rdx, QWORD PTR _Ptr$[rsp]

; 2780 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2781 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

	add	rdi, rbx

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rbx, QWORD PTR _Count$[rsp]
	mov	rcx, rdi
	mov	r8, rbx
	call	memcpy

; 2782 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rdi+rbx], 0

; 2783 :             },

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBAXQEADQEBD_K12@Z ENDP ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$dead$ = 24
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign, COMDAT

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	rax, rdx

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN4@Copy_assig

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdx]
$LN4@Copy_assig:

; 2657 :         _Pocca(_Getal(), _Right._Getal());
; 2658 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r8, QWORD PTR [rdx+16]
	mov	rdx, rax
	jmp	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT

; 2556 :     void _Construct_lv_contents(const basic_string& _Right) {

$LN44:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2556 :     void _Construct_lv_contents(const basic_string& _Right) {

	mov	rbx, rdx

; 2557 :         // assign by copying data stored in _Right
; 2558 :         // pre: this != &_Right
; 2559 :         // pre: *this owns no memory, iterators orphaned (note:
; 2560 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2561 :         auto& _Right_data             = _Right._Mypair._Myval2;
; 2562 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	rsi, QWORD PTR [rdx+16]
	mov	rdi, rcx

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN5@Construct_

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [rdx]
$LN5@Construct_:

; 2563 :         const _Elem* const _Right_ptr = _Right_data._Myptr();
; 2564 :         auto& _My_data                = _Mypair._Myval2;
; 2565 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	rsi, 16
	jae	SHORT $LN2@Construct_

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	movups	xmm0, XMMWORD PTR [rbx]
	movups	XMMWORD PTR [rcx], xmm0

; 2566 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);
; 2567 :             _My_data._Mysize = _Right_size;

	mov	QWORD PTR [rcx+16], rsi

; 2568 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 2579 :     }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Construct_:
	mov	QWORD PTR [rsp+48], rbp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2573 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	rbp, rsi
	or	rbp, 15
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\utility

; 30   :     return _Right < _Left ? _Right : _Left;

	cmp	rbp, rax
	cmova	rbp, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2574 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	rcx, QWORD PTR [rbp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN16@Construct_

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN42@Construct_

; 51   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN25@Construct_

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN15@Construct_
$LN25@Construct_:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN16@Construct_:

; 179  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN17@Construct_

; 51   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 180  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN15@Construct_
$LN17@Construct_:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	eax, eax
$LN15@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2576 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	lea	r8, QWORD PTR [rsi+1]
	mov	QWORD PTR [rdi], rax

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, rbx
	mov	rcx, rax
	call	memcpy

; 2579 :     }

	mov	rbx, QWORD PTR [rsp+56]
	mov	QWORD PTR [rdi+16], rsi
	mov	rsi, QWORD PTR [rsp+64]
	mov	QWORD PTR [rdi+24], rbp
	mov	rbp, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN42@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN40@Construct_:
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$dead$ = 24
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT

; 2512 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rdx+16], 0

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdx], 0

; 2516 :         // assign by stealing _Right's buffer, memcpy optimization
; 2517 :         // pre: this != &_Right
; 2518 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2519 :         // pre: *this owns no memory, iterators orphaned (note:
; 2520 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2521 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2522 :         if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 2523 :             // take ownership of _Right's iterators along with its buffer
; 2524 :             _Swap_proxy_and_iterators(_Right);
; 2525 :         } else {
; 2526 :             _Right._Mypair._Myval2._Orphan_all();
; 2527 :         }
; 2528 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2529 : 
; 2530 :         _Memcpy_val_from(_Right);
; 2531 :         _Right._Tidy_init();
; 2532 :     }

	ret	0
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 2188 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16
	setae	al

; 2162 :     }

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2152 :         const value_type* _Result = _Bx._Buf;
; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2154 :             _Result = _Unfancy(_Bx._Ptr);
; 2155 :         }
; 2156 : 
; 2157 :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 2158 :     }

	ret	0
$LN6@Myptr:

; 2154 :             _Result = _Unfancy(_Bx._Ptr);
; 2155 :         }
; 2156 : 
; 2157 :         return _Result;

	mov	rax, rcx

; 2158 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2143 :         value_type* _Result = _Bx._Buf;
; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN6@Myptr

; 2145 :             _Result = _Unfancy(_Bx._Ptr);
; 2146 :         }
; 2147 : 
; 2148 :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 2149 :     }

	ret	0
$LN6@Myptr:

; 2145 :             _Result = _Unfancy(_Bx._Ptr);
; 2146 :         }
; 2147 : 
; 2148 :         return _Result;

	mov	rax, rcx

; 2149 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 684  :         return _Al;

	mov	rax, rcx

; 685  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 783  :     _NODISCARD _DECLSPEC_ALLOCATOR _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN27:
	sub	rsp, 40					; 00000028H

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN4@allocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	rcx, rdx
	jbe	SHORT $LN26@allocate

; 51   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN13@allocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN13@allocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN4@allocate:

; 179  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN5@allocate

; 51   :         return ::operator new(_Bytes);

	mov	rcx, rdx

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

	add	rsp, 40					; 00000028H

; 51   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN5@allocate:

; 183  :     return nullptr;

	xor	eax, eax

; 784  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 785  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN26@allocate:

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN24@allocate:
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 778  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN22:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	r8, 4096				; 00001000H
	jb	SHORT $LN16@deallocate

; 108  :     _Bytes += _Non_user_size;

	add	r8, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdx-8]

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN13@deallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN16@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	rdx, r8
	mov	rcx, rax
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1

; 779  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 780  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
; 781  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN13@deallocate:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN19@deallocate:
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 405  :         return static_cast<int_type>(EOF);

	mov	eax, -1

; 406  :     }

	ret	0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 397  :         return _Left == _Right;

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rcx], eax
	sete	al

; 398  :     }

	ret	0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NAEBH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC ; std::_Narrow_char_traits<char,int>::copy, COMDAT

; 330  :         const size_t _Count) noexcept /* strengthened */ {

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 331  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	call	memcpy
	mov	rax, rbx

; 333  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?copy@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP ; std::_Narrow_char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 310  :         // find length of null-terminated string
; 311  : #if _HAS_CXX17
; 312  : #ifdef __cpp_char8_t
; 313  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 314  : #if _HAS_U8_INTRINSICS
; 315  :             return __builtin_u8strlen(_First);
; 316  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 317  :             return _Char_traits<_Elem, _Int_type>::length(_First);
; 318  : #endif // _HAS_U8_INTRINSICS
; 319  :         } else
; 320  : #endif // __cpp_char8_t
; 321  :         {
; 322  :             return __builtin_strlen(_First);
; 323  :         }
; 324  : #else // _HAS_CXX17
; 325  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	rax, -1
$LL3@length:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL3@length

; 326  : #endif // _HAS_CXX17
; 327  :     }

	ret	0
?length@?$_Narrow_char_traits@DH@std@@SA_KQEBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN8:
	sub	rsp, 40					; 00000028H

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rdx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios

; 80   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 80   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN2@Sentry_bas

; 81   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN2@Sentry_bas:

; 82   :             }
; 83   :         }

	add	rsp, 40					; 00000028H
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rcx], rdx
	mov	rbx, rcx

; 72   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios

; 80   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [r8+rdx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 73   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN6@Sentry_bas

; 74   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
$LN6@Sentry_bas:

; 75   :             }
; 76   :         }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1340 :         return *this;

	mov	rax, rcx

; 1341 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1336 :         return *this;

	mov	rax, rcx

; 1337 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from, COMDAT

; 2507 :         _STL_INTERNAL_CHECK(_Can_memcpy_val); // TRANSITION, if constexpr
; 2508 :         const auto _My_data_mem =
; 2509 :             reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 2510 :         const auto _Right_data_mem =
; 2511 :             reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 2512 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1

; 2513 :     }

	ret	0
?_Memcpy_val_from@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Memcpy_val_from
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 680  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 681  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 377  :         _Left = _Right;

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al

; 378  :     }

	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?move@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 8
_First2$ = 16
_Count$ = 24
?move@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC ; std::_Narrow_char_traits<char,int>::move, COMDAT

; 366  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	jmp	memmove
?move@?$_Narrow_char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP ; std::_Narrow_char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Off$dead$ = 16
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT

; 2165 :         if (_Mysize < _Off) {
; 2166 :             _Xran();
; 2167 :         }
; 2168 :     }

	ret	0
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2176 :     [[noreturn]] static void _Xran() {

$LN4:
	sub	rsp, 40					; 00000028H

; 2177 :         _Xout_of_range("invalid string position");

	lea	rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position@
	call	QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
	int	3
$LN3@Xran:
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\utility
;	COMDAT ??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z PROC		; std::_Min_value<unsigned __int64>, COMDAT

; 30   :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR [rcx]
	cmp	QWORD PTR [rdx], rax
	cmovb	rcx, rdx
	mov	rax, rcx

; 31   : }

	ret	0
??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z ENDP		; std::_Min_value<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xutility
;	COMDAT ??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z PROC	; std::_Adl_verify_range<char *,char *>, COMDAT

; 1037 :     // check that [_First, _Last) forms an iterator range
; 1038 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1039 :         _Verify_range(_First, _Last);
; 1040 :     } else {
; 1041 :         (void) _First; // TRANSITION, VSO-486357
; 1042 :         (void) _Last; // TRANSITION, VSO-486357
; 1043 :     }
; 1044 : }

	ret	0
??$_Adl_verify_range@PEADPEAD@std@@YAXAEBQEAD0@Z ENDP	; std::_Adl_verify_range<char *,char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\string
;	COMDAT ??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z
_TEXT	SEGMENT
__$ReturnUdt$GSCopy$ = 32
_Buff$ = 40
__$ArrayPad$ = 64
__$ReturnUdt$ = 96
_Val$ = 104
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z PROC ; std::_Integral_to_string<char,int>, COMDAT

; 486  : basic_string<_Elem> _Integral_to_string(const _Ty _Val) { // convert _Val to string

$LN37:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	r8d, edx

; 487  :     static_assert(is_integral_v<_Ty>, "_Ty must be integral");
; 488  :     using _UTy = make_unsigned_t<_Ty>;
; 489  :     _Elem _Buff[21]; // can hold -2^63 and 2^64 - 1, plus NUL
; 490  :     _Elem* const _Buff_end = _STD end(_Buff);
; 491  :     _Elem* _RNext          = _Buff_end;
; 492  :     const auto _UVal       = static_cast<_UTy>(_Val);
; 493  :     if (_Val < 0) {

	lea	r9, QWORD PTR _Buff$[rsp+21]
	mov	rbx, rcx
	test	edx, edx
	jns	SHORT $LL15@Integral_t

; 458  :     auto _UVal_trunc = _UVal;

	neg	r8d
	npad	4
$LL10@Integral_t:

; 459  : #else // ^^^ _WIN64 ^^^ // vvv !_WIN64 vvv
; 460  : 
; 461  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 462  :     if
; 463  :         _CONSTEXPR_IF(_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 464  :             while (_UVal > 0xFFFFFFFFU) {
; 465  :                 auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 466  :                 _UVal /= 1000000000;
; 467  : 
; 468  :                 for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 469  :                     *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 470  :                     _UVal_chunk /= 10;
; 471  :                 }
; 472  :             }
; 473  :         }
; 474  : 
; 475  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 476  : #endif // _WIN64
; 477  : 
; 478  :     do {
; 479  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 480  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 481  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL10@Integral_t

; 494  :         _RNext    = _UIntegral_to_buff(_RNext, 0 - _UVal);
; 495  :         *--_RNext = '-';

	dec	r9
	mov	BYTE PTR [r9], 45			; 0000002dH

; 496  :     } else {

	jmp	SHORT $LN3@Integral_t
	npad	13
$LL15@Integral_t:

; 479  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	r9
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	ecx, DWORD PTR [rax+rdx]
	add	cl, cl
	sub	r8b, cl
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [r9], r8b

; 480  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 481  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL15@Integral_t
$LN3@Integral_t:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2405 :         if (_First != _Last) {

	lea	rax, QWORD PTR _Buff$[rsp+21]

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rbx], 0

; 2405 :         if (_First != _Last) {

	cmp	r9, rax
	je	SHORT $LN34@Integral_t

; 2406 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));

	lea	r8, QWORD PTR _Buff$[rsp+21]
	mov	rdx, r9
	sub	r8, r9
	mov	rcx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN34@Integral_t:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\string

; 501  : }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
??$_Integral_to_string@DH@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@H@Z ENDP ; std::_Integral_to_string<char,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xutility
;	COMDAT ??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z
_TEXT	SEGMENT
_Array$ = 8
??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z PROC		; std::end<char,21>, COMDAT

; 1937 :     return _Array + _Size;

	lea	rax, QWORD PTR [rcx+21]

; 1938 : }

	ret	0
??$end@D$0BF@@std@@YAPEADAEAY0BF@D@Z ENDP		; std::end<char,21>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\types.hpp
;	COMDAT ??0?$Size_@H@cv@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$Size_@H@cv@@QEAA@XZ PROC				; cv::Size_<int>::Size_<int>, COMDAT

; 1682 :     : width(0), height(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	rax, rcx
	ret	0
??0?$Size_@H@cv@@QEAA@XZ ENDP				; cv::Size_<int>::Size_<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\types.hpp
;	COMDAT ??0?$Point_@H@cv@@QEAA@HH@Z
_TEXT	SEGMENT
this$ = 8
_x$dead$ = 16
_y$ = 24
??0?$Point_@H@cv@@QEAA@HH@Z PROC			; cv::Point_<int>::Point_<int>, COMDAT

; 1165 :     : x(_x), y(_y) {}

	mov	DWORD PTR [rcx], 20
	mov	rax, rcx
	mov	DWORD PTR [rcx+4], r8d
	ret	0
??0?$Point_@H@cv@@QEAA@HH@Z ENDP			; cv::Point_<int>::Point_<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\types.hpp
;	COMDAT ??0?$Scalar_@N@cv@@QEAA@NNNN@Z
_TEXT	SEGMENT
this$ = 8
v0$ = 16
v1$ = 24
v2$ = 32
v3$ = 40
??0?$Scalar_@N@cv@@QEAA@NNNN@Z PROC			; cv::Scalar_<double>::Scalar_<double>, COMDAT

; 2160 :     this->val[0] = v0;
; 2161 :     this->val[1] = v1;
; 2162 :     this->val[2] = v2;
; 2163 :     this->val[3] = v3;

	movsd	xmm0, QWORD PTR v3$[rsp]

; 2164 : }

	mov	rax, rcx
	movsd	QWORD PTR [rcx+24], xmm0
	movsd	QWORD PTR [rcx], xmm1
	movsd	QWORD PTR [rcx+8], xmm2
	movsd	QWORD PTR [rcx+16], xmm3
	ret	0
??0?$Scalar_@N@cv@@QEAA@NNNN@Z ENDP			; cv::Scalar_<double>::Scalar_<double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 731  :     const char* _Val) { // insert NTBS into char stream

$LN99:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r15, rdx
	mov	rsi, rcx

; 732  :     using _Elem = char;
; 733  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 734  : 
; 735  :     ios_base::iostate _State = ios_base::goodbit;

	xor	ebx, ebx
	mov	DWORD PTR _State$[rsp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 325  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

	mov	r14, -1
	npad	7
$LL92@operator:
	inc	r14
	cmp	BYTE PTR [rdx+r14], bl
	jne	SHORT $LL92@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 737  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	rcx, QWORD PTR [rcx]
	movsxd	rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xiosbase

; 367  :         return _Wide;

	mov	rdi, QWORD PTR [rax+rsi+40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 737  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	test	rdi, rdi
	jle	SHORT $LN17@operator
	cmp	rdi, r14
	jle	SHORT $LN17@operator
	sub	rdi, r14
	jmp	SHORT $LN18@operator
$LN17@operator:
	xor	edi, edi
$LN18@operator:

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	r12, rsi
	mov	QWORD PTR _Ok$[rsp], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios

; 80   :         return _Mystrbuf;

	mov	r8, QWORD PTR [rax+rsi+72]
	mov	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 73   :             if (_Rdbuf) {

	test	r8, r8
	je	SHORT $LN39@operator

; 74   :                 _Rdbuf->_Lock();

	mov	rax, QWORD PTR [r8]
	mov	rcx, r8
	call	QWORD PTR [rax+8]
	mov	rcx, QWORD PTR [rsi]
	mov	rdx, rcx
$LN39@operator:

; 93   :             if (!_Ostr.good()) {

	movsxd	rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xiosbase

; 299  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [rax+rsi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 93   :             if (!_Ostr.good()) {

	je	SHORT $LN33@operator

; 94   :                 _Ok = false;

	xor	al, al

; 95   :                 return;

	jmp	SHORT $LN95@operator
$LN33@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios

; 70   :         return _Tiestr;

	mov	rax, QWORD PTR [rax+rsi+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 99   :             if (!_Tied || _Tied == &_Ostr) {

	test	rax, rax
	je	SHORT $LN35@operator
	cmp	rax, rsi
	je	SHORT $LN35@operator

; 101  :                 return;
; 102  :             }
; 103  : 
; 104  : 
; 105  :             _Tied->flush();

	mov	rcx, rax
	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rcx, QWORD PTR [rsi]
	movsxd	rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xiosbase

; 299  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [rax+rsi+16], 0
	sete	al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 106  :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	rdx, rcx
	jmp	SHORT $LN95@operator
$LN35@operator:

; 100  :                 _Ok = true;

	mov	al, 1
$LN95@operator:

; 107  :         }

	mov	BYTE PTR _Ok$[rsp+8], al

; 738  :     const typename _Myos::sentry _Ok(_Ostr);
; 739  : 
; 740  :     if (!_Ok) {

	test	al, al
	jne	SHORT $LN8@operator

; 741  :         _State |= ios_base::badbit;

	mov	ebx, 4

; 742  :     } else { // state okay, insert

	jmp	$LN22@operator
$LN8@operator:

; 744  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	movsxd	rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xiosbase

; 330  :         return _Fmtfl;

	mov	ecx, DWORD PTR [rax+rsi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 744  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	and	ecx, 448				; 000001c0H
	cmp	ecx, 64					; 00000040H
	je	SHORT $LN87@operator
	npad	4
$LL4@operator:

; 745  :             for (; 0 < _Pad; --_Pad) { // pad on left

	test	rdi, rdi
	jle	SHORT $LN89@operator

; 746  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	je	SHORT $LN96@operator

; 745  :             for (; 0 < _Pad; --_Pad) { // pad on left

	dec	rdi
	jmp	SHORT $LL4@operator
$LN89@operator:

; 747  :                     _State |= ios_base::badbit; // insertion failed, quit
; 748  :                     break;
; 749  :                 }
; 750  :             }
; 751  :         }
; 752  : 
; 753  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	mov	rdx, QWORD PTR [rsi]
$LN87@operator:
	movsxd	rax, DWORD PTR [rdx+4]
	mov	r8, r14
	mov	rdx, r15
	mov	rcx, QWORD PTR [rax+rsi+72]
	call	QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
	cmp	rax, r14
	jne	SHORT $LN96@operator
$LL93@operator:

; 754  :             _State |= ios_base::badbit;
; 755  :         }
; 756  : 
; 757  :         if (_State == ios_base::goodbit) {
; 758  :             for (; 0 < _Pad; --_Pad) { // pad on right

	test	rdi, rdi
	jle	SHORT $LN6@operator

; 759  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	je	SHORT $LN96@operator

; 754  :             _State |= ios_base::badbit;
; 755  :         }
; 756  : 
; 757  :         if (_State == ios_base::goodbit) {
; 758  :             for (; 0 < _Pad; --_Pad) { // pad on right

	dec	rdi
	jmp	SHORT $LL93@operator
$LN96@operator:

; 760  :                     _State |= ios_base::badbit; // insertion failed, quit
; 761  :                     break;
; 762  :                 }
; 763  :             }
; 764  :         }
; 765  : 
; 766  :         _Ostr.width(0);

	mov	ebx, 4
	mov	DWORD PTR _State$[rsp], ebx
$LN6@operator:
	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xiosbase

; 372  :         _Wide                      = _Newwidth;

	mov	QWORD PTR [rcx+rsi+40], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream
	jmp	SHORT $LN22@operator
$LN23@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios
	mov	rsi, QWORD PTR _Ostr$[rsp]
	mov	ebx, DWORD PTR _State$[rsp]
	mov	r12, QWORD PTR _Ok$[rsp]
$LN22@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 770  :     _Ostr.setstate(_State);

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	xor	r8d, r8d
	mov	edx, ebx
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1

; 112  :             if (!_STD uncaught_exception()) { // TRANSITION, ArchivedOS-12000909

	call	QWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN72@operator

; 113  :                 this->_Myostr._Osfx();

	mov	rcx, r12
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN72@operator:

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

	mov	rax, QWORD PTR [r12]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ios

; 80   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rcx+r12+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\ostream

; 80   :             if (_Rdbuf) {

	test	rcx, rcx
	je	SHORT $LN76@operator

; 81   :                 _Rdbuf->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN76@operator:

; 771  :     return _Ostr;

	mov	rax, rsi

; 772  : }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4

; 767  :         _CATCH_IO_(ios_base, _Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
	mov	rdx, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rdx
	mov	r8b, 1
	mov	edx, 4
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	mov	rax, 0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ok$ = 32
_Ostr$ = 96
_Val$ = 104
_State$ = 112
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4

; 767  :         _CATCH_IO_(ios_base, _Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
	mov	rdx, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rdx
	mov	r8b, 1
	mov	edx, 4
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	mov	rax, 0
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_Left$ = 72
_Right$dead$ = 80
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4364 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

$LN34:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	r8, rdx
	mov	rbx, rcx

; 2767 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	rdx, QWORD PTR [rdx+16]

; 2768 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rcx, r8
	mov	r9, QWORD PTR [r8+24]
	mov	rax, r9
	sub	rax, rdx
	cmp	rax, 1
	jb	SHORT $LN10@operator

; 2769 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [r8+16], rax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	r9, 16

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN13@operator

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rcx, QWORD PTR [r8]
$LN13@operator:

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	movzx	eax, BYTE PTR ??_C@_01KMDKNFGN@?1@
	mov	BYTE PTR [rcx+rdx], al

; 2772 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rcx+rdx+1], 0

; 2773 :             return *this;

	jmp	SHORT $LN9@operator
$LN10@operator:

; 2774 :         }
; 2775 : 
; 2776 :         return _Reallocate_grow_by(

	lea	r9, OFFSET FLAT:??_C@_01KMDKNFGN@?1@
	mov	QWORD PTR [rsp+32], 1
	mov	edx, 1
	call	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
	mov	r8, rax
$LN9@operator:

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	xor	eax, eax
	mov	QWORD PTR [rbx+16], rax
	mov	QWORD PTR [rbx+24], rax

; 2512 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rbx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rbx+16], xmm1

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [r8+16], rax

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [r8], al

; 4365 :     return _STD move(_Left.append(_Right));

	mov	rax, rbx

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [r8+24], 15

; 4366 : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 96
_Left$ = 104
_Right$ = 112
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4342 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

$LN83:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	sub	rsp, 48					; 00000030H

; 4343 :     if (_Right.size() <= _Left.capacity() - _Left.size() || _Right.capacity() - _Right.size() < _Left.size()) {

	mov	rsi, QWORD PTR [r8+16]
	mov	rdi, rdx
	mov	rdx, QWORD PTR [rdx+24]
	mov	r13, rcx
	mov	rcx, rdx
	mov	r14, r8
	mov	rbx, QWORD PTR [rdi+16]
	sub	rcx, rbx
	cmp	rsi, rcx
	jbe	$LN78@operator
	mov	r8, QWORD PTR [r8+24]
	mov	rax, r8
	sub	rax, rsi
	cmp	rax, rbx
	jb	$LN78@operator

; 2161 :         return _BUF_SIZE <= _Myres;

	mov	QWORD PTR [rsp+96], r12
	mov	QWORD PTR [rsp+104], r15
	cmp	rdx, 16

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN41@operator

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rdi, QWORD PTR [rdi]
$LN41@operator:

; 2991 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rsi+rbx]

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	r15, r14

; 2991 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [r14+16], rax

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	r8, 16

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN54@operator

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r15, QWORD PTR [r14]
$LN54@operator:

; 2998 :                 || _Ptr > _Old_ptr + _Old_size) { // inserted content is before the shifted region, or does not alias

	lea	rax, QWORD PTR [rbx+rdi]
	xor	ebp, ebp
	cmp	rax, r15
	jbe	SHORT $LN49@operator
	lea	rax, QWORD PTR [r15+rsi]
	cmp	rdi, rax
	ja	SHORT $LN49@operator

; 3000 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts

	cmp	r15, rdi
	ja	SHORT $LN50@operator

; 3001 :                 _Ptr_shifted_after = 0;

	mov	r12d, ebp

; 3002 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts

	jmp	SHORT $LN51@operator
$LN50@operator:

; 3003 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

	mov	r12, r15
	sub	r12, rdi
	jmp	SHORT $LN51@operator
$LN49@operator:

; 2999 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts

	mov	r12, rbx
$LN51@operator:

; 3004 :             }
; 3005 : 
; 3006 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	lea	r8, QWORD PTR [rsi+1]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	rdx, r15

; 3006 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	lea	rcx, QWORD PTR [r15+rbx]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	call	memmove

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	r8, r12
	mov	rdx, rdi
	mov	rcx, r15
	call	memcpy

; 3008 :             _Traits::copy(

	mov	r8, rbx
	lea	rdx, QWORD PTR [r12+rbx]
	sub	r8, r12
	lea	rcx, QWORD PTR [r15+r12]
	add	rdx, rdi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	call	memcpy

; 4344 :         return _STD move(_Left.append(_Right));
; 4345 :     } else {
; 4346 :         return _STD move(_Right.insert(0, _Left));

	mov	r15, QWORD PTR [rsp+104]
	mov	r12, QWORD PTR [rsp+96]

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	mov	QWORD PTR [r13+16], rbp
	mov	QWORD PTR [r13+24], rbp

; 2512 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [r14]
	movups	XMMWORD PTR [r13], xmm0
	movups	xmm1, XMMWORD PTR [r14+16]
	movups	XMMWORD PTR [r13+16], xmm1

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [r14+16], rbp

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [r14+24], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [r14], bpl

; 4344 :         return _STD move(_Left.append(_Right));
; 4345 :     } else {
; 4346 :         return _STD move(_Right.insert(0, _Left));

	jmp	SHORT $LN80@operator
$LN78@operator:

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [r14+24], 16

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN11@operator

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	r14, QWORD PTR [r14]
$LN11@operator:

; 2768 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	cmp	rsi, rcx
	ja	SHORT $LN16@operator

; 2769 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	lea	rax, QWORD PTR [rbx+rsi]
	mov	QWORD PTR [rdi+16], rax

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN19@operator

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR [rdi]
$LN19@operator:

; 2771 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

	add	rbx, rax

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	r8, rsi
	mov	rcx, rbx
	mov	rdx, r14
	call	memmove

; 2772 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [rbx+rsi], 0

; 2773 :             return *this;

	jmp	SHORT $LN15@operator
$LN16@operator:

; 2774 :         }
; 2775 : 
; 2776 :         return _Reallocate_grow_by(

	mov	r9, r14
	mov	QWORD PTR [rsp+32], rsi
	mov	rdx, rsi
	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
	mov	rdi, rax
$LN15@operator:

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	xor	ebp, ebp
	mov	QWORD PTR [r13+16], rbp
	mov	QWORD PTR [r13+24], rbp

; 2512 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [r13], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [r13+16], xmm1

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rdi+16], rbp

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rdi], bpl
$LN80@operator:

; 4347 :     }
; 4348 : }

	mov	rbx, QWORD PTR [rsp+112]
	mov	rax, r13
	add	rsp, 48					; 00000030H
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 289  :     return _Ptr;

	mov	rax, rcx

; 290  : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xutility
;	COMDAT ??$_Get_unwrapped@AEAPEAD@std@@YAPEADAEAPEAD@Z
_TEXT	SEGMENT
_It$ = 8
??$_Get_unwrapped@AEAPEAD@std@@YAPEADAEAPEAD@Z PROC	; std::_Get_unwrapped<char * &>, COMDAT

; 1077 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1078 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1079 :         return _It + 0;

	mov	rax, QWORD PTR [rcx]

; 1080 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1081 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1082 :     } else {
; 1083 :         return static_cast<_Iter&&>(_It);
; 1084 :     }
; 1085 : }

	ret	0
??$_Get_unwrapped@AEAPEAD@std@@YAPEADAEAPEAD@Z ENDP	; std::_Get_unwrapped<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\type_traits
;	COMDAT ??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1465 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1466 : }

	ret	0
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 275  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 276  : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 275  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 276  : }

	ret	0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1465 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1466 : }

	ret	0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 1328 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$dead$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 242  :     _Obj.~_Ty();
; 243  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
_TEXT	SEGMENT
this$ = 80
_New_size$ = 88
_Fn$dead$ = 96
<_Args_0>$ = 104
??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>, COMDAT

; 4126 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

$LN65:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r15, r9
	mov	r14, rdx
	mov	rsi, rcx

; 4127 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4128 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4129 :         if (_New_size > max_size()) {

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	cmp	rdx, rdi
	ja	$LN62@Reallocate

; 4131 :         }
; 4132 : 
; 4133 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

	mov	rbp, QWORD PTR [rcx+24]

; 4109 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rcx, rdx
	or	rcx, 15
	cmp	rcx, rdi

; 4110 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN8@Reallocate

; 4111 :             return _Max;
; 4112 :         }
; 4113 : 
; 4114 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rdx, rbp
	shr	rdx, 1
	mov	rax, rdi
	sub	rax, rdx
	cmp	rbp, rax
	ja	SHORT $LN8@Reallocate

; 4115 :             return _Max;
; 4116 :         }
; 4117 : 
; 4118 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rdx+rbp]
	mov	rdi, rcx
	cmp	rcx, rax
	cmovb	rdi, rax
$LN8@Reallocate:

; 4134 :         const size_type _New_capacity = _Calculate_growth(_New_size);
; 4135 :         auto& _Al                     = _Getal();
; 4136 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rcx, rdi
	add	rcx, 1
	mov	rax, -1
	cmovb	rcx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN17@Reallocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN63@Reallocate

; 51   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN26@Reallocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN26@Reallocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN17@Reallocate:

; 179  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN18@Reallocate

; 51   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 180  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	ebx, ebx
$LN16@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4138 :         _Mypair._Myval2._Mysize = _New_size;

	mov	QWORD PTR [rsi+16], r14

; 4139 :         _Mypair._Myval2._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rdi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	r8, r14
	mov	rdx, r15
	mov	rcx, rbx
	call	memcpy

; 2886 :                 _Traits::assign(_New_ptr[_Count], _Elem());

	mov	BYTE PTR [r14+rbx], 0

; 4140 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 4141 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	rbp, 16
	jb	SHORT $LN3@Reallocate

; 4142 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

	mov	rcx, QWORD PTR [rsi]
	lea	rdx, QWORD PTR [rbp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN57@Reallocate

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN54@Reallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN57@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4148 :         return *this;

	mov	QWORD PTR [rsi], rbx
	mov	rax, rsi

; 4149 :     }

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN54@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN63@Reallocate:

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN62@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4130 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
	int	3
$LN60@Reallocate:
??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
<_Args_0>$ = 120
<_Args_1>$ = 128
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>, COMDAT

; 4152 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN73:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r13, r9
	mov	rsi, rcx

; 4153 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4154 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4155 :         auto& _My_data            = _Mypair._Myval2;
; 4156 :         const size_type _Old_size = _My_data._Mysize;

	mov	r12, QWORD PTR [rcx+16]

; 4157 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, rbx
	sub	rax, r12
	cmp	rax, rdx
	jb	$LN70@Reallocate

; 4159 :         }
; 4160 : 
; 4161 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	r14, QWORD PTR [rdx+r12]

; 4162 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rbp, QWORD PTR [rcx+24]

; 4109 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rcx, r14
	or	rcx, 15
	cmp	rcx, rbx

; 4110 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN8@Reallocate

; 4111 :             return _Max;
; 4112 :         }
; 4113 : 
; 4114 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rdx, rbp
	shr	rdx, 1
	mov	rax, rbx
	sub	rax, rdx
	cmp	rbp, rax
	ja	SHORT $LN8@Reallocate

; 4115 :             return _Max;
; 4116 :         }
; 4117 : 
; 4118 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rdx+rbp]
	mov	rbx, rcx
	cmp	rcx, rax
	cmovb	rbx, rax
$LN8@Reallocate:

; 4163 :         const size_type _New_capacity = _Calculate_growth(_New_size);
; 4164 :         auto& _Al                     = _Getal();
; 4165 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rcx, rbx
	add	rcx, 1
	mov	rax, -1
	cmovb	rcx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN17@Reallocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN71@Reallocate

; 51   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN26@Reallocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN26@Reallocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN17@Reallocate:

; 179  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN18@Reallocate

; 51   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 180  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	edi, edi
$LN16@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4167 :         _My_data._Mysize      = _New_size;

	mov	QWORD PTR [rsi+16], r14

; 4168 :         _My_data._Myres       = _New_capacity;

	mov	QWORD PTR [rsi+24], rbx

; 4169 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	lea	r14, QWORD PTR [rdi+r12]
	mov	r15, QWORD PTR <_Args_1>$[rsp]

; 4170 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	r8, r12
	mov	rcx, rdi
	cmp	rbp, 16
	jb	SHORT $LN3@Reallocate

; 4171 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [rsi]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, rbx
	call	memcpy
	mov	r8, r15
	mov	rdx, r13
	mov	rcx, r14
	call	memcpy

; 2782 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [r14+r15], 0

; 4172 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4173 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	lea	rdx, QWORD PTR [rbp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN59@Reallocate

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rbx-8]

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, 31
	ja	SHORT $LN56@Reallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rcx
$LN59@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4175 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN56@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, rsi
	call	memcpy
	mov	r8, r15
	mov	rdx, r13
	mov	rcx, r14
	call	memcpy

; 2782 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	mov	BYTE PTR [r14+r15], 0
$LN4@Reallocate:

; 4176 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4177 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 4178 :         }
; 4179 : 
; 4180 :         return *this;

	mov	QWORD PTR [rsi], rdi
	mov	rax, rsi

; 4181 :     }

	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN71@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN70@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4158 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
	int	3
$LN68@Reallocate:
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 856  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 857  :         _Left = _Right;
; 858  :     } else {
; 859  :         (void) _Left; // TRANSITION, VSO-486357
; 860  :         (void) _Right; // TRANSITION, VSO-486357
; 861  :     }
; 862  : }

	ret	0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
<_Args_0>$ = 16
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 202  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 203  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))
; 204  :         _Ty(_STD forward<_Types>(_Args)...);
; 205  : }

	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 8
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 29   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;
; 30   : 
; 31   :     if
; 32   :         _CONSTEXPR_IF(_Overflow_is_possible) {
; 33   :             constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 34   :             if (_Count > _Max_possible) {
; 35   :                 _Throw_bad_array_new_length(); // multiply overflow
; 36   :             }
; 37   :         }
; 38   : 
; 39   :     return _Count * _Ty_size;

	mov	rax, rcx

; 40   : }

	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits,0>, COMDAT

; 171  : _DECLSPEC_ALLOCATOR void* _Allocate(const size_t _Bytes) {

$LN24:
	sub	rsp, 40					; 00000028H

; 172  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 173  : #if defined(_M_IX86) || defined(_M_X64)
; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN2@Allocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN23@Allocate

; 51   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN11@Allocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 184  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN11@Allocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN2@Allocate:

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
; 176  :     }
; 177  : #endif // defined(_M_IX86) || defined(_M_X64)
; 178  : 
; 179  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN3@Allocate

; 184  : }

	add	rsp, 40					; 00000028H

; 51   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN3@Allocate:

; 180  :         return _Traits::_Allocate(_Bytes);
; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	eax, eax

; 184  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN23@Allocate:

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN21@Allocate:
??$_Allocate@$0BA@U_Default_allocate_traits@std@@$0A@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16,0>, COMDAT

; 187  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN18:
	sub	rsp, 40					; 00000028H

; 188  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 189  : #if defined(_M_IX86) || defined(_M_X64)
; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN13@Deallocate

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN10@Deallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN13@Deallocate:

; 196  : }

	add	rsp, 40					; 00000028H

; 191  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 192  :     }
; 193  : #endif // defined(_M_IX86) || defined(_M_X64)
; 194  : 
; 195  :     ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN10@Deallocate:

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN15@Deallocate:
??$_Deallocate@$0BA@$0A@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT

; 275  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 276  : }

	ret	0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEBV?$_String_val@U?$_Simple_types@D@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?print@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
out$ = 16
src$ = 24
?print@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z PROC ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::print, COMDAT

; 102  :     virtual void print(std::ostream& out, void* const* src) CV_OVERRIDE { out << *reinterpret_cast<T const*>(*src); }

	mov	rcx, rdx

; 38   :     out << "[empty_any]";

	lea	rdx, OFFSET FLAT:??_C@_0M@LLFGKPEG@?$FLempty_any?$FN@
	jmp	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
?print@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::print
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z PROC ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::get_value, COMDAT

; 101  :     virtual const void* get_value(void* const * src) CV_OVERRIDE { return *src; }

	mov	rax, QWORD PTR [rdx]
	ret	0
?get_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::get_value, COMDAT

; 100  :     virtual void* get_value(void** src) CV_OVERRIDE { return *src; }

	mov	rax, QWORD PTR [rdx]
	ret	0
?get_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?move@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?move@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::move, COMDAT

; 97   :         (*reinterpret_cast<T**>(dest))->~T();
; 98   :         **reinterpret_cast<T**>(dest) = **reinterpret_cast<T* const*>(src);
; 99   :     }

	ret	0
?move@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?clone@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
src$ = 56
dest$ = 64
?clone@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::clone, COMDAT

; 92   :     {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 93   :         *dest = new T(**reinterpret_cast<T* const*>(src));

	mov	ecx, 1
	mov	rbx, r8
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR [rbx], rax

; 94   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?clone@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::clone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?copy_from_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
src$ = 56
dest$ = 64
?copy_from_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::copy_from_value, COMDAT

; 88   :     {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 89   :         *dest = new T(*reinterpret_cast<T const*>(src));

	mov	ecx, 1
	mov	rbx, r8
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR [rbx], rax

; 90   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?copy_from_value@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::copy_from_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?static_delete@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
x$ = 56
?static_delete@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z PROC ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::static_delete, COMDAT

; 83   :     {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 84   :         if (* x) delete (* reinterpret_cast<T**>(x));

	mov	rcx, QWORD PTR [rdx]
	mov	rbx, rdx
	test	rcx, rcx
	je	SHORT $LN6@static_del
	mov	edx, 1
	call	??3@YAXPEAX_K@Z				; operator delete

; 85   :         *x = NULL;

	mov	QWORD PTR [rbx], 0

; 86   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN6@static_del:

; 85   :         *x = NULL;

	mov	QWORD PTR [rdx], 0

; 86   :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?static_delete@?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAXPEAPEAX@Z ENDP ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::static_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?type@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
_TEXT	SEGMENT
this$ = 8
?type@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::type, COMDAT

; 60   :     virtual const std::type_info& type() CV_OVERRIDE { return typeid(T); }

	lea	rax, OFFSET FLAT:??_R0?AUempty_any@anyimpl@cvflann@@@8
	ret	0
?type@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_size@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAA_KXZ
_TEXT	SEGMENT
this$ = 8
?get_size@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAA_KXZ PROC ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::get_size, COMDAT

; 59   :     virtual ::size_t get_size() CV_OVERRIDE { return sizeof(T); }

	mov	eax, 1
	ret	0
?get_size@?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAA_KXZ ENDP ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::get_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 4224 :     [[noreturn]] static void _Xlen() {

$LN4:
	sub	rsp, 40					; 00000028H

; 4225 :         _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Requested$ = 16
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4122 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rax, QWORD PTR [rcx+24]

; 4109 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	rdx, 15
	mov	r9, 9223372036854775807			; 7fffffffffffffffH
	cmp	rdx, r9

; 4110 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	jbe	SHORT $LN4@Calculate_
$LN9@Calculate_:

; 4123 :     }

	mov	rax, r9
	ret	0
$LN4@Calculate_:

; 4114 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	r8, rax
	mov	rcx, r9
	shr	r8, 1
	sub	rcx, r8
	cmp	rax, rcx
	ja	SHORT $LN9@Calculate_

; 4115 :             return _Max;
; 4116 :         }
; 4117 : 
; 4118 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	rcx, QWORD PTR [r8+rax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

	cmp	rdx, rcx
	cmovb	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4122 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rax, rdx

; 4123 :     }

	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity, COMDAT

; 3617 :         return _Mypair._Myval2._Myres;

	mov	rax, QWORD PTR [rcx+24]

; 3618 :     }

	ret	0
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
_TEXT	SEGMENT
this$ = 64
_Off$dead$ = 72
_Right$ = 80
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 2958 :     basic_string& insert(const size_type _Off, const basic_string& _Right) { // insert _Right at _Off

$LN29:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [r8+24], 16

; 2958 :     basic_string& insert(const size_type _Off, const basic_string& _Right) { // insert _Right at _Off

	mov	r14, rcx

; 2152 :         const value_type* _Result = _Bx._Buf;

	mov	rbx, r8

; 2153 :         if (_Large_string_engaged()) {

	jb	SHORT $LN4@insert

; 2154 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [r8]
$LN4@insert:

; 2959 :         return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	rdi, QWORD PTR [r8+16]

; 2989 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	r8, QWORD PTR [rcx+16]

; 2990 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, rcx
	sub	rax, r8
	cmp	rdi, rax
	ja	$LN9@insert

; 2991 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [rsp+64], rsi
	lea	rax, QWORD PTR [r8+rdi]
	mov	QWORD PTR [r14+16], rax

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	rsi, r14

; 2991 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [rsp+72], r15

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	rcx, 16

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN17@insert

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rsi, QWORD PTR [r14]
$LN17@insert:

; 2998 :                 || _Ptr > _Old_ptr + _Old_size) { // inserted content is before the shifted region, or does not alias

	lea	rax, QWORD PTR [rdi+rbx]
	cmp	rax, rsi
	jbe	SHORT $LN12@insert
	lea	rax, QWORD PTR [rsi+r8]
	cmp	rbx, rax
	ja	SHORT $LN12@insert

; 3000 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts

	cmp	rsi, rbx
	ja	SHORT $LN13@insert

; 3001 :                 _Ptr_shifted_after = 0;

	xor	r15d, r15d

; 3002 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts

	jmp	SHORT $LN14@insert
$LN13@insert:

; 3003 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

	mov	r15, rsi
	sub	r15, rbx
	jmp	SHORT $LN14@insert
$LN12@insert:

; 2999 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts

	mov	r15, rdi
$LN14@insert:

; 3004 :             }
; 3005 : 
; 3006 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	r8
	lea	rcx, QWORD PTR [rsi+rdi]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	rdx, rsi
	call	memmove

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	r8, r15
	mov	rdx, rbx
	mov	rcx, rsi
	call	memcpy

; 3008 :             _Traits::copy(

	mov	r8, rdi
	lea	rdx, QWORD PTR [r15+rdi]
	sub	r8, r15
	lea	rcx, QWORD PTR [rsi+r15]
	add	rdx, rbx

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	call	memcpy

; 2959 :         return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

	mov	r15, QWORD PTR [rsp+72]
	mov	rax, r14
	mov	rsi, QWORD PTR [rsp+64]

; 2960 :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
$LN9@insert:

; 3013 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+40], rdi
	mov	rdx, rdi
	mov	rcx, r14
	mov	QWORD PTR [rsp+32], rbx
	call	??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const *,unsigned __int64>

; 2960 :     }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
	mov	rax, rcx
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 772  :     constexpr allocator() noexcept {}

	mov	rax, rcx
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Requested$ = 8
_Old$ = 16
_Max$ = 24
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4109 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	rcx, 15
	cmp	rcx, r8

; 4110 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN7@Calculate_

; 4111 :             return _Max;
; 4112 :         }
; 4113 : 
; 4114 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	r9, rdx
	mov	rax, r8
	shr	r9, 1
	sub	rax, r9
	cmp	rdx, rax
	ja	SHORT $LN7@Calculate_

; 4118 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [r9+rdx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\utility

; 37   :     return _Left < _Right ? _Right : _Left;

	cmp	rcx, rax
	cmovb	rcx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4118 :         return _Max_value(_Masked, _Old + _Old / 2);

	mov	rax, rcx

; 4119 :     }

	ret	0
$LN7@Calculate_:

; 4115 :             return _Max;

	mov	rax, r8

; 4119 :     }

	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
_TEXT	SEGMENT
this$ = 64
_Off$dead$ = 72
_Ptr$ = 80
_Count$ = 88
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 2986 :         const size_type _Off, _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN22:
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r14, r8
	mov	r15, rcx

; 2987 :         // insert [_Ptr, _Ptr + _Count) at _Off
; 2988 :         _Mypair._Myval2._Check_offset(_Off);
; 2989 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

	mov	r8, QWORD PTR [rcx+16]
	mov	rdi, r9

; 2990 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

	mov	rcx, QWORD PTR [rcx+24]
	mov	rax, rcx
	sub	rax, r8
	cmp	r9, rax
	ja	$LN2@insert

; 2991 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [rsp+64], rbx
	lea	rax, QWORD PTR [r8+r9]
	mov	QWORD PTR [r15+16], rax

; 2143 :         value_type* _Result = _Bx._Buf;

	mov	rbx, r15

; 2991 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

	mov	QWORD PTR [rsp+72], rsi

; 2161 :         return _BUF_SIZE <= _Myres;

	cmp	rcx, 16

; 2144 :         if (_Large_string_engaged()) {

	jb	SHORT $LN10@insert

; 2145 :             _Result = _Unfancy(_Bx._Ptr);

	mov	rbx, QWORD PTR [r15]
$LN10@insert:

; 2992 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2993 :             _Elem* const _Insert_at = _Old_ptr + _Off;
; 2994 :             // the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
; 2995 :             // while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
; 2996 :             size_type _Ptr_shifted_after;
; 2997 :             if (_Ptr + _Count <= _Insert_at
; 2998 :                 || _Ptr > _Old_ptr + _Old_size) { // inserted content is before the shifted region, or does not alias

	lea	rax, QWORD PTR [r14+r9]
	cmp	rax, rbx
	jbe	SHORT $LN5@insert
	lea	rax, QWORD PTR [rbx+r8]
	cmp	r14, rax
	ja	SHORT $LN5@insert

; 3000 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts

	cmp	rbx, r14
	ja	SHORT $LN6@insert

; 3001 :                 _Ptr_shifted_after = 0;

	xor	esi, esi

; 3002 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts

	jmp	SHORT $LN7@insert
$LN6@insert:

; 3003 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

	mov	rsi, rbx
	sub	rsi, r14
	jmp	SHORT $LN7@insert
$LN5@insert:

; 2999 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts

	mov	rsi, rdi
$LN7@insert:

; 3004 :             }
; 3005 : 
; 3006 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

	inc	r8
	lea	rcx, QWORD PTR [rbx+r9]

; 367  :         return static_cast<_Elem*>(_CSTD memmove(_First1, _First2, _Count));

	mov	rdx, rbx
	call	memmove

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	r8, rsi
	mov	rdx, r14
	mov	rcx, rbx
	call	memcpy

; 3007 :             _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
; 3008 :             _Traits::copy(

	mov	r8, rdi
	lea	rdx, QWORD PTR [rsi+r14]
	sub	r8, rsi
	lea	rcx, QWORD PTR [rbx+rsi]
	add	rdx, rdi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	call	memcpy

; 3009 :                 _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
; 3010 :             return *this;

	mov	rsi, QWORD PTR [rsp+72]
	mov	rax, r15
	mov	rbx, QWORD PTR [rsp+64]

; 3014 :             _Count,
; 3015 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3016 :                 const _Elem* const _Ptr, const size_type _Count) {
; 3017 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3018 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3019 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 3020 :             },
; 3021 :             _Off, _Ptr, _Count);
; 3022 :     }

	mov	rdi, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r15
	ret	0
$LN2@insert:

; 3011 :         }
; 3012 : 
; 3013 :         return _Reallocate_grow_by(

	mov	QWORD PTR [rsp+40], rdi
	mov	rdx, rdi
	mov	rcx, r15
	mov	QWORD PTR [rsp+32], r14
	call	??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const *,unsigned __int64>

; 3014 :             _Count,
; 3015 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3016 :                 const _Elem* const _Ptr, const size_type _Count) {
; 3017 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3018 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3019 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 3020 :             },
; 3021 :             _Off, _Ptr, _Count);
; 3022 :     }

	mov	rdi, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r15
	ret	0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBAXQEADQEBD_K212@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Off$dead$ = 80
_Ptr$ = 88
_Count$ = 96
??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBAXQEADQEBD_K212@Z PROC ; <lambda_f3a66ab6a0570788f31503db83886f49>::operator(), COMDAT

; 3016 :                 const _Elem* const _Ptr, const size_type _Count) {

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rbx, QWORD PTR _Count$[rsp]

; 3016 :                 const _Elem* const _Ptr, const size_type _Count) {

	mov	rdi, rdx

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, QWORD PTR _Ptr$[rsp]

; 3016 :                 const _Elem* const _Ptr, const size_type _Count) {

	mov	rbp, r8

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	r8, rbx
	mov	rcx, rdi

; 3016 :                 const _Elem* const _Ptr, const size_type _Count) {

	mov	rsi, r9

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	call	memcpy

; 3017 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3018 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3019 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	r8, QWORD PTR [rsi+1]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, rbp

; 3017 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3018 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3019 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

	lea	rcx, QWORD PTR [rdi+rbx]

; 3020 :             },

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	jmp	memcpy
??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBAXQEADQEBD_K212@Z ENDP ; <lambda_f3a66ab6a0570788f31503db83886f49>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 2186 :         _Bxty() {} // user-provided, for fancy pointers

	mov	rax, rcx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\matx.hpp
;	COMDAT ??0?$Vec@N$03@cv@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$Vec@N$03@cv@@QEAA@XZ PROC				; cv::Vec<double,4>::Vec<double,4>, COMDAT

; 538  :     for(int i = 0; i < channels; i++) val[i] = _Tp(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 969  : Vec<_Tp, cn>::Vec() {}

	mov	rax, rcx
	ret	0
??0?$Vec@N$03@cv@@QEAA@XZ ENDP				; cv::Vec<double,4>::Vec<double,4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ??__F?policy@?$SinglePolicy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@Uempty_any@anyimpl@cvflann@@@23@A@@YAXXZ
text$di	SEGMENT
??__F?policy@?$SinglePolicy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@Uempty_any@anyimpl@cvflann@@@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<cvflann::anyimpl::empty_any>::policy'', COMDAT

; 176  : typename choose_policy<T>::type SinglePolicy<T>::policy;

	lea	rcx, OFFSET FLAT:??__F?policy@?$SinglePolicy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@Uempty_any@anyimpl@cvflann@@@23@A@@YAXXZ ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<cvflann::anyimpl::empty_any>::policy''
	jmp	atexit
??__F?policy@?$SinglePolicy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@Uempty_any@anyimpl@cvflann@@@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<cvflann::anyimpl::empty_any>::policy''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\string
;	COMDAT ??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z
_TEXT	SEGMENT
_RNext$ = 8
_UVal$ = 16
??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z PROC	; std::_UIntegral_to_buff<char,unsigned int>, COMDAT

; 454  : _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal) { // format _UVal into buffer *ending at* _RNext

	mov	r8d, edx
	npad	13
$LL4@UIntegral_:

; 455  :     static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");
; 456  : 
; 457  : #ifdef _WIN64
; 458  :     auto _UVal_trunc = _UVal;
; 459  : #else // ^^^ _WIN64 ^^^ // vvv !_WIN64 vvv
; 460  : 
; 461  :     constexpr bool _Big_uty = sizeof(_UTy) > 4;
; 462  :     if
; 463  :         _CONSTEXPR_IF(_Big_uty) { // For 64-bit numbers, work in chunks to avoid 64-bit divisions.
; 464  :             while (_UVal > 0xFFFFFFFFU) {
; 465  :                 auto _UVal_chunk = static_cast<unsigned long>(_UVal % 1000000000);
; 466  :                 _UVal /= 1000000000;
; 467  : 
; 468  :                 for (int _Idx = 0; _Idx != 9; ++_Idx) {
; 469  :                     *--_RNext = static_cast<_Elem>('0' + _UVal_chunk % 10);
; 470  :                     _UVal_chunk /= 10;
; 471  :                 }
; 472  :             }
; 473  :         }
; 474  : 
; 475  :     auto _UVal_trunc = static_cast<unsigned long>(_UVal);
; 476  : #endif // _WIN64
; 477  : 
; 478  :     do {
; 479  :         *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);

	dec	rcx
	mov	eax, -858993459				; cccccccdH
	mul	r8d
	shr	edx, 3
	movzx	eax, dl
	shl	al, 2
	lea	r9d, DWORD PTR [rax+rdx]
	add	r9b, r9b
	sub	r8b, r9b
	add	r8b, 48					; 00000030H
	mov	BYTE PTR [rcx], r8b

; 480  :         _UVal_trunc /= 10;

	mov	r8d, edx

; 481  :     } while (_UVal_trunc != 0);

	test	edx, edx
	jne	SHORT $LL4@UIntegral_

; 482  :     return _RNext;

	mov	rax, rcx

; 483  : }

	ret	0
??$_UIntegral_to_buff@DI@std@@YAPEADPEADI@Z ENDP	; std::_UIntegral_to_buff<char,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
_First$ = 56
_Last$ = 64
_Al$dead$ = 72
??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>, COMDAT

; 2375 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H

; 4201 :         _Mypair._Myval2._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 2375 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al) {

	mov	rbx, rcx

; 4202 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 4203 :         // the _Traits::assign is last so the codegen doesn't think the char
; 4204 :         // write can alias this
; 4205 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

	mov	BYTE PTR [rcx], 0

; 2405 :         if (_First != _Last) {

	cmp	rdx, r8
	je	SHORT $LN12@allocator

; 2406 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));

	sub	r8, rdx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN12@allocator:

; 2376 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2377 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2378 :         _Tidy_init();
; 2379 :         _Adl_verify_range(_First, _Last);
; 2380 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());
; 2381 :         _Proxy._Release();
; 2382 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?0PEAD$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEAD0AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1453 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1454 : }

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstddef
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 275  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 276  : }

	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1453 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1454 : }

	ret	0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 87   : _DECLSPEC_ALLOCATOR void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN17:
	sub	rsp, 40					; 00000028H

; 88   :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	SHORT $LN16@Allocate_m

; 51   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 92   :     }
; 93   : 
; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN7@Allocate_m

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 98   : 
; 99   : #ifdef _DEBUG
; 100  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 101  : #endif // _DEBUG
; 102  :     return _Ptr;
; 103  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@Allocate_m:

; 92   :     }
; 93   : 
; 94   :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN16@Allocate_m:

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN14@Allocate_m:
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
_TEXT	SEGMENT
this$ = 80
_Size_increase$ = 88
_Fn$dead$ = 96
<_Args_0>$dead$ = 104
<_Args_1>$ = 112
<_Args_2>$ = 120
??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const *,unsigned __int64>, COMDAT

; 4152 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN77:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
	mov	r12, QWORD PTR <_Args_1>$[rsp]

; 4153 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4154 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4155 :         auto& _My_data            = _Mypair._Myval2;
; 4156 :         const size_type _Old_size = _My_data._Mysize;

	mov	r14, QWORD PTR [rcx+16]

; 4157 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, rbx
	sub	rax, r14
	cmp	rax, rdx
	jb	$LN74@Reallocate

; 4159 :         }
; 4160 : 
; 4161 :         const size_type _New_size     = _Old_size + _Size_increase;

	lea	r15, QWORD PTR [rdx+r14]

; 4162 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rbp, QWORD PTR [rcx+24]

; 4109 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rdx, r15
	or	rdx, 15
	cmp	rdx, rbx

; 4110 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN8@Reallocate

; 4111 :             return _Max;
; 4112 :         }
; 4113 : 
; 4114 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, rbp
	shr	rcx, 1
	mov	rax, rbx
	sub	rax, rcx
	cmp	rbp, rax
	ja	SHORT $LN8@Reallocate

; 4115 :             return _Max;
; 4116 :         }
; 4117 : 
; 4118 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+rbp]
	mov	rbx, rdx
	cmp	rdx, rax
	cmovb	rbx, rax
$LN8@Reallocate:

; 4163 :         const size_type _New_capacity = _Calculate_growth(_New_size);
; 4164 :         auto& _Al                     = _Getal();
; 4165 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rcx, rbx
	add	rcx, 1
	mov	rax, -1
	cmovb	rcx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 174  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rcx, 4096				; 00001000H
	jb	SHORT $LN17@Reallocate

; 89   :     const size_t _Block_size = _Non_user_size + _Bytes;

	lea	rax, QWORD PTR [rcx+39]

; 90   :     if (_Block_size <= _Bytes) {

	cmp	rax, rcx
	jbe	$LN75@Reallocate

; 51   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN26@Reallocate

; 96   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 97   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 175  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN26@Reallocate:

; 95   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN17@Reallocate:

; 179  :     if (_Bytes != 0) {

	test	rcx, rcx
	je	SHORT $LN18@Reallocate

; 51   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 180  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN16@Reallocate
$LN18@Reallocate:

; 181  :     }
; 182  : 
; 183  :     return nullptr;

	xor	edi, edi
$LN16@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4167 :         _My_data._Mysize      = _New_size;

	mov	QWORD PTR [rsi+16], r15

; 4168 :         _My_data._Myres       = _New_capacity;

	mov	QWORD PTR [rsi+24], rbx

; 4169 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	r8, QWORD PTR <_Args_2>$[rsp]
	lea	r15, QWORD PTR [rdi+r8]

; 4170 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	rdx, r12
	mov	rcx, rdi
	cmp	rbp, 16
	jb	SHORT $LN3@Reallocate

; 4171 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rbx, QWORD PTR [rsi]

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	call	memcpy
	lea	r8, QWORD PTR [r14+1]
	mov	rdx, rbx
	mov	rcx, r15
	call	memcpy

; 4172 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4173 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	lea	rdx, QWORD PTR [rbp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN61@Reallocate

; 108  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 109  : 
; 110  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 111  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rbx-8]

; 112  : 
; 113  :     // If the following asserts, it likely means that we are performing
; 114  :     // an aligned delete on memory coming from an unaligned allocation.
; 115  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 116  : 
; 117  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 118  :     // in range [_Min_back_shift, _Non_user_size]
; 119  : #ifdef _DEBUG
; 120  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 121  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 122  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 123  : #endif // _DEBUG
; 124  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rbx, rcx

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rbx-8]
	cmp	rax, 31
	ja	SHORT $LN58@Reallocate

; 126  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rbx, rcx
$LN61@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4175 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN58@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 125  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 332  :         return static_cast<_Elem*>(_CSTD memcpy(_First1, _First2, _Count));

	call	memcpy
	lea	r8, QWORD PTR [r14+1]
	mov	rdx, rsi
	mov	rcx, r15
	call	memcpy
$LN4@Reallocate:

; 4176 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4177 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 4178 :         }
; 4179 : 
; 4180 :         return *this;

	mov	QWORD PTR [rsi], rdi
	mov	rax, rsi

; 4181 :     }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN75@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 91   :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	int	3
$LN74@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 4158 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
	int	3
$LN72@Reallocate:
??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const *,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??__F?policy@?$SinglePolicy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@Uempty_any@anyimpl@cvflann@@@23@A@@YAXXZ
text$yd	SEGMENT
??__F?policy@?$SinglePolicy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@Uempty_any@anyimpl@cvflann@@@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<cvflann::anyimpl::empty_any>::policy'', COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR ?policy@?$SinglePolicy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@Uempty_any@anyimpl@cvflann@@@23@A, rax ; cvflann::anyimpl::SinglePolicy<cvflann::anyimpl::empty_any>::policy
	ret	0
??__F?policy@?$SinglePolicy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@Uempty_any@anyimpl@cvflann@@@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<cvflann::anyimpl::empty_any>::policy''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z PROC ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::`scalar deleting destructor', COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN4@scalar
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z ENDP ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAA@XZ PROC ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::~big_any_policy<cvflann::anyimpl::empty_any>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$big_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAA@XZ ENDP ; cvflann::anyimpl::big_any_policy<cvflann::anyimpl::empty_any>::~big_any_policy<cvflann::anyimpl::empty_any>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAA@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::~typed_base_any_policy<cvflann::anyimpl::empty_any>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$typed_base_any_policy@Uempty_any@anyimpl@cvflann@@@anyimpl@cvflann@@UEAA@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<cvflann::anyimpl::empty_any>::~typed_base_any_policy<cvflann::anyimpl::empty_any>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?print@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
out$ = 16
src$ = 24
?print@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z PROC ; cvflann::anyimpl::small_any_policy<char const *>::print, COMDAT

; 76   :     virtual void print(std::ostream& out, void* const* src) CV_OVERRIDE { out << *reinterpret_cast<T const*>(src); }

	mov	rcx, rdx
	mov	rdx, QWORD PTR [r8]
	jmp	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
?print@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<char const *>::print
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z PROC ; cvflann::anyimpl::small_any_policy<char const *>::get_value, COMDAT

; 75   :     virtual const void* get_value(void* const * src) CV_OVERRIDE { return reinterpret_cast<const void*>(src); }

	mov	rax, rdx
	ret	0
?get_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<char const *>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<char const *>::get_value, COMDAT

; 74   :     virtual void* get_value(void** src) CV_OVERRIDE { return reinterpret_cast<void*>(src); }

	mov	rax, rdx
	ret	0
?get_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<char const *>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?move@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?move@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<char const *>::move, COMDAT

; 73   :     virtual void move(void* const* src, void** dest) CV_OVERRIDE { *dest = *src; }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax
	ret	0
?move@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<char const *>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?clone@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?clone@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<char const *>::clone, COMDAT

; 72   :     virtual void clone(void* const* src, void** dest) CV_OVERRIDE { *dest = *src; }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax
	ret	0
?clone@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<char const *>::clone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?copy_from_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?copy_from_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<char const *>::copy_from_value, COMDAT

; 70   :         new (dest) T(* reinterpret_cast<T const*>(src));

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 71   :     }

	ret	0
?copy_from_value@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<char const *>::copy_from_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?static_delete@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?static_delete@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<char const *>::static_delete, COMDAT

; 67   :     virtual void static_delete(void**) CV_OVERRIDE { }

	ret	0
?static_delete@?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<char const *>::static_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?type@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
_TEXT	SEGMENT
this$ = 8
?type@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<char const *>::type, COMDAT

; 60   :     virtual const std::type_info& type() CV_OVERRIDE { return typeid(T); }

	lea	rax, OFFSET FLAT:??_R0PEBD@8
	ret	0
?type@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<char const *>::type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_size@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@UEAA_KXZ
_TEXT	SEGMENT
this$ = 8
?get_size@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@UEAA_KXZ PROC ; cvflann::anyimpl::typed_base_any_policy<char const *>::get_size, COMDAT

; 59   :     virtual ::size_t get_size() CV_OVERRIDE { return sizeof(T); }

	mov	eax, 8
	ret	0
?get_size@?$typed_base_any_policy@PEBD@anyimpl@cvflann@@UEAA_KXZ ENDP ; cvflann::anyimpl::typed_base_any_policy<char const *>::get_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
;	COMDAT ?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXQEAD0Urandom_access_iterator_tag@2@@Z
_TEXT	SEGMENT
this$ = 8
_First$ = 16
_Last$ = 24
__formal$dead$ = 32
?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXQEAD0Urandom_access_iterator_tag@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct, COMDAT

; 2404 :         // initialize from [_First, _Last), pointers
; 2405 :         if (_First != _Last) {

	cmp	rdx, r8
	je	SHORT $LN2@Construct

; 2406 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));

	sub	r8, rdx
	jmp	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@Construct:

; 2407 :         }
; 2408 :     }

	ret	0
?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXQEAD0Urandom_access_iterator_tag@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\core\matx.hpp
;	COMDAT ??0?$Matx@N$03$00@cv@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$Matx@N$03$00@cv@@QEAA@XZ PROC			; cv::Matx<double,4,1>::Matx<double,4,1>, COMDAT

; 538  :     for(int i = 0; i < channels; i++) val[i] = _Tp(0);

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 539  : }

	mov	rax, rcx
	ret	0
??0?$Matx@N$03$00@cv@@QEAA@XZ ENDP			; cv::Matx<double,4,1>::Matx<double,4,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ??__F?policy@?$SinglePolicy@PEBD@anyimpl@cvflann@@0U?$small_any_policy@PEBD@23@A@@YAXXZ
text$di	SEGMENT
??__F?policy@?$SinglePolicy@PEBD@anyimpl@cvflann@@0U?$small_any_policy@PEBD@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<char const *>::policy'', COMDAT

; 176  : typename choose_policy<T>::type SinglePolicy<T>::policy;

	lea	rcx, OFFSET FLAT:??__F?policy@?$SinglePolicy@PEBD@anyimpl@cvflann@@0U?$small_any_policy@PEBD@23@A@@YAXXZ ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<char const *>::policy''
	jmp	atexit
??__F?policy@?$SinglePolicy@PEBD@anyimpl@cvflann@@0U?$small_any_policy@PEBD@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<char const *>::policy''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xstring

; 2132 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) {}

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\xmemory

; 1333 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??__F?policy@?$SinglePolicy@PEBD@anyimpl@cvflann@@0U?$small_any_policy@PEBD@23@A@@YAXXZ
text$yd	SEGMENT
??__F?policy@?$SinglePolicy@PEBD@anyimpl@cvflann@@0U?$small_any_policy@PEBD@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<char const *>::policy'', COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR ?policy@?$SinglePolicy@PEBD@anyimpl@cvflann@@0U?$small_any_policy@PEBD@23@A, rax ; cvflann::anyimpl::SinglePolicy<char const *>::policy
	ret	0
??__F?policy@?$SinglePolicy@PEBD@anyimpl@cvflann@@0U?$small_any_policy@PEBD@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<char const *>::policy''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEAXI@Z PROC ; cvflann::anyimpl::small_any_policy<char const *>::`scalar deleting destructor', COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN4@scalar
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$small_any_policy@PEBD@anyimpl@cvflann@@UEAAPEAXI@Z ENDP ; cvflann::anyimpl::small_any_policy<char const *>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$small_any_policy@PEBD@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$small_any_policy@PEBD@anyimpl@cvflann@@UEAA@XZ PROC ; cvflann::anyimpl::small_any_policy<char const *>::~small_any_policy<char const *>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$small_any_policy@PEBD@anyimpl@cvflann@@UEAA@XZ ENDP ; cvflann::anyimpl::small_any_policy<char const *>::~small_any_policy<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$typed_base_any_policy@PEBD@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$typed_base_any_policy@PEBD@anyimpl@cvflann@@UEAA@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<char const *>::~typed_base_any_policy<char const *>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$typed_base_any_policy@PEBD@anyimpl@cvflann@@UEAA@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<char const *>::~typed_base_any_policy<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?print@?$small_any_policy@I@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
out$ = 16
src$ = 24
?print@?$small_any_policy@I@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z PROC ; cvflann::anyimpl::small_any_policy<unsigned int>::print, COMDAT

; 76   :     virtual void print(std::ostream& out, void* const* src) CV_OVERRIDE { out << *reinterpret_cast<T const*>(src); }

	mov	rcx, rdx
	mov	edx, DWORD PTR [r8]
	rex_jmp	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@I@Z
?print@?$small_any_policy@I@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<unsigned int>::print
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z PROC ; cvflann::anyimpl::small_any_policy<unsigned int>::get_value, COMDAT

; 75   :     virtual const void* get_value(void* const * src) CV_OVERRIDE { return reinterpret_cast<const void*>(src); }

	mov	rax, rdx
	ret	0
?get_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<unsigned int>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<unsigned int>::get_value, COMDAT

; 74   :     virtual void* get_value(void** src) CV_OVERRIDE { return reinterpret_cast<void*>(src); }

	mov	rax, rdx
	ret	0
?get_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<unsigned int>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?move@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?move@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<unsigned int>::move, COMDAT

; 73   :     virtual void move(void* const* src, void** dest) CV_OVERRIDE { *dest = *src; }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax
	ret	0
?move@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<unsigned int>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?clone@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?clone@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<unsigned int>::clone, COMDAT

; 72   :     virtual void clone(void* const* src, void** dest) CV_OVERRIDE { *dest = *src; }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax
	ret	0
?clone@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<unsigned int>::clone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?copy_from_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?copy_from_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<unsigned int>::copy_from_value, COMDAT

; 70   :         new (dest) T(* reinterpret_cast<T const*>(src));

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax

; 71   :     }

	ret	0
?copy_from_value@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<unsigned int>::copy_from_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?static_delete@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?static_delete@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<unsigned int>::static_delete, COMDAT

; 67   :     virtual void static_delete(void**) CV_OVERRIDE { }

	ret	0
?static_delete@?$small_any_policy@I@anyimpl@cvflann@@UEAAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<unsigned int>::static_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?type@?$typed_base_any_policy@I@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
_TEXT	SEGMENT
this$ = 8
?type@?$typed_base_any_policy@I@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::type, COMDAT

; 60   :     virtual const std::type_info& type() CV_OVERRIDE { return typeid(T); }

	lea	rax, OFFSET FLAT:??_R0I@8
	ret	0
?type@?$typed_base_any_policy@I@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_size@?$typed_base_any_policy@I@anyimpl@cvflann@@UEAA_KXZ
_TEXT	SEGMENT
this$ = 8
?get_size@?$typed_base_any_policy@I@anyimpl@cvflann@@UEAA_KXZ PROC ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::get_size, COMDAT

; 59   :     virtual ::size_t get_size() CV_OVERRIDE { return sizeof(T); }

	mov	eax, 4
	ret	0
?get_size@?$typed_base_any_policy@I@anyimpl@cvflann@@UEAA_KXZ ENDP ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::get_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?print@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
out$ = 16
src$ = 24
?print@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z PROC ; cvflann::anyimpl::small_any_policy<bool>::print, COMDAT

; 76   :     virtual void print(std::ostream& out, void* const* src) CV_OVERRIDE { out << *reinterpret_cast<T const*>(src); }

	mov	rcx, rdx
	movzx	edx, BYTE PTR [r8]
	rex_jmp	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_N@Z
?print@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<bool>::print
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z PROC ; cvflann::anyimpl::small_any_policy<bool>::get_value, COMDAT

; 75   :     virtual const void* get_value(void* const * src) CV_OVERRIDE { return reinterpret_cast<const void*>(src); }

	mov	rax, rdx
	ret	0
?get_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<bool>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<bool>::get_value, COMDAT

; 74   :     virtual void* get_value(void** src) CV_OVERRIDE { return reinterpret_cast<void*>(src); }

	mov	rax, rdx
	ret	0
?get_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<bool>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?move@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?move@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<bool>::move, COMDAT

; 73   :     virtual void move(void* const* src, void** dest) CV_OVERRIDE { *dest = *src; }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax
	ret	0
?move@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<bool>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?clone@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?clone@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<bool>::clone, COMDAT

; 72   :     virtual void clone(void* const* src, void** dest) CV_OVERRIDE { *dest = *src; }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax
	ret	0
?clone@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<bool>::clone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?copy_from_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?copy_from_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<bool>::copy_from_value, COMDAT

; 70   :         new (dest) T(* reinterpret_cast<T const*>(src));

	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r8], al

; 71   :     }

	ret	0
?copy_from_value@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<bool>::copy_from_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?static_delete@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?static_delete@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<bool>::static_delete, COMDAT

; 67   :     virtual void static_delete(void**) CV_OVERRIDE { }

	ret	0
?static_delete@?$small_any_policy@_N@anyimpl@cvflann@@UEAAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<bool>::static_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?type@?$typed_base_any_policy@_N@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
_TEXT	SEGMENT
this$ = 8
?type@?$typed_base_any_policy@_N@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<bool>::type, COMDAT

; 60   :     virtual const std::type_info& type() CV_OVERRIDE { return typeid(T); }

	lea	rax, OFFSET FLAT:??_R0_N@8
	ret	0
?type@?$typed_base_any_policy@_N@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<bool>::type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_size@?$typed_base_any_policy@_N@anyimpl@cvflann@@UEAA_KXZ
_TEXT	SEGMENT
this$ = 8
?get_size@?$typed_base_any_policy@_N@anyimpl@cvflann@@UEAA_KXZ PROC ; cvflann::anyimpl::typed_base_any_policy<bool>::get_size, COMDAT

; 59   :     virtual ::size_t get_size() CV_OVERRIDE { return sizeof(T); }

	mov	eax, 1
	ret	0
?get_size@?$typed_base_any_policy@_N@anyimpl@cvflann@@UEAA_KXZ ENDP ; cvflann::anyimpl::typed_base_any_policy<bool>::get_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?print@?$small_any_policy@M@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
out$ = 16
src$ = 24
?print@?$small_any_policy@M@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z PROC ; cvflann::anyimpl::small_any_policy<float>::print, COMDAT

; 76   :     virtual void print(std::ostream& out, void* const* src) CV_OVERRIDE { out << *reinterpret_cast<T const*>(src); }

	movss	xmm1, DWORD PTR [r8]
	mov	rcx, rdx
	rex_jmp	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@M@Z
?print@?$small_any_policy@M@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<float>::print
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z PROC ; cvflann::anyimpl::small_any_policy<float>::get_value, COMDAT

; 75   :     virtual const void* get_value(void* const * src) CV_OVERRIDE { return reinterpret_cast<const void*>(src); }

	mov	rax, rdx
	ret	0
?get_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<float>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<float>::get_value, COMDAT

; 74   :     virtual void* get_value(void** src) CV_OVERRIDE { return reinterpret_cast<void*>(src); }

	mov	rax, rdx
	ret	0
?get_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<float>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?move@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?move@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<float>::move, COMDAT

; 73   :     virtual void move(void* const* src, void** dest) CV_OVERRIDE { *dest = *src; }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax
	ret	0
?move@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<float>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?clone@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?clone@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<float>::clone, COMDAT

; 72   :     virtual void clone(void* const* src, void** dest) CV_OVERRIDE { *dest = *src; }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax
	ret	0
?clone@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<float>::clone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?copy_from_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?copy_from_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<float>::copy_from_value, COMDAT

; 70   :         new (dest) T(* reinterpret_cast<T const*>(src));

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax

; 71   :     }

	ret	0
?copy_from_value@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<float>::copy_from_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?static_delete@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?static_delete@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<float>::static_delete, COMDAT

; 67   :     virtual void static_delete(void**) CV_OVERRIDE { }

	ret	0
?static_delete@?$small_any_policy@M@anyimpl@cvflann@@UEAAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<float>::static_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?type@?$typed_base_any_policy@M@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
_TEXT	SEGMENT
this$ = 8
?type@?$typed_base_any_policy@M@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<float>::type, COMDAT

; 60   :     virtual const std::type_info& type() CV_OVERRIDE { return typeid(T); }

	lea	rax, OFFSET FLAT:??_R0M@8
	ret	0
?type@?$typed_base_any_policy@M@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<float>::type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_size@?$typed_base_any_policy@M@anyimpl@cvflann@@UEAA_KXZ
_TEXT	SEGMENT
this$ = 8
?get_size@?$typed_base_any_policy@M@anyimpl@cvflann@@UEAA_KXZ PROC ; cvflann::anyimpl::typed_base_any_policy<float>::get_size, COMDAT

; 59   :     virtual ::size_t get_size() CV_OVERRIDE { return sizeof(T); }

	mov	eax, 4
	ret	0
?get_size@?$typed_base_any_policy@M@anyimpl@cvflann@@UEAA_KXZ ENDP ; cvflann::anyimpl::typed_base_any_policy<float>::get_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?print@?$small_any_policy@H@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
out$ = 16
src$ = 24
?print@?$small_any_policy@H@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z PROC ; cvflann::anyimpl::small_any_policy<int>::print, COMDAT

; 76   :     virtual void print(std::ostream& out, void* const* src) CV_OVERRIDE { out << *reinterpret_cast<T const*>(src); }

	mov	rcx, rdx
	mov	edx, DWORD PTR [r8]
	rex_jmp	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
?print@?$small_any_policy@H@anyimpl@cvflann@@UEAAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PEBQEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<int>::print
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z PROC ; cvflann::anyimpl::small_any_policy<int>::get_value, COMDAT

; 75   :     virtual const void* get_value(void* const * src) CV_OVERRIDE { return reinterpret_cast<const void*>(src); }

	mov	rax, rdx
	ret	0
?get_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAPEBXPEBQEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<int>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
?get_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<int>::get_value, COMDAT

; 74   :     virtual void* get_value(void** src) CV_OVERRIDE { return reinterpret_cast<void*>(src); }

	mov	rax, rdx
	ret	0
?get_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAPEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<int>::get_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?move@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?move@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<int>::move, COMDAT

; 73   :     virtual void move(void* const* src, void** dest) CV_OVERRIDE { *dest = *src; }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax
	ret	0
?move@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<int>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?clone@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?clone@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<int>::clone, COMDAT

; 72   :     virtual void clone(void* const* src, void** dest) CV_OVERRIDE { *dest = *src; }

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax
	ret	0
?clone@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBQEAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<int>::clone
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?copy_from_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
src$ = 16
dest$ = 24
?copy_from_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<int>::copy_from_value, COMDAT

; 70   :         new (dest) T(* reinterpret_cast<T const*>(src));

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [r8], eax

; 71   :     }

	ret	0
?copy_from_value@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEBXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<int>::copy_from_value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?static_delete@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?static_delete@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEAPEAX@Z PROC ; cvflann::anyimpl::small_any_policy<int>::static_delete, COMDAT

; 67   :     virtual void static_delete(void**) CV_OVERRIDE { }

	ret	0
?static_delete@?$small_any_policy@H@anyimpl@cvflann@@UEAAXPEAPEAX@Z ENDP ; cvflann::anyimpl::small_any_policy<int>::static_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?type@?$typed_base_any_policy@H@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ
_TEXT	SEGMENT
this$ = 8
?type@?$typed_base_any_policy@H@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<int>::type, COMDAT

; 60   :     virtual const std::type_info& type() CV_OVERRIDE { return typeid(T); }

	lea	rax, OFFSET FLAT:??_R0H@8
	ret	0
?type@?$typed_base_any_policy@H@anyimpl@cvflann@@UEAAAEBVtype_info@@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<int>::type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ?get_size@?$typed_base_any_policy@H@anyimpl@cvflann@@UEAA_KXZ
_TEXT	SEGMENT
this$ = 8
?get_size@?$typed_base_any_policy@H@anyimpl@cvflann@@UEAA_KXZ PROC ; cvflann::anyimpl::typed_base_any_policy<int>::get_size, COMDAT

; 59   :     virtual ::size_t get_size() CV_OVERRIDE { return sizeof(T); }

	mov	eax, 4
	ret	0
?get_size@?$typed_base_any_policy@H@anyimpl@cvflann@@UEAA_KXZ ENDP ; cvflann::anyimpl::typed_base_any_policy<int>::get_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ??__F?policy@?$SinglePolicy@H@anyimpl@cvflann@@0U?$small_any_policy@H@23@A@@YAXXZ
text$di	SEGMENT
??__F?policy@?$SinglePolicy@H@anyimpl@cvflann@@0U?$small_any_policy@H@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<int>::policy'', COMDAT

; 176  : typename choose_policy<T>::type SinglePolicy<T>::policy;

	lea	rcx, OFFSET FLAT:??__F?policy@?$SinglePolicy@H@anyimpl@cvflann@@0U?$small_any_policy@H@23@A@@YAXXZ ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<int>::policy''
	jmp	atexit
??__F?policy@?$SinglePolicy@H@anyimpl@cvflann@@0U?$small_any_policy@H@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<int>::policy''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ??__F?policy@?$SinglePolicy@M@anyimpl@cvflann@@0U?$small_any_policy@M@23@A@@YAXXZ
text$di	SEGMENT
??__F?policy@?$SinglePolicy@M@anyimpl@cvflann@@0U?$small_any_policy@M@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<float>::policy'', COMDAT

; 176  : typename choose_policy<T>::type SinglePolicy<T>::policy;

	lea	rcx, OFFSET FLAT:??__F?policy@?$SinglePolicy@M@anyimpl@cvflann@@0U?$small_any_policy@M@23@A@@YAXXZ ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<float>::policy''
	jmp	atexit
??__F?policy@?$SinglePolicy@M@anyimpl@cvflann@@0U?$small_any_policy@M@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<float>::policy''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ??__F?policy@?$SinglePolicy@_N@anyimpl@cvflann@@0U?$small_any_policy@_N@23@A@@YAXXZ
text$di	SEGMENT
??__F?policy@?$SinglePolicy@_N@anyimpl@cvflann@@0U?$small_any_policy@_N@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<bool>::policy'', COMDAT

; 176  : typename choose_policy<T>::type SinglePolicy<T>::policy;

	lea	rcx, OFFSET FLAT:??__F?policy@?$SinglePolicy@_N@anyimpl@cvflann@@0U?$small_any_policy@_N@23@A@@YAXXZ ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<bool>::policy''
	jmp	atexit
??__F?policy@?$SinglePolicy@_N@anyimpl@cvflann@@0U?$small_any_policy@_N@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<bool>::policy''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ??__F?policy@?$SinglePolicy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_algorithm_t@cvflann@@@23@A@@YAXXZ
text$di	SEGMENT
??__F?policy@?$SinglePolicy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_algorithm_t@cvflann@@@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<enum cvflann::flann_algorithm_t>::policy'', COMDAT

; 176  : typename choose_policy<T>::type SinglePolicy<T>::policy;

	lea	rcx, OFFSET FLAT:??__F?policy@?$SinglePolicy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_algorithm_t@cvflann@@@23@A@@YAXXZ ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<enum cvflann::flann_algorithm_t>::policy''
	jmp	atexit
??__F?policy@?$SinglePolicy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_algorithm_t@cvflann@@@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<enum cvflann::flann_algorithm_t>::policy''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ??__F?policy@?$SinglePolicy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_centers_init_t@cvflann@@@23@A@@YAXXZ
text$di	SEGMENT
??__F?policy@?$SinglePolicy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_centers_init_t@cvflann@@@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<enum cvflann::flann_centers_init_t>::policy'', COMDAT

; 176  : typename choose_policy<T>::type SinglePolicy<T>::policy;

	lea	rcx, OFFSET FLAT:??__F?policy@?$SinglePolicy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_centers_init_t@cvflann@@@23@A@@YAXXZ ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<enum cvflann::flann_centers_init_t>::policy''
	jmp	atexit
??__F?policy@?$SinglePolicy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_centers_init_t@cvflann@@@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<enum cvflann::flann_centers_init_t>::policy''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ??__F?policy@?$SinglePolicy@I@anyimpl@cvflann@@0U?$small_any_policy@I@23@A@@YAXXZ
text$di	SEGMENT
??__F?policy@?$SinglePolicy@I@anyimpl@cvflann@@0U?$small_any_policy@I@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<unsigned int>::policy'', COMDAT

; 176  : typename choose_policy<T>::type SinglePolicy<T>::policy;

	lea	rcx, OFFSET FLAT:??__F?policy@?$SinglePolicy@I@anyimpl@cvflann@@0U?$small_any_policy@I@23@A@@YAXXZ ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<unsigned int>::policy''
	jmp	atexit
??__F?policy@?$SinglePolicy@I@anyimpl@cvflann@@0U?$small_any_policy@I@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<unsigned int>::policy''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\opencv\build\include\opencv2\flann\any.h
;	COMDAT ??__F?policy@?$SinglePolicy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@0U?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@23@A@@YAXXZ
text$di	SEGMENT
??__F?policy@?$SinglePolicy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@0U?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::policy'', COMDAT

; 176  : typename choose_policy<T>::type SinglePolicy<T>::policy;

	lea	rcx, OFFSET FLAT:??__F?policy@?$SinglePolicy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@0U?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@23@A@@YAXXZ ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::policy''
	jmp	atexit
??__F?policy@?$SinglePolicy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@0U?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::policy''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1453 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1454 : }

	ret	0
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??__F?policy@?$SinglePolicy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@0U?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@23@A@@YAXXZ
text$yd	SEGMENT
??__F?policy@?$SinglePolicy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@0U?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::policy'', COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR ?policy@?$SinglePolicy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@0U?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@23@A, rax ; cvflann::anyimpl::SinglePolicy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::policy
	ret	0
??__F?policy@?$SinglePolicy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@0U?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::policy''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??__F?policy@?$SinglePolicy@I@anyimpl@cvflann@@0U?$small_any_policy@I@23@A@@YAXXZ
text$yd	SEGMENT
??__F?policy@?$SinglePolicy@I@anyimpl@cvflann@@0U?$small_any_policy@I@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<unsigned int>::policy'', COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR ?policy@?$SinglePolicy@I@anyimpl@cvflann@@0U?$small_any_policy@I@23@A, rax ; cvflann::anyimpl::SinglePolicy<unsigned int>::policy
	ret	0
??__F?policy@?$SinglePolicy@I@anyimpl@cvflann@@0U?$small_any_policy@I@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<unsigned int>::policy''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??__F?policy@?$SinglePolicy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_centers_init_t@cvflann@@@23@A@@YAXXZ
text$yd	SEGMENT
??__F?policy@?$SinglePolicy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_centers_init_t@cvflann@@@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<enum cvflann::flann_centers_init_t>::policy'', COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR ?policy@?$SinglePolicy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_centers_init_t@cvflann@@@23@A, rax ; cvflann::anyimpl::SinglePolicy<enum cvflann::flann_centers_init_t>::policy
	ret	0
??__F?policy@?$SinglePolicy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_centers_init_t@cvflann@@@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<enum cvflann::flann_centers_init_t>::policy''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??__F?policy@?$SinglePolicy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_algorithm_t@cvflann@@@23@A@@YAXXZ
text$yd	SEGMENT
??__F?policy@?$SinglePolicy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_algorithm_t@cvflann@@@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<enum cvflann::flann_algorithm_t>::policy'', COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR ?policy@?$SinglePolicy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_algorithm_t@cvflann@@@23@A, rax ; cvflann::anyimpl::SinglePolicy<enum cvflann::flann_algorithm_t>::policy
	ret	0
??__F?policy@?$SinglePolicy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@0U?$big_any_policy@W4flann_algorithm_t@cvflann@@@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<enum cvflann::flann_algorithm_t>::policy''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??__F?policy@?$SinglePolicy@_N@anyimpl@cvflann@@0U?$small_any_policy@_N@23@A@@YAXXZ
text$yd	SEGMENT
??__F?policy@?$SinglePolicy@_N@anyimpl@cvflann@@0U?$small_any_policy@_N@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<bool>::policy'', COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR ?policy@?$SinglePolicy@_N@anyimpl@cvflann@@0U?$small_any_policy@_N@23@A, rax ; cvflann::anyimpl::SinglePolicy<bool>::policy
	ret	0
??__F?policy@?$SinglePolicy@_N@anyimpl@cvflann@@0U?$small_any_policy@_N@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<bool>::policy''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??__F?policy@?$SinglePolicy@M@anyimpl@cvflann@@0U?$small_any_policy@M@23@A@@YAXXZ
text$yd	SEGMENT
??__F?policy@?$SinglePolicy@M@anyimpl@cvflann@@0U?$small_any_policy@M@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<float>::policy'', COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR ?policy@?$SinglePolicy@M@anyimpl@cvflann@@0U?$small_any_policy@M@23@A, rax ; cvflann::anyimpl::SinglePolicy<float>::policy
	ret	0
??__F?policy@?$SinglePolicy@M@anyimpl@cvflann@@0U?$small_any_policy@M@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<float>::policy''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??__F?policy@?$SinglePolicy@H@anyimpl@cvflann@@0U?$small_any_policy@H@23@A@@YAXXZ
text$yd	SEGMENT
??__F?policy@?$SinglePolicy@H@anyimpl@cvflann@@0U?$small_any_policy@H@23@A@@YAXXZ PROC ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<int>::policy'', COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR ?policy@?$SinglePolicy@H@anyimpl@cvflann@@0U?$small_any_policy@H@23@A, rax ; cvflann::anyimpl::SinglePolicy<int>::policy
	ret	0
??__F?policy@?$SinglePolicy@H@anyimpl@cvflann@@0U?$small_any_policy@H@23@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'cvflann::anyimpl::SinglePolicy<int>::policy''
text$yd	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$small_any_policy@H@anyimpl@cvflann@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$small_any_policy@H@anyimpl@cvflann@@UEAAPEAXI@Z PROC ; cvflann::anyimpl::small_any_policy<int>::`scalar deleting destructor', COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN4@scalar
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$small_any_policy@H@anyimpl@cvflann@@UEAAPEAXI@Z ENDP ; cvflann::anyimpl::small_any_policy<int>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$small_any_policy@H@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$small_any_policy@H@anyimpl@cvflann@@UEAA@XZ PROC	; cvflann::anyimpl::small_any_policy<int>::~small_any_policy<int>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$small_any_policy@H@anyimpl@cvflann@@UEAA@XZ ENDP	; cvflann::anyimpl::small_any_policy<int>::~small_any_policy<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$typed_base_any_policy@H@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$typed_base_any_policy@H@anyimpl@cvflann@@UEAA@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<int>::~typed_base_any_policy<int>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$typed_base_any_policy@H@anyimpl@cvflann@@UEAA@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<int>::~typed_base_any_policy<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$small_any_policy@M@anyimpl@cvflann@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$small_any_policy@M@anyimpl@cvflann@@UEAAPEAXI@Z PROC ; cvflann::anyimpl::small_any_policy<float>::`scalar deleting destructor', COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN4@scalar
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$small_any_policy@M@anyimpl@cvflann@@UEAAPEAXI@Z ENDP ; cvflann::anyimpl::small_any_policy<float>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$small_any_policy@M@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$small_any_policy@M@anyimpl@cvflann@@UEAA@XZ PROC	; cvflann::anyimpl::small_any_policy<float>::~small_any_policy<float>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$small_any_policy@M@anyimpl@cvflann@@UEAA@XZ ENDP	; cvflann::anyimpl::small_any_policy<float>::~small_any_policy<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$typed_base_any_policy@M@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$typed_base_any_policy@M@anyimpl@cvflann@@UEAA@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<float>::~typed_base_any_policy<float>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$typed_base_any_policy@M@anyimpl@cvflann@@UEAA@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<float>::~typed_base_any_policy<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEAXI@Z PROC ; cvflann::anyimpl::small_any_policy<bool>::`scalar deleting destructor', COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN4@scalar
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$small_any_policy@_N@anyimpl@cvflann@@UEAAPEAXI@Z ENDP ; cvflann::anyimpl::small_any_policy<bool>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$small_any_policy@_N@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$small_any_policy@_N@anyimpl@cvflann@@UEAA@XZ PROC	; cvflann::anyimpl::small_any_policy<bool>::~small_any_policy<bool>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$small_any_policy@_N@anyimpl@cvflann@@UEAA@XZ ENDP	; cvflann::anyimpl::small_any_policy<bool>::~small_any_policy<bool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$typed_base_any_policy@_N@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$typed_base_any_policy@_N@anyimpl@cvflann@@UEAA@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<bool>::~typed_base_any_policy<bool>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$typed_base_any_policy@_N@anyimpl@cvflann@@UEAA@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<bool>::~typed_base_any_policy<bool>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::`scalar deleting destructor', COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN4@scalar
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::~big_any_policy<enum cvflann::flann_algorithm_t>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$big_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_algorithm_t>::~big_any_policy<enum cvflann::flann_algorithm_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::~typed_base_any_policy<enum cvflann::flann_algorithm_t>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$typed_base_any_policy@W4flann_algorithm_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_algorithm_t>::~typed_base_any_policy<enum cvflann::flann_algorithm_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::`scalar deleting destructor', COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN4@scalar
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAAPEAXI@Z ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ PROC ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::~big_any_policy<enum cvflann::flann_centers_init_t>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$big_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ ENDP ; cvflann::anyimpl::big_any_policy<enum cvflann::flann_centers_init_t>::~big_any_policy<enum cvflann::flann_centers_init_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::~typed_base_any_policy<enum cvflann::flann_centers_init_t>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$typed_base_any_policy@W4flann_centers_init_t@cvflann@@@anyimpl@cvflann@@UEAA@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<enum cvflann::flann_centers_init_t>::~typed_base_any_policy<enum cvflann::flann_centers_init_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$small_any_policy@I@anyimpl@cvflann@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$small_any_policy@I@anyimpl@cvflann@@UEAAPEAXI@Z PROC ; cvflann::anyimpl::small_any_policy<unsigned int>::`scalar deleting destructor', COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN4@scalar
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$small_any_policy@I@anyimpl@cvflann@@UEAAPEAXI@Z ENDP ; cvflann::anyimpl::small_any_policy<unsigned int>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$small_any_policy@I@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$small_any_policy@I@anyimpl@cvflann@@UEAA@XZ PROC	; cvflann::anyimpl::small_any_policy<unsigned int>::~small_any_policy<unsigned int>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$small_any_policy@I@anyimpl@cvflann@@UEAA@XZ ENDP	; cvflann::anyimpl::small_any_policy<unsigned int>::~small_any_policy<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$typed_base_any_policy@I@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$typed_base_any_policy@I@anyimpl@cvflann@@UEAA@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::~typed_base_any_policy<unsigned int>, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$typed_base_any_policy@I@anyimpl@cvflann@@UEAA@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<unsigned int>::~typed_base_any_policy<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEAXI@Z PROC ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor', COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
	test	dl, 1
	je	SHORT $LN4@scalar
	mov	edx, 8
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAAPEAXI@Z ENDP ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAA@XZ PROC ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$big_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAA@XZ ENDP ; cvflann::anyimpl::big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~big_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAA@XZ PROC ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
	lea	rax, OFFSET FLAT:??_7base_any_policy@anyimpl@cvflann@@6B@
	mov	QWORD PTR [rcx], rax
	ret	0
??1?$typed_base_any_policy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@anyimpl@cvflann@@UEAA@XZ ENDP ; cvflann::anyimpl::typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~typed_base_any_policy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
END
