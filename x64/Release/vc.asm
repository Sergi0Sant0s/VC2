; Listing generated by Microsoft (R) Optimizing Compiler Version 19.25.28614.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_02NHCIPLKK@P4@				; `string'
PUBLIC	??_C@_02MODDMKOL@P5@				; `string'
PUBLIC	??_C@_02OFBOJJCI@P6@				; `string'
PUBLIC	??_C@_0FJ@EHALEAAF@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7File@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_0EF@JMCLEPHM@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7File@ ; `string'
PUBLIC	??_C@_0FB@GFAIKGOP@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5@ ; `string'
PUBLIC	??_C@_0CN@GALKGGNA@Imagem?3?5?$CFd?5x?5?$CFd?5?$HM?5Channels?3?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0BC@JGANLKK@Localiza?C?$KH?C?$KDo?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0FD@DBAHIHF@?6?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0DD@LDKNGAAH@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7Prem@ ; `string'
PUBLIC	??_C@_0EM@MPKKMDJL@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7File@ ; `string'
PUBLIC	??_C@_0CM@MBFBLIJM@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7File@ ; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_09GIKFGCFC@?$CFs?5?$CFd?5?$CFd?6@		; `string'
PUBLIC	??_C@_0N@FDHJOLCH@Total?5?$DN?5?$CFld?6@	; `string'
PUBLIC	??_C@_0EA@PGLIBIMI@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7Erro@ ; `string'
PUBLIC	??_C@_0O@NICCHDHF@?$CFs?5?$CFd?5?$CFd?5255?6@	; `string'
PUBLIC	??_C@_0FB@LPLGNJGA@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5@ ; `string'
PUBLIC	??_C@_0BD@MMOFMCKH@Localiza?C?$KH?C?$KDo?3?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0FC@BENCLKDM@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ ; `string'
PUBLIC	??_C@_0BD@BLLBHCMJ@0?5?3?5?$CFd?5?0?5255?5?3?5?$CFd?6@ ; `string'
PUBLIC	results
EXTRN	__imp_malloc:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp_isspace:PROC
EXTRN	__imp_ungetc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp_getc:PROC
EXTRN	__imp__strdup:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fopen:PROC
;	COMDAT ??_C@_0BD@BLLBHCMJ@0?5?3?5?$CFd?5?0?5255?5?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0BD@BLLBHCMJ@0?5?3?5?$CFd?5?0?5255?5?3?5?$CFd?6@ DB '0 : %d , 255 :'
	DB	' %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@BENCLKDM@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
CONST	SEGMENT
??_C@_0FC@BENCLKDM@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB '='
	DB	'============================================================='
	DB	'=================', 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MMOFMCKH@Localiza?C?$KH?C?$KDo?3?5?$CFs?6@
CONST	SEGMENT
??_C@_0BD@MMOFMCKH@Localiza?C?$KH?C?$KDo?3?5?$CFs?6@ DB 'Localiza', 0c3H, 0a7H
	DB	0c3H, 0a3H, 'o: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@LPLGNJGA@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5@
CONST	SEGMENT
??_C@_0FB@LPLGNJGA@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5@ DB '='
	DB	'============================= IMAGEM GERADA ================='
	DB	'=================', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NICCHDHF@?$CFs?5?$CFd?5?$CFd?5255?6@
CONST	SEGMENT
??_C@_0O@NICCHDHF@?$CFs?5?$CFd?5?$CFd?5255?6@ DB '%s %d %d 255', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@PGLIBIMI@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7Erro@
CONST	SEGMENT
??_C@_0EA@PGLIBIMI@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7Erro@ DB 'ER'
	DB	'ROR -> vc_read_image():', 0aH, 09H, 'Error writing PBM, PGM o'
	DB	'r PPM file.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FDHJOLCH@Total?5?$DN?5?$CFld?6@
CONST	SEGMENT
??_C@_0N@FDHJOLCH@Total?5?$DN?5?$CFld?6@ DB 'Total = %ld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GIKFGCFC@?$CFs?5?$CFd?5?$CFd?6@
CONST	SEGMENT
??_C@_09GIKFGCFC@?$CFs?5?$CFd?5?$CFd?6@ DB '%s %d %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MBFBLIJM@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7File@
CONST	SEGMENT
??_C@_0CM@MBFBLIJM@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7File@ DB 'ER'
	DB	'ROR -> vc_read_image():', 0aH, 09H, 'File not found.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@MPKKMDJL@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7File@
CONST	SEGMENT
??_C@_0EM@MPKKMDJL@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7File@ DB 'ER'
	DB	'ROR -> vc_read_image():', 0aH, 09H, 'File is not a valid PGM '
	DB	'or PPM file.', 0aH, 09H, 'Bad size!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@LDKNGAAH@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7Prem@
CONST	SEGMENT
??_C@_0DD@LDKNGAAH@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7Prem@ DB 'ER'
	DB	'ROR -> vc_read_image():', 0aH, 09H, 'Premature EOF on file.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@DBAHIHF@?6?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
CONST	SEGMENT
??_C@_0FD@DBAHIHF@?6?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@ DB 0aH
	DB	'============================================================='
	DB	'==================', 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JGANLKK@Localiza?C?$KH?C?$KDo?3?5?$CFs@
CONST	SEGMENT
??_C@_0BC@JGANLKK@Localiza?C?$KH?C?$KDo?3?5?$CFs@ DB 'Localiza', 0c3H, 0a7H
	DB	0c3H, 0a3H, 'o: %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GALKGGNA@Imagem?3?5?$CFd?5x?5?$CFd?5?$HM?5Channels?3?5?$CFd?5@
CONST	SEGMENT
??_C@_0CN@GALKGGNA@Imagem?3?5?$CFd?5x?5?$CFd?5?$HM?5Channels?3?5?$CFd?5@ DB 'I'
	DB	'magem: %d x %d | Channels: %d | Levels: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@GFAIKGOP@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5@
CONST	SEGMENT
??_C@_0FB@GFAIKGOP@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5@ DB '='
	DB	'============================= IMAGEM ABERTA ================='
	DB	'=================', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@JMCLEPHM@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7File@
CONST	SEGMENT
??_C@_0EF@JMCLEPHM@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7File@ DB 'ER'
	DB	'ROR -> vc_read_image():', 0aH, 09H, 'File is not a valid PBM '
	DB	'file.', 0aH, 09H, 'Bad size!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@EHALEAAF@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7File@
CONST	SEGMENT
??_C@_0FJ@EHALEAAF@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7File@ DB 'ER'
	DB	'ROR -> vc_read_image():', 0aH, 09H, 'File is not a valid PBM,'
	DB	' PGM or PPM file.', 0aH, 09H, 'Bad magic number!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02OFBOJJCI@P6@
CONST	SEGMENT
??_C@_02OFBOJJCI@P6@ DB 'P6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MODDMKOL@P5@
CONST	SEGMENT
??_C@_02MODDMKOL@P5@ DB 'P5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NHCIPLKK@P4@
CONST	SEGMENT
??_C@_02NHCIPLKK@P4@ DB 'P4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
	ORG $+7
results	DB	'results/', 00H
	ORG $+41
PUBLIC	vc_trab_prewitt
PUBLIC	vc_trab_clean
PUBLIC	vc_binary_edge_prewitt
PUBLIC	vc_binary_blob_info
PUBLIC	vc_rgb_gray_to_binary
PUBLIC	unsigned_char_to_bit
PUBLIC	vc_image_free
PUBLIC	fprintf
PUBLIC	__local_stdio_scanf_options
PUBLIC	vc_image_new
PUBLIC	vc_binary_dilate
PUBLIC	vc_trab_fase2
PUBLIC	vc_trab_detect
PUBLIC	vc_rgb_gray
PUBLIC	vc_gray_edge_prewitt
PUBLIC	vc_trab_fase3
PUBLIC	vc_write_image
PUBLIC	vc_convert_bgr_rgb
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_trab_prewitt DD imagerel $LN30
	DD	imagerel $LN30+54
	DD	imagerel $unwind$vc_trab_prewitt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$vc_trab_prewitt DD imagerel $LN30+54
	DD	imagerel $LN30+629
	DD	imagerel $chain$5$vc_trab_prewitt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$vc_trab_prewitt DD imagerel $LN30+629
	DD	imagerel $LN30+642
	DD	imagerel $chain$6$vc_trab_prewitt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_trab_clean DD imagerel $LN31
	DD	imagerel $LN31+102
	DD	imagerel $unwind$vc_trab_clean
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$vc_trab_clean DD imagerel $LN31+102
	DD	imagerel $LN31+228
	DD	imagerel $chain$1$vc_trab_clean
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$vc_trab_clean DD imagerel $LN31+228
	DD	imagerel $LN31+242
	DD	imagerel $chain$2$vc_trab_clean
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_binary_edge_prewitt DD imagerel $LN101
	DD	imagerel $LN101+2591
	DD	imagerel $unwind$vc_binary_edge_prewitt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_binary_blob_info DD imagerel $LN42
	DD	imagerel $LN42+29
	DD	imagerel $unwind$vc_binary_blob_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$vc_binary_blob_info DD imagerel $LN42+29
	DD	imagerel $LN42+111
	DD	imagerel $chain$1$vc_binary_blob_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$vc_binary_blob_info DD imagerel $LN42+111
	DD	imagerel $LN42+531
	DD	imagerel $chain$7$vc_binary_blob_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$vc_binary_blob_info DD imagerel $LN42+531
	DD	imagerel $LN42+551
	DD	imagerel $chain$8$vc_binary_blob_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$vc_binary_blob_info DD imagerel $LN42+551
	DD	imagerel $LN42+568
	DD	imagerel $chain$10$vc_binary_blob_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_rgb_gray_to_binary DD imagerel $LN22
	DD	imagerel $LN22+32
	DD	imagerel $unwind$vc_rgb_gray_to_binary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$vc_rgb_gray_to_binary DD imagerel $LN22+32
	DD	imagerel $LN22+196
	DD	imagerel $chain$1$vc_rgb_gray_to_binary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$vc_rgb_gray_to_binary DD imagerel $LN22+196
	DD	imagerel $LN22+203
	DD	imagerel $chain$2$vc_rgb_gray_to_binary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unsigned_char_to_bit DD imagerel $LN22
	DD	imagerel $LN22+31
	DD	imagerel $unwind$unsigned_char_to_bit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unsigned_char_to_bit DD imagerel $LN22+31
	DD	imagerel $LN22+149
	DD	imagerel $chain$1$unsigned_char_to_bit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unsigned_char_to_bit DD imagerel $LN22+149
	DD	imagerel $LN22+159
	DD	imagerel $chain$2$unsigned_char_to_bit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_image_free DD imagerel $LN7
	DD	imagerel $LN7+61
	DD	imagerel $unwind$vc_image_free
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN6
	DD	imagerel $LN6+69
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_image_new DD imagerel $LN12
	DD	imagerel $LN12+152
	DD	imagerel $unwind$vc_image_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_binary_dilate DD imagerel $LN46
	DD	imagerel $LN46+102
	DD	imagerel $unwind$vc_binary_dilate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$vc_binary_dilate DD imagerel $LN46+102
	DD	imagerel $LN46+407
	DD	imagerel $chain$2$vc_binary_dilate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$vc_binary_dilate DD imagerel $LN46+407
	DD	imagerel $LN46+421
	DD	imagerel $chain$3$vc_binary_dilate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_trab_fase2 DD imagerel $LN110
	DD	imagerel $LN110+984
	DD	imagerel $unwind$vc_trab_fase2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_trab_detect DD imagerel $LN56
	DD	imagerel $LN56+135
	DD	imagerel $unwind$vc_trab_detect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$vc_trab_detect DD imagerel $LN56+135
	DD	imagerel $LN56+272
	DD	imagerel $chain$0$vc_trab_detect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$vc_trab_detect DD imagerel $LN56+272
	DD	imagerel $LN56+367
	DD	imagerel $chain$1$vc_trab_detect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_rgb_gray DD imagerel $LN20
	DD	imagerel $LN20+50
	DD	imagerel $unwind$vc_rgb_gray
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$vc_rgb_gray DD imagerel $LN20+50
	DD	imagerel $LN20+230
	DD	imagerel $chain$0$vc_rgb_gray
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$vc_rgb_gray DD imagerel $LN20+230
	DD	imagerel $LN20+237
	DD	imagerel $chain$1$vc_rgb_gray
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_gray_edge_prewitt DD imagerel $LN91
	DD	imagerel $LN91+214
	DD	imagerel $unwind$vc_gray_edge_prewitt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$vc_gray_edge_prewitt DD imagerel $LN91+214
	DD	imagerel $LN91+1585
	DD	imagerel $chain$0$vc_gray_edge_prewitt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$vc_gray_edge_prewitt DD imagerel $LN91+1585
	DD	imagerel $LN91+1896
	DD	imagerel $chain$1$vc_gray_edge_prewitt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_trab_fase3 DD imagerel $LN235
	DD	imagerel $LN235+2338
	DD	imagerel $unwind$vc_trab_fase3
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_write_image DD imagerel $LN30
	DD	imagerel $LN30+155
	DD	imagerel $unwind$vc_write_image
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$vc_write_image DD imagerel $LN30+155
	DD	imagerel $LN30+204
	DD	imagerel $chain$2$vc_write_image
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$vc_write_image DD imagerel $LN30+204
	DD	imagerel $LN30+313
	DD	imagerel $chain$3$vc_write_image
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$vc_write_image DD imagerel $LN30+313
	DD	imagerel $LN30+370
	DD	imagerel $chain$4$vc_write_image
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$vc_write_image DD imagerel $LN30+370
	DD	imagerel $LN30+666
	DD	imagerel $chain$5$vc_write_image
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vc_convert_bgr_rgb DD imagerel $LN19
	DD	imagerel $LN19+104
	DD	imagerel $unwind$vc_convert_bgr_rgb
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_convert_bgr_rgb DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$vc_write_image DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+155
	DD	imagerel $unwind$vc_write_image
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$vc_write_image DD 021H
	DD	imagerel $LN30+155
	DD	imagerel $LN30+204
	DD	imagerel $chain$2$vc_write_image
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$vc_write_image DD 020521H
	DD	06c405H
	DD	imagerel $LN30+155
	DD	imagerel $LN30+204
	DD	imagerel $chain$2$vc_write_image
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$vc_write_image DD 060f21H
	DD	0f640fH
	DD	0e540aH
	DD	0d3405H
	DD	imagerel $LN30
	DD	imagerel $LN30+155
	DD	imagerel $unwind$vc_write_image
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_write_image DD 051001H
	DD	0f00c6210H
	DD	0d008e00aH
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_trab_fase3 DD 0137501H
	DD	0c47875H
	DD	0c5686dH
	DD	018cf465H
	DD	018de45dH
	DD	018e7455H
	DD	018f6445H
	DD	0194543aH
	DD	01900116H
	DD	0c00dd00fH
	DD	0300bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$vc_gray_edge_prewitt DD 021H
	DD	imagerel $LN91
	DD	imagerel $LN91+214
	DD	imagerel $unwind$vc_gray_edge_prewitt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$vc_gray_edge_prewitt DD 020821H
	DD	0a2c408H
	DD	imagerel $LN91
	DD	imagerel $LN91+214
	DD	imagerel $unwind$vc_gray_edge_prewitt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_gray_edge_prewitt DD 0b2c19H
	DD	04b681aH
	DD	0980112H
	DD	0e009f00bH
	DD	07005d007H
	DD	050036004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	04a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$vc_rgb_gray DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+50
	DD	imagerel $unwind$vc_rgb_gray
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$vc_rgb_gray DD 020421H
	DD	06804H
	DD	imagerel $LN20
	DD	imagerel $LN20+50
	DD	imagerel $unwind$vc_rgb_gray
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_rgb_gray DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$vc_trab_detect DD 021H
	DD	imagerel $LN56
	DD	imagerel $LN56+135
	DD	imagerel $unwind$vc_trab_detect
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$vc_trab_detect DD 020521H
	DD	0ad405H
	DD	imagerel $LN56
	DD	imagerel $LN56+135
	DD	imagerel $unwind$vc_trab_detect
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_trab_detect DD 0a1601H
	DD	0c5416H
	DD	0b3416H
	DD	0f0123216H
	DD	0c00ee010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_trab_fase2 DD 091f01H
	DD	0f01b621fH
	DD	0d017e019H
	DD	07013c015H
	DD	050116012H
	DD	03010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$vc_binary_dilate DD 021H
	DD	imagerel $LN46
	DD	imagerel $LN46+102
	DD	imagerel $unwind$vc_binary_dilate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$vc_binary_dilate DD 061421H
	DD	0e414H
	DD	01d40dH
	DD	093405H
	DD	imagerel $LN46
	DD	imagerel $LN46+102
	DD	imagerel $unwind$vc_binary_dilate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_binary_dilate DD 061001H
	DD	0f00c1210H
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_image_new DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 041601H
	DD	070125216H
	DD	030106011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_image_free DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unsigned_char_to_bit DD 021H
	DD	imagerel $LN22
	DD	imagerel $LN22+31
	DD	imagerel $unwind$unsigned_char_to_bit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unsigned_char_to_bit DD 040d21H
	DD	03540dH
	DD	023405H
	DD	imagerel $LN22
	DD	imagerel $LN22+31
	DD	imagerel $unwind$unsigned_char_to_bit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unsigned_char_to_bit DD 030601H
	DD	046406H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$vc_rgb_gray_to_binary DD 021H
	DD	imagerel $LN22
	DD	imagerel $LN22+32
	DD	imagerel $unwind$vc_rgb_gray_to_binary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$vc_rgb_gray_to_binary DD 040a21H
	DD	03640aH
	DD	023405H
	DD	imagerel $LN22
	DD	imagerel $LN22+32
	DD	imagerel $unwind$vc_rgb_gray_to_binary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_rgb_gray_to_binary DD 010201H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$vc_binary_blob_info DD 040021H
	DD	02f400H
	DD	05c400H
	DD	imagerel $LN42
	DD	imagerel $LN42+29
	DD	imagerel $unwind$vc_binary_blob_info
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$vc_binary_blob_info DD 021H
	DD	imagerel $LN42+29
	DD	imagerel $LN42+111
	DD	imagerel $chain$1$vc_binary_blob_info
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$vc_binary_blob_info DD 0c2721H
	DD	03e427H
	DD	04d422H
	DD	06741dH
	DD	076416H
	DD	08540eH
	DD	0b3405H
	DD	imagerel $LN42+29
	DD	imagerel $LN42+111
	DD	imagerel $chain$1$vc_binary_blob_info
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$vc_binary_blob_info DD 041221H
	DD	02f412H
	DD	05c405H
	DD	imagerel $LN42
	DD	imagerel $LN42+29
	DD	imagerel $unwind$vc_binary_blob_info
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_binary_blob_info DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_binary_edge_prewitt DD 0d3119H
	DD	057681fH
	DD	0ba3417H
	DD	0b00117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	0560H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$vc_trab_clean DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+102
	DD	imagerel $unwind$vc_trab_clean
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$vc_trab_clean DD 020521H
	DD	023405H
	DD	imagerel $LN31
	DD	imagerel $LN31+102
	DD	imagerel $unwind$vc_trab_clean
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_trab_clean DD 032b01H
	DD	0742bH
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$vc_trab_prewitt DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+54
	DD	imagerel $unwind$vc_trab_prewitt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$vc_trab_prewitt DD 0c2621H
	DD	0bf426H
	DD	0ce421H
	DD	0dc41cH
	DD	0e7417H
	DD	0f540fH
	DD	0103408H
	DD	imagerel $LN30
	DD	imagerel $LN30+54
	DD	imagerel $unwind$vc_trab_prewitt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vc_trab_prewitt DD 041401H
	DD	0110114H
	DD	0600bd00dH
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_convert_bgr_rgb
_TEXT	SEGMENT
original$ = 8
vc_convert_bgr_rgb PROC					; COMDAT

; 1817 : int vc_convert_bgr_rgb(IVC* original) {

$LN19:
	mov	QWORD PTR [rsp+8], rbx

; 1818 : 	int x, y, pos;
; 1819 : 	int temp;
; 1820 : 
; 1821 : 	for (x = 0; x < original->width; x++)

	xor	ebx, ebx
	cmp	DWORD PTR [rcx+8], ebx
	jle	SHORT $LN3@vc_convert
	mov	eax, DWORD PTR [rcx+12]
	npad	1
$LL4@vc_convert:

; 1822 : 	{
; 1823 : 		for (y = 0; y < original->height; y++)

	xor	r11d, r11d
	test	eax, eax
	jle	SHORT $LN2@vc_convert
	npad	9
$LL7@vc_convert:

; 1824 : 		{
; 1825 : 			pos = y * original->bytesperline + x * original->channels;

	mov	edx, r11d
	mov	eax, ebx
	imul	eax, DWORD PTR [rcx+16]
	inc	r11d
	imul	edx, DWORD PTR [rcx+24]
	add	eax, edx

; 1826 : 			temp = original->data[pos];

	mov	rdx, QWORD PTR [rcx]
	cdqe
	movzx	r10d, BYTE PTR [rax+rdx]

; 1827 : 			original->data[pos] = original->data[pos + 2];

	lea	r9, QWORD PTR [rax+2]
	lea	r8, QWORD PTR [rax+rdx]
	movzx	eax, BYTE PTR [r9+rdx]
	mov	BYTE PTR [r8], al

; 1828 : 			original->data[pos + 2] = (unsigned char)temp;

	mov	rax, QWORD PTR [rcx]
	mov	BYTE PTR [r9+rax], r10b
	mov	eax, DWORD PTR [rcx+12]
	cmp	r11d, eax
	jl	SHORT $LL7@vc_convert
$LN2@vc_convert:

; 1818 : 	int x, y, pos;
; 1819 : 	int temp;
; 1820 : 
; 1821 : 	for (x = 0; x < original->width; x++)

	inc	ebx
	cmp	ebx, DWORD PTR [rcx+8]
	jl	SHORT $LL4@vc_convert
$LN3@vc_convert:

; 1829 : 		}
; 1830 : 	}
; 1831 : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
vc_convert_bgr_rgb ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_write_image
_TEXT	SEGMENT
filename$ = 96
image$ = 104
vc_write_image PROC					; COMDAT

; 336  : {

$LN30:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 56					; 00000038H
	mov	r14, rdx
	mov	rdi, rcx

; 337  : 	FILE *file = NULL;
; 338  : 	unsigned char *tmp;
; 339  : 	long int totalbytes, sizeofbinarydata;
; 340  : 
; 341  : 	if (image == NULL)

	test	rdx, rdx
	je	$LN3@vc_write_i

; 342  : 		return 0;
; 343  : 
; 344  : 	if ((file = fopen(filename, "wb")) != NULL)

	lea	rdx, OFFSET FLAT:??_C@_02GMLFBBN@wb@
	call	QWORD PTR __imp_fopen
	mov	r15, rax
	test	rax, rax
	je	$LN3@vc_write_i

; 345  : 	{
; 346  : 		if (image->levels == 1)

	cmp	DWORD PTR [r14+20], 1
	jne	$LN4@vc_write_i

; 347  : 		{
; 348  : 			sizeofbinarydata = (image->width / 8 + ((image->width % 8) ? 1 : 0)) * image->height + 1;

	mov	eax, DWORD PTR [r14+8]
	xor	ecx, ecx
	cdq
	and	edx, 7
	add	eax, edx
	mov	r8d, eax
	and	eax, 7
	sar	r8d, 3
	cmp	eax, edx
	setne	cl
	add	ecx, r8d
	imul	ecx, DWORD PTR [r14+12]

; 349  : 			tmp = (unsigned char *)malloc(sizeofbinarydata);

	movsxd	rcx, ecx
	inc	rcx
	call	QWORD PTR __imp_malloc
	mov	r13, rax

; 350  : 			if (tmp == NULL)

	test	rax, rax
	je	$LN3@vc_write_i

; 351  : 				return 0;
; 352  : 
; 353  : 			fprintf(file, "%s %d %d\n", "P4", image->width, image->height);

	mov	ecx, DWORD PTR [r14+12]
	lea	r8, OFFSET FLAT:??_C@_02NHCIPLKK@P4@
	mov	r9d, DWORD PTR [r14+8]
	lea	rdx, OFFSET FLAT:??_C@_09GIKFGCFC@?$CFs?5?$CFd?5?$CFd?6@
	mov	DWORD PTR [rsp+32], ecx
	mov	rcx, r15
	mov	QWORD PTR [rsp+104], rbx
	mov	QWORD PTR [rsp+112], rbp
	mov	QWORD PTR [rsp+120], rsi
	call	fprintf

; 354  : 
; 355  : 			totalbytes = unsigned_char_to_bit(image->data, tmp, image->width, image->height);

	mov	ecx, DWORD PTR [r14+12]

; 128  : 	counttotalbytes = 0;

	xor	ebx, ebx

; 354  : 
; 355  : 			totalbytes = unsigned_char_to_bit(image->data, tmp, image->width, image->height);

	movsxd	rbp, DWORD PTR [r14+8]

; 124  : 	unsigned char *p = databit;

	mov	r10, r13

; 354  : 
; 355  : 			totalbytes = unsigned_char_to_bit(image->data, tmp, image->width, image->height);

	mov	rsi, QWORD PTR [r14]

; 126  : 	*p = 0;

	mov	BYTE PTR [r13], 0

; 127  : 	countbits = 1;

	lea	r8d, QWORD PTR [rbx+1]

; 129  : 
; 130  : 	for (y = 0; y < height; y++)

	test	ecx, ecx
	jle	SHORT $LN12@vc_write_i

; 351  : 				return 0;
; 352  : 
; 353  : 			fprintf(file, "%s %d %d\n", "P4", image->width, image->height);

	mov	QWORD PTR [rsp+48], r12
	mov	r12d, ecx
$LL13@vc_write_i:

; 132  : 		for (x = 0; x < width; x++)

	xor	r11d, r11d
	test	ebp, ebp
	jle	SHORT $LN11@vc_write_i

; 133  : 		{
; 134  : 			pos = width * y + x;

	xor	r9d, r9d
	npad	2
$LL16@vc_write_i:

; 135  : 
; 136  : 			if (countbits <= 8)

	cmp	r8d, 8
	jg	SHORT $LN19@vc_write_i

; 137  : 			{
; 138  : 				// Numa imagem PBM:
; 139  : 				// 1 = Preto
; 140  : 				// 0 = Branco
; 141  : 				//*p |= (datauchar[pos] != 0) << (8 - countbits);
; 142  : 
; 143  : 				// Na nossa imagem:
; 144  : 				// 1 = Branco
; 145  : 				// 0 = Preto
; 146  : 				*p |= (datauchar[pos] == 0) << (8 - countbits);

	cmp	BYTE PTR [rsi+r9], 0
	mov	ecx, 8
	sete	dl
	sub	ecx, r8d
	shl	dl, cl

; 147  : 
; 148  : 				countbits++;

	inc	r8d
	or	BYTE PTR [r10], dl

; 149  : 			}
; 150  : 			if ((countbits > 8) || (x == width - 1))

	cmp	r8d, 8
	jg	SHORT $LN19@vc_write_i
	lea	eax, DWORD PTR [rbp-1]
	cmp	r11d, eax
	jne	SHORT $LN14@vc_write_i
$LN19@vc_write_i:

; 151  : 			{
; 152  : 				p++;

	inc	r10

; 153  : 				*p = 0;
; 154  : 				countbits = 1;

	mov	r8d, 1

; 155  : 				counttotalbytes++;

	inc	ebx
	mov	BYTE PTR [r10], 0
$LN14@vc_write_i:

; 131  : 	{
; 132  : 		for (x = 0; x < width; x++)

	inc	r11d
	inc	r9
	cmp	r9, rbp
	jl	SHORT $LL16@vc_write_i
$LN11@vc_write_i:

; 129  : 
; 130  : 	for (y = 0; y < height; y++)

	add	rsi, rbp
	sub	r12, 1
	jne	SHORT $LL13@vc_write_i
	mov	rdi, QWORD PTR filename$[rsp]
	mov	r12, QWORD PTR [rsp+48]
$LN12@vc_write_i:

; 356  : 			printf("Total = %ld\n", totalbytes);

	mov	edx, ebx
	lea	rcx, OFFSET FLAT:??_C@_0N@FDHJOLCH@Total?5?$DN?5?$CFld?6@
	call	printf

; 357  : 			if (fwrite(tmp, sizeof(unsigned char), totalbytes, file) != totalbytes)

	movsxd	rbx, ebx
	mov	r9, r15
	mov	r8, rbx
	mov	edx, 1
	mov	rcx, r13
	call	QWORD PTR __imp_fwrite
	mov	rsi, QWORD PTR [rsp+120]
	cmp	rax, rbx
	mov	rbx, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+112]
	je	SHORT $LN7@vc_write_i

; 358  : 			{
; 359  : #ifdef VC_DEBUG
; 360  : 				fprintf(stderr, "ERROR -> vc_read_image():\n\tError writing PBM, PGM or PPM file.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_0EA@PGLIBIMI@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7Erro@
	call	fprintf

; 361  : #endif
; 362  : 
; 363  : 				fclose(file);

	mov	rcx, r15
	call	QWORD PTR __imp_fclose

; 364  : 				free(tmp);

	mov	rcx, r13
	call	QWORD PTR __imp_free
$LN3@vc_write_i:

; 391  : 	}
; 392  : 
; 393  : 	return 0;
; 394  : }

	xor	eax, eax
	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	ret	0
$LN7@vc_write_i:

; 365  : 				return 0;
; 366  : 			}
; 367  : 
; 368  : 			free(tmp);

	mov	rcx, r13
	call	QWORD PTR __imp_free
$LN8@vc_write_i:

; 381  : 				return 0;
; 382  : 			}
; 383  : 		}
; 384  : 		printf("============================== IMAGEM GERADA ==================================\n");

	lea	rcx, OFFSET FLAT:??_C@_0FB@LPLGNJGA@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?5@
	call	printf

; 385  : 		printf("Imagem: %d x %d | Channels: %d | Levels: %d\n", image->width, image->height, image->channels, image->levels);

	mov	ecx, DWORD PTR [r14+20]
	mov	r9d, DWORD PTR [r14+16]
	mov	r8d, DWORD PTR [r14+12]
	mov	edx, DWORD PTR [r14+8]
	mov	DWORD PTR [rsp+32], ecx
	lea	rcx, OFFSET FLAT:??_C@_0CN@GALKGGNA@Imagem?3?5?$CFd?5x?5?$CFd?5?$HM?5Channels?3?5?$CFd?5@
	call	printf

; 386  : 		printf("Localização: %s\n", filename);

	mov	rdx, rdi
	lea	rcx, OFFSET FLAT:??_C@_0BD@MMOFMCKH@Localiza?C?$KH?C?$KDo?3?5?$CFs?6@
	call	printf

; 387  : 		printf("===============================================================================\n\n");

	lea	rcx, OFFSET FLAT:??_C@_0FC@BENCLKDM@?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN?$DN@
	call	printf

; 388  : 		fclose(file);

	mov	rcx, r15
	call	QWORD PTR __imp_fclose

; 389  : 
; 390  : 		return 1;

	mov	eax, 1

; 391  : 	}
; 392  : 
; 393  : 	return 0;
; 394  : }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	ret	0
$LN4@vc_write_i:

; 369  : 		}
; 370  : 		else
; 371  : 		{
; 372  : 			fprintf(file, "%s %d %d 255\n", (image->channels == 1) ? "P5" : "P6", image->width, image->height);

	cmp	DWORD PTR [r14+16], 1
	lea	rax, OFFSET FLAT:??_C@_02MODDMKOL@P5@
	mov	r9d, DWORD PTR [r14+8]
	lea	r8, OFFSET FLAT:??_C@_02OFBOJJCI@P6@
	cmove	r8, rax
	lea	rdx, OFFSET FLAT:??_C@_0O@NICCHDHF@?$CFs?5?$CFd?5?$CFd?5255?6@
	mov	eax, DWORD PTR [r14+12]
	mov	rcx, r15
	mov	DWORD PTR [rsp+32], eax
	call	fprintf

; 373  : 
; 374  : 			if (fwrite(image->data, image->bytesperline, image->height, file) != image->height)

	movsxd	r8, DWORD PTR [r14+12]
	mov	r9, r15
	movsxd	rdx, DWORD PTR [r14+24]
	mov	rcx, QWORD PTR [r14]
	call	QWORD PTR __imp_fwrite
	movsxd	rcx, DWORD PTR [r14+12]
	cmp	rax, rcx
	je	$LN8@vc_write_i

; 375  : 			{
; 376  : #ifdef VC_DEBUG
; 377  : 				fprintf(stderr, "ERROR -> vc_read_image():\n\tError writing PBM, PGM or PPM file.\n");

	mov	ecx, 2
	call	QWORD PTR __imp___acrt_iob_func
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_0EA@PGLIBIMI@ERROR?5?9?$DO?5vc_read_image?$CI?$CJ?3?6?7Erro@
	call	fprintf

; 378  : #endif
; 379  : 
; 380  : 				fclose(file);

	mov	rcx, r15
	call	QWORD PTR __imp_fclose

; 391  : 	}
; 392  : 
; 393  : 	return 0;
; 394  : }

	xor	eax, eax
	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	ret	0
vc_write_image ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_trab_fase3
_TEXT	SEGMENT
tv4511 = 32
nLabels$ = 32
blobs$1$ = 40
tv4705 = 48
median$ = 64
original$ = 3232
result$ = 3240
license$ = 3248
blob$ = 3256
vc_trab_fase3 PROC					; COMDAT

; 1483 : {

$LN235:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	r12
	push	r13
	sub	rsp, 3200				; 00000c80H
	mov	r12, r8
	mov	r13, rcx

; 1484 : 	if (blob == NULL)

	test	r9, r9
	jne	SHORT $LN29@vc_trab_fa

; 1485 : 		return -1;

	lea	eax, QWORD PTR [r9-1]

; 1707 : }

	add	rsp, 3200				; 00000c80H
	pop	r13
	pop	r12
	pop	rbx
	ret	0
$LN29@vc_trab_fa:
	mov	QWORD PTR [rsp+3232], rbp

; 1489 : 	int x, y, pos, sum = 0, min, max, i = 0, j = 0;
; 1490 : 	//
; 1491 : 	OVC *blobs;
; 1492 : 	IVC *prewitt, *binary, *bImg;
; 1493 : 
; 1494 : 	//Inicialize
; 1495 : 	prewitt = vc_image_new(original->width, original->height, 1, 255);

	mov	ebp, DWORD PTR [rcx+12]
	mov	QWORD PTR [rsp+3192], rsi
	mov	esi, DWORD PTR [rcx+8]

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H
	mov	QWORD PTR [rsp+3184], rdi
	mov	QWORD PTR [rsp+3176], r14
	mov	QWORD PTR [rsp+3168], r15
	movaps	XMMWORD PTR [rsp+3152], xmm6
	movaps	XMMWORD PTR [rsp+3136], xmm7

; 1486 : 
; 1487 : 	//VARS
; 1488 : 	int nLabels = 0;

	mov	DWORD PTR nLabels$[rsp], 0

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	call	QWORD PTR __imp_malloc
	mov	rdi, rax

; 39   : 
; 40   : 	if (image == NULL)

	mov	r15d, 255				; 000000ffH
	test	rax, rax
	je	SHORT $LN228@vc_trab_fa

; 41   : 		return NULL;
; 42   : 	if ((levels <= 0) || (levels > 255))
; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rax+8], esi

; 47   : 	image->channels = channels;
; 48   : 	image->levels = levels;
; 49   : 	image->bytesperline = image->width * image->channels;

	mov	DWORD PTR [rax+24], esi

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	esi, ebp
	mov	DWORD PTR [rax+12], ebp
	mov	DWORD PTR [rax+16], 1
	mov	DWORD PTR [rax+20], r15d
	movsxd	rcx, esi
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rdi], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN67@vc_trab_fa

; 71   : 		free(image);

	mov	rcx, rdi
	call	QWORD PTR __imp_free
$LN228@vc_trab_fa:

; 1496 : 	binary = vc_image_new(original->width, original->height, 1, 255);

	xor	edi, edi
$LN67@vc_trab_fa:
	mov	r14d, DWORD PTR [r13+12]

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H

; 1496 : 	binary = vc_image_new(original->width, original->height, 1, 255);

	mov	ebp, DWORD PTR [r13+8]

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	call	QWORD PTR __imp_malloc
	mov	rsi, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	je	SHORT $LN229@vc_trab_fa

; 41   : 		return NULL;
; 42   : 	if ((levels <= 0) || (levels > 255))
; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rax+8], ebp

; 47   : 	image->channels = channels;
; 48   : 	image->levels = levels;
; 49   : 	image->bytesperline = image->width * image->channels;

	mov	DWORD PTR [rax+24], ebp

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	ebp, r14d
	mov	DWORD PTR [rax+12], r14d
	mov	DWORD PTR [rax+16], 1
	mov	DWORD PTR [rax+20], r15d
	movsxd	rcx, ebp
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rsi], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN77@vc_trab_fa

; 71   : 		free(image);

	mov	rcx, rsi
	call	QWORD PTR __imp_free
$LN229@vc_trab_fa:

; 1497 : 	bImg = vc_image_new(original->width, original->height, 1, 255);

	xor	esi, esi
$LN77@vc_trab_fa:
	mov	ebp, DWORD PTR [r13+12]

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H

; 1497 : 	bImg = vc_image_new(original->width, original->height, 1, 255);

	mov	r14d, DWORD PTR [r13+8]

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	call	QWORD PTR __imp_malloc
	mov	r15, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	je	SHORT $LN230@vc_trab_fa

; 46   : 	image->height = height;

	mov	DWORD PTR [rax+12], ebp

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	ebp, r14d
	mov	DWORD PTR [rax+8], r14d
	mov	DWORD PTR [rax+16], 1
	mov	DWORD PTR [rax+20], 255			; 000000ffH
	mov	DWORD PTR [rax+24], r14d
	movsxd	rcx, ebp
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r15], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN87@vc_trab_fa

; 71   : 		free(image);

	mov	rcx, r15
	call	QWORD PTR __imp_free
$LN230@vc_trab_fa:

; 1498 : 
; 1499 : 	//Edge
; 1500 : 	vc_trab_prewitt(license, prewitt);

	xor	r15d, r15d
$LN87@vc_trab_fa:
	mov	rdx, rdi
	mov	rcx, r12
	call	vc_trab_prewitt

; 598  : 	for (x = 0; x < original->width; x++)

	xor	r11d, r11d
	cmp	DWORD PTR [rdi+8], r11d
	jle	$LN95@vc_trab_fa
	mov	eax, DWORD PTR [rdi+12]
	mov	ebx, 255				; 000000ffH
	movss	xmm1, DWORD PTR __real@430c0000
$LL96@vc_trab_fa:

; 599  : 	{
; 600  : 		for (y = 0; y < original->height; y++)

	xor	r9d, r9d
	test	eax, eax
	jle	SHORT $LN94@vc_trab_fa
	npad	8
$LL99@vc_trab_fa:

; 601  : 		{
; 602  : 			pos = y * original->bytesperline + x * original->channels;

	mov	r10d, DWORD PTR [rdi+16]

; 603  : 			posAux = y * converted->bytesperline + x * converted->channels;

	mov	r8d, r9d
	imul	r8d, DWORD PTR [rsi+24]
	mov	eax, r11d
	imul	eax, DWORD PTR [rsi+16]
	mov	ecx, DWORD PTR [rdi+24]
	imul	ecx, r9d
	add	r8d, eax
	mov	eax, r11d
	imul	eax, r10d
	add	ecx, eax

; 604  : 			meanAux = (original->channels == 1 ? original->data[pos] : (original->data[pos] + original->data[pos + 1] + original->data[pos + 2])) / original->channels;

	movsxd	rdx, ecx
	add	rdx, QWORD PTR [rdi]
	cmp	r10d, 1
	jne	SHORT $LN101@vc_trab_fa
	movzx	ecx, BYTE PTR [rdx]
	jmp	SHORT $LN102@vc_trab_fa
$LN101@vc_trab_fa:
	movzx	eax, BYTE PTR [rdx+1]
	movzx	ecx, BYTE PTR [rdx+2]
	add	ecx, eax
	movzx	eax, BYTE PTR [rdx]
	add	ecx, eax
$LN102@vc_trab_fa:
	mov	eax, ecx

; 605  : 			converted->data[posAux] = meanAux > threshold ? 255 : 0;

	movsxd	rcx, r8d
	cdq
	idiv	r10d
	xor	edx, edx
	movd	xmm0, eax
	mov	rax, QWORD PTR [rsi]
	cvtdq2ps xmm0, xmm0
	comiss	xmm0, xmm1
	cmova	edx, ebx
	inc	r9d
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR [rdi+12]
	cmp	r9d, eax
	jl	SHORT $LL99@vc_trab_fa
$LN94@vc_trab_fa:

; 72   : 		image = NULL;
; 73   : 	}
; 74   : 
; 75   : 	return image;
; 76   : }
; 77   : 
; 78   : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; 79   : //    FUN��ES: LEITURA E ESCRITA DE IMAGENS (PBM, PGM E PPM)
; 80   : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; 81   : 
; 82   : char *netpbm_get_token(FILE *file, char *tok, int len)
; 83   : {
; 84   : 	char *t;
; 85   : 	int c;
; 86   : 
; 87   : 	for (;;)
; 88   : 	{
; 89   : 		while (isspace(c = getc(file)))
; 90   : 			;
; 91   : 		if (c != '#')
; 92   : 			break;
; 93   : 		do
; 94   : 			c = getc(file);
; 95   : 		while ((c != '\n') && (c != EOF));
; 96   : 		if (c == EOF)
; 97   : 			break;
; 98   : 	}
; 99   : 
; 100  : 	t = tok;
; 101  : 
; 102  : 	if (c != EOF)
; 103  : 	{
; 104  : 		do
; 105  : 		{
; 106  : 			*t++ = c;
; 107  : 			c = getc(file);
; 108  : 		} while ((!isspace(c)) && (c != '#') && (c != EOF) && (t - tok < len - 1));
; 109  : 
; 110  : 		if (c == '#')
; 111  : 			ungetc(c, file);
; 112  : 	}
; 113  : 
; 114  : 	*t = 0;
; 115  : 
; 116  : 	return tok;
; 117  : }
; 118  : 
; 119  : long int unsigned_char_to_bit(unsigned char *datauchar, unsigned char *databit, int width, int height)
; 120  : {
; 121  : 	int x, y;
; 122  : 	int countbits;
; 123  : 	long int pos, counttotalbytes;
; 124  : 	unsigned char *p = databit;
; 125  : 
; 126  : 	*p = 0;
; 127  : 	countbits = 1;
; 128  : 	counttotalbytes = 0;
; 129  : 
; 130  : 	for (y = 0; y < height; y++)
; 131  : 	{
; 132  : 		for (x = 0; x < width; x++)
; 133  : 		{
; 134  : 			pos = width * y + x;
; 135  : 
; 136  : 			if (countbits <= 8)
; 137  : 			{
; 138  : 				// Numa imagem PBM:
; 139  : 				// 1 = Preto
; 140  : 				// 0 = Branco
; 141  : 				//*p |= (datauchar[pos] != 0) << (8 - countbits);
; 142  : 
; 143  : 				// Na nossa imagem:
; 144  : 				// 1 = Branco
; 145  : 				// 0 = Preto
; 146  : 				*p |= (datauchar[pos] == 0) << (8 - countbits);
; 147  : 
; 148  : 				countbits++;
; 149  : 			}
; 150  : 			if ((countbits > 8) || (x == width - 1))
; 151  : 			{
; 152  : 				p++;
; 153  : 				*p = 0;
; 154  : 				countbits = 1;
; 155  : 				counttotalbytes++;
; 156  : 			}
; 157  : 		}
; 158  : 	}
; 159  : 
; 160  : 	return counttotalbytes;
; 161  : }
; 162  : 
; 163  : void bit_to_unsigned_char(unsigned char *databit, unsigned char *datauchar, int width, int height)
; 164  : {
; 165  : 	int x, y;
; 166  : 	int countbits;
; 167  : 	long int pos;
; 168  : 	unsigned char *p = databit;
; 169  : 
; 170  : 	countbits = 1;
; 171  : 
; 172  : 	for (y = 0; y < height; y++)
; 173  : 	{
; 174  : 		for (x = 0; x < width; x++)
; 175  : 		{
; 176  : 			pos = width * y + x;
; 177  : 
; 178  : 			if (countbits <= 8)
; 179  : 			{
; 180  : 				// Numa imagem PBM:
; 181  : 				// 1 = Preto
; 182  : 				// 0 = Branco
; 183  : 				//datauchar[pos] = (*p & (1 << (8 - countbits))) ? 1 : 0;
; 184  : 
; 185  : 				// Na nossa imagem:
; 186  : 				// 1 = Branco
; 187  : 				// 0 = Preto
; 188  : 				datauchar[pos] = (*p & (1 << (8 - countbits))) ? 0 : 1;
; 189  : 
; 190  : 				countbits++;
; 191  : 			}
; 192  : 			if ((countbits > 8) || (x == width - 1))
; 193  : 			{
; 194  : 				p++;
; 195  : 				countbits = 1;
; 196  : 			}
; 197  : 		}
; 198  : 	}
; 199  : }
; 200  : 
; 201  : IVC *vc_read_image(char *filename)
; 202  : {
; 203  : 	FILE *file = NULL;
; 204  : 	IVC *image = NULL;
; 205  : 	unsigned char *tmp;
; 206  : 	char tok[20];
; 207  : 	long int size, sizeofbinarydata;
; 208  : 	int width, height, channels;
; 209  : 	int levels = 255;
; 210  : 	int v;
; 211  : 
; 212  : 	// Abre o ficheiro
; 213  : 	if ((file = fopen(filename, "rb")) != NULL)
; 214  : 	{
; 215  : 		// Efectua a leitura do header
; 216  : 		netpbm_get_token(file, tok, sizeof(tok));
; 217  : 
; 218  : 		if (strcmp(tok, "P4") == 0)
; 219  : 		{
; 220  : 			channels = 1;
; 221  : 			levels = 1;
; 222  : 		} // Se PBM (Binary [0,1])
; 223  : 		else if (strcmp(tok, "P5") == 0)
; 224  : 			channels = 1; // Se PGM (Gray [0,MAX(level,255)])
; 225  : 		else if (strcmp(tok, "P6") == 0)
; 226  : 			channels = 3; // Se PPM (RGB [0,MAX(level,255)])
; 227  : 		else
; 228  : 		{
; 229  : #ifdef VC_DEBUG
; 230  : 			printf("ERROR -> vc_read_image():\n\tFile is not a valid PBM, PGM or PPM file.\n\tBad magic number!\n");
; 231  : #endif
; 232  : 
; 233  : 			fclose(file);
; 234  : 			return NULL;
; 235  : 		}
; 236  : 
; 237  : 		if (levels == 1) // PBM
; 238  : 		{
; 239  : 			if (sscanf(netpbm_get_token(file, tok, sizeof(tok)), "%d", &width) != 1 ||
; 240  : 				sscanf(netpbm_get_token(file, tok, sizeof(tok)), "%d", &height) != 1)
; 241  : 			{
; 242  : #ifdef VC_DEBUG
; 243  : 				printf("ERROR -> vc_read_image():\n\tFile is not a valid PBM file.\n\tBad size!\n");
; 244  : #endif
; 245  : 
; 246  : 				fclose(file);
; 247  : 				return NULL;
; 248  : 			}
; 249  : 
; 250  : 			// Aloca mem�ria para imagem
; 251  : 			image = vc_image_new(width, height, channels, levels);
; 252  : 			if (image == NULL)
; 253  : 				return NULL;
; 254  : 
; 255  : 			sizeofbinarydata = (image->width / 8 + ((image->width % 8) ? 1 : 0)) * image->height;
; 256  : 			tmp = (unsigned char *)malloc(sizeofbinarydata);
; 257  : 			if (tmp == NULL)
; 258  : 				return 0;
; 259  : 
; 260  : #ifdef VC_DEBUG
; 261  : 			printf("============================== IMAGEM ABERTA ==================================\n");
; 262  : 			printf("Imagem: %d x %d | Channels: %d | Levels: %d\n", image->width, image->height, image->channels, image->levels);
; 263  : 			printf("Localização: %s", filename);
; 264  : 			printf("\n===============================================================================\n\n");
; 265  : #endif
; 266  : 
; 267  : 			if ((v = fread(tmp, sizeof(unsigned char), sizeofbinarydata, file)) != sizeofbinarydata)
; 268  : 			{
; 269  : #ifdef VC_DEBUG
; 270  : 				printf("ERROR -> vc_read_image():\n\tPremature EOF on file.\n");
; 271  : #endif
; 272  : 
; 273  : 				vc_image_free(image);
; 274  : 				fclose(file);
; 275  : 				free(tmp);
; 276  : 				return NULL;
; 277  : 			}
; 278  : 
; 279  : 			bit_to_unsigned_char(tmp, image->data, image->width, image->height);
; 280  : 
; 281  : 			free(tmp);
; 282  : 		}
; 283  : 		else // PGM ou PPM
; 284  : 		{
; 285  : 			if (sscanf(netpbm_get_token(file, tok, sizeof(tok)), "%d", &width) != 1 ||
; 286  : 				sscanf(netpbm_get_token(file, tok, sizeof(tok)), "%d", &height) != 1 ||
; 287  : 				sscanf(netpbm_get_token(file, tok, sizeof(tok)), "%d", &levels) != 1 || levels <= 0 || levels > 255)
; 288  : 			{
; 289  : #ifdef VC_DEBUG
; 290  : 				printf("ERROR -> vc_read_image():\n\tFile is not a valid PGM or PPM file.\n\tBad size!\n");
; 291  : #endif
; 292  : 
; 293  : 				fclose(file);
; 294  : 				return NULL;
; 295  : 			}
; 296  : 
; 297  : 			// Aloca mem�ria para imagem
; 298  : 			image = vc_image_new(width, height, channels, levels);
; 299  : 			if (image == NULL)
; 300  : 				return NULL;
; 301  : 
; 302  : #ifdef VC_DEBUG
; 303  : 			printf("============================== IMAGEM ABERTA ==================================\n");
; 304  : 			printf("Imagem: %d x %d | Channels: %d | Levels: %d\n", image->width, image->height, image->channels, image->levels);
; 305  : 			printf("Localização: %s", filename);
; 306  : 			printf("\n===============================================================================\n\n");
; 307  : #endif
; 308  : 
; 309  : 			size = image->width * image->height * image->channels;
; 310  : 
; 311  : 			if ((v = fread(image->data, sizeof(unsigned char), size, file)) != size)
; 312  : 			{
; 313  : #ifdef VC_DEBUG
; 314  : 				printf("ERROR -> vc_read_image():\n\tPremature EOF on file.\n");
; 315  : #endif
; 316  : 
; 317  : 				vc_image_free(image);
; 318  : 				fclose(file);
; 319  : 				return NULL;
; 320  : 			}
; 321  : 		}
; 322  : 
; 323  : 		fclose(file);
; 324  : 	}
; 325  : 	else
; 326  : 	{
; 327  : #ifdef VC_DEBUG
; 328  : 		printf("ERROR -> vc_read_image():\n\tFile not found.\n");
; 329  : #endif
; 330  : 	}
; 331  : 
; 332  : 	return image;
; 333  : }
; 334  : 
; 335  : int vc_write_image(char *filename, IVC *image)
; 336  : {
; 337  : 	FILE *file = NULL;
; 338  : 	unsigned char *tmp;
; 339  : 	long int totalbytes, sizeofbinarydata;
; 340  : 
; 341  : 	if (image == NULL)
; 342  : 		return 0;
; 343  : 
; 344  : 	if ((file = fopen(filename, "wb")) != NULL)
; 345  : 	{
; 346  : 		if (image->levels == 1)
; 347  : 		{
; 348  : 			sizeofbinarydata = (image->width / 8 + ((image->width % 8) ? 1 : 0)) * image->height + 1;
; 349  : 			tmp = (unsigned char *)malloc(sizeofbinarydata);
; 350  : 			if (tmp == NULL)
; 351  : 				return 0;
; 352  : 
; 353  : 			fprintf(file, "%s %d %d\n", "P4", image->width, image->height);
; 354  : 
; 355  : 			totalbytes = unsigned_char_to_bit(image->data, tmp, image->width, image->height);
; 356  : 			printf("Total = %ld\n", totalbytes);
; 357  : 			if (fwrite(tmp, sizeof(unsigned char), totalbytes, file) != totalbytes)
; 358  : 			{
; 359  : #ifdef VC_DEBUG
; 360  : 				fprintf(stderr, "ERROR -> vc_read_image():\n\tError writing PBM, PGM or PPM file.\n");
; 361  : #endif
; 362  : 
; 363  : 				fclose(file);
; 364  : 				free(tmp);
; 365  : 				return 0;
; 366  : 			}
; 367  : 
; 368  : 			free(tmp);
; 369  : 		}
; 370  : 		else
; 371  : 		{
; 372  : 			fprintf(file, "%s %d %d 255\n", (image->channels == 1) ? "P5" : "P6", image->width, image->height);
; 373  : 
; 374  : 			if (fwrite(image->data, image->bytesperline, image->height, file) != image->height)
; 375  : 			{
; 376  : #ifdef VC_DEBUG
; 377  : 				fprintf(stderr, "ERROR -> vc_read_image():\n\tError writing PBM, PGM or PPM file.\n");
; 378  : #endif
; 379  : 
; 380  : 				fclose(file);
; 381  : 				return 0;
; 382  : 			}
; 383  : 		}
; 384  : 		printf("============================== IMAGEM GERADA ==================================\n");
; 385  : 		printf("Imagem: %d x %d | Channels: %d | Levels: %d\n", image->width, image->height, image->channels, image->levels);
; 386  : 		printf("Localização: %s\n", filename);
; 387  : 		printf("===============================================================================\n\n");
; 388  : 		fclose(file);
; 389  : 
; 390  : 		return 1;
; 391  : 	}
; 392  : 
; 393  : 	return 0;
; 394  : }
; 395  : 
; 396  : #pragma endregion
; 397  : 
; 398  : #pragma region Save and Run
; 399  : 
; 400  : char *conc(const char *first, char *second)
; 401  : {
; 402  : 	char *aux = _strdup(first);
; 403  : 	strcat(aux, second);
; 404  : 	return aux;
; 405  : }
; 406  : 
; 407  : void save(char *filename, IVC *image)
; 408  : {
; 409  : 	char *filepath = conc(results, filename);
; 410  : 	vc_write_image(filepath, image);
; 411  : }
; 412  : 
; 413  : #pragma endregion
; 414  : 
; 415  : #pragma region RGB to GRAY
; 416  : 
; 417  : int vc_rgb_gray(IVC *original, IVC *converted)
; 418  : {
; 419  : 	int pos, posAux, x, y;
; 420  : 	for (x = 0; x < original->width; x++)
; 421  : 	{
; 422  : 		for (y = 0; y < original->height; y++)
; 423  : 		{
; 424  : 			pos = y * original->bytesperline + x * original->channels;
; 425  : 			posAux = y * converted->bytesperline + x * converted->channels;
; 426  : 			converted->data[posAux] = ((0.3 * original->data[pos] + 0.59 * original->data[pos + 1] + 0.11 * original->data[pos + 2]) / 3);
; 427  : 		}
; 428  : 	}
; 429  : 
; 430  : 	return 0;
; 431  : }
; 432  : 
; 433  : #pragma endregion
; 434  : 
; 435  : #pragma region Manuseamento de channels
; 436  : 
; 437  : int vc_only_red(IVC *original, IVC *converted)
; 438  : {
; 439  : 	int pos, x, y;
; 440  : 
; 441  : 	for (x = 0; x < original->width; x++)
; 442  : 	{
; 443  : 		for (y = 0; y < original->height; y++)
; 444  : 		{
; 445  : 			pos = y * original->bytesperline + x * original->channels;
; 446  : 			converted->data[pos] = original->data[pos];
; 447  : 			converted->data[pos + 1] = original->data[pos];
; 448  : 			converted->data[pos + 2] = original->data[pos];
; 449  : 		}
; 450  : 	}
; 451  : 
; 452  : 	return 0;
; 453  : }
; 454  : 
; 455  : int vc_only_green(IVC *original, IVC *converted)
; 456  : {
; 457  : 	int pos, x, y;
; 458  : 
; 459  : 	for (x = 0; x < original->width; x++)
; 460  : 	{
; 461  : 		for (y = 0; y < original->height; y++)
; 462  : 		{
; 463  : 			pos = y * original->bytesperline + x * original->channels;
; 464  : 			converted->data[pos + 1] = original->data[pos + 1];
; 465  : 			converted->data[pos] = 0;
; 466  : 			converted->data[pos + 2] = 0;
; 467  : 		}
; 468  : 	}
; 469  : 
; 470  : 	return 0;
; 471  : }
; 472  : 
; 473  : int vc_only_blue(IVC *original, IVC *converted)
; 474  : {
; 475  : 	int pos, x, y;
; 476  : 
; 477  : 	for (x = 0; x < original->width; x++)
; 478  : 	{
; 479  : 		for (y = 0; y < original->height; y++)
; 480  : 		{
; 481  : 			pos = y * original->bytesperline + x * original->channels;
; 482  : 			converted->data[pos + 2] = original->data[pos + 2];
; 483  : 			converted->data[pos + 1] = 0;
; 484  : 			converted->data[pos] = 0;
; 485  : 		}
; 486  : 	}
; 487  : 
; 488  : 	return 0;
; 489  : }
; 490  : 
; 491  : int vc_remove_red(IVC *original, IVC *converted)
; 492  : {
; 493  : 	int pos, x, y;
; 494  : 
; 495  : 	for (x = 0; x < original->width; x++)
; 496  : 	{
; 497  : 		for (y = 0; y < original->height; y++)
; 498  : 		{
; 499  : 			pos = y * original->bytesperline + x * original->channels;
; 500  : 
; 501  : 			converted->data[pos] = 0;
; 502  : 			converted->data[pos + 1] = original->data[pos + 1];
; 503  : 			converted->data[pos + 2] = original->data[pos + 2];
; 504  : 		}
; 505  : 	}
; 506  : 	return 0;
; 507  : }
; 508  : 
; 509  : int vc_remove_green(IVC *original, IVC *converted)
; 510  : {
; 511  : 	int pos, x, y;
; 512  : 
; 513  : 	for (x = 0; x < original->width; x++)
; 514  : 	{
; 515  : 		for (y = 0; y < original->height; y++)
; 516  : 		{
; 517  : 			pos = y * original->bytesperline + x * original->channels;
; 518  : 			converted->data[pos] = original->data[pos];
; 519  : 			converted->data[pos + 1] = 0;
; 520  : 			converted->data[pos + 2] = original->data[pos + 2];
; 521  : 		}
; 522  : 	}
; 523  : 	return 0;
; 524  : }
; 525  : 
; 526  : int vc_remove_blue(IVC *original, IVC *converted)
; 527  : {
; 528  : 	int pos, x, y;
; 529  : 
; 530  : 	for (x = 0; x < original->width; x++)
; 531  : 	{
; 532  : 		for (y = 0; y < original->height; y++)
; 533  : 		{
; 534  : 			pos = y * original->bytesperline + x * original->channels;
; 535  : 			converted->data[pos] = original->data[pos];
; 536  : 			converted->data[pos + 1] = original->data[pos + 1];
; 537  : 			converted->data[pos + 2] = 0;
; 538  : 		}
; 539  : 	}
; 540  : 
; 541  : 	return 0;
; 542  : }
; 543  : 
; 544  : #pragma endregion
; 545  : 
; 546  : #pragma region Binary
; 547  : 
; 548  : float vc_media(IVC *original)
; 549  : {
; 550  : 	int pos, x, y;
; 551  : 	float media = 0;
; 552  : 
; 553  : 	if (original->channels == 1)
; 554  : 	{
; 555  : 		for (x = 0; x < original->width; x++)
; 556  : 			for (y = 0; y < original->height; y++)
; 557  : 			{
; 558  : 				pos = y * original->bytesperline + x * original->channels;
; 559  : 				media += original->data[pos];
; 560  : 			}
; 561  : 	}
; 562  : 	else if (original->channels == 3)
; 563  : 	{
; 564  : 		for (x = 0; x < original->width; x++)
; 565  : 			for (y = 0; y < original->height; y++)
; 566  : 			{
; 567  : 				pos = y * original->bytesperline + x * original->channels;
; 568  : 				media += (original->data[pos] + original->data[pos + 1] + original->data[pos + 2]) / 3;
; 569  : 			}
; 570  : 	}
; 571  : 	return (media / (original->bytesperline * original->height));
; 572  : }
; 573  : 
; 574  : int vc_rgb_gray_to_binary_global_mean(IVC *original, IVC *converted)
; 575  : {
; 576  : 	int pos, posAux, x, y;
; 577  : 	float media = vc_media(original), meanAux = 0;
; 578  : 
; 579  : 	for (x = 0; x < original->width; x++)
; 580  : 	{
; 581  : 		for (y = 0; y < original->height; y++)
; 582  : 		{
; 583  : 			pos = y * original->bytesperline + x * original->channels;
; 584  : 			posAux = y * converted->bytesperline + x * converted->channels;
; 585  : 			meanAux = (original->channels == 1 ? original->data[pos] : (original->data[pos] + original->data[pos + 1] + original->data[pos + 2])) / original->channels;
; 586  : 			converted->data[posAux] = meanAux > media ? 255 : 0;
; 587  : 		}
; 588  : 	}
; 589  : 
; 590  : 	return 1;
; 591  : }
; 592  : 
; 593  : int vc_rgb_gray_to_binary(IVC *original, IVC *converted, int threshold)
; 594  : {
; 595  : 	int pos, posAux, x, y;
; 596  : 	float meanAux;
; 597  : 
; 598  : 	for (x = 0; x < original->width; x++)

	inc	r11d
	cmp	r11d, DWORD PTR [rdi+8]
	jl	$LL96@vc_trab_fa
$LN95@vc_trab_fa:

; 1501 : 	//vc_write_image("fase3_prewitt.pgm", prewitt); //Passa para outro nivel de cinzas
; 1502 : 
; 1503 : 	//Binary
; 1504 : 	vc_rgb_gray_to_binary(prewitt, binary, 140);
; 1505 : 	//vc_write_image("fase3_threshold.pgm", binary);
; 1506 : 
; 1507 : 	//Get blobs
; 1508 : 	blobs = vc_binary_blob_labelling(binary, bImg, &nLabels);

	lea	r8, QWORD PTR nLabels$[rsp]
	mov	rdx, r15
	mov	rcx, rsi
	call	vc_binary_blob_labelling

; 1509 : 	vc_binary_blob_info(bImg, blobs, nLabels);

	mov	r14d, DWORD PTR nLabels$[rsp]
	mov	rdx, rax
	mov	r8d, r14d
	mov	QWORD PTR blobs$1$[rsp], rax
	mov	rcx, r15
	mov	rsi, rax
	call	vc_binary_blob_info

; 1510 : 
; 1511 : 	//Salva e executa a imagem dos blobs
; 1512 : 	//save("fase3_blobs.pgm", bImg);
; 1513 : 
; 1514 : 	//Free
; 1515 : 	//free(prewitt);
; 1516 : 	//free(binary);
; 1517 : 	//free(bImg);
; 1518 : 
; 1519 : 	//Inicializate median array
; 1520 : 	int median[255][3], count = 0, medianI;
; 1521 : 	float mean = 0;
; 1522 : 
; 1523 : 	//Primeiro filtro nos blobs
; 1524 : 	for (i = 0; i < nLabels; i++)

	movsd	xmm7, QWORD PTR __real@3fc3333333333333
	xor	r8d, r8d
	movsd	xmm6, QWORD PTR __real@3fd999999999999a
	xor	edi, edi
	xorps	xmm3, xmm3
	test	r14d, r14d
	jle	SHORT $LN3@vc_trab_fa

; 1525 : 	{
; 1526 : 		if (blobs[i].height > blobs[i].width && blobs[i].width < blob->width * 0.15 && blobs[i].height > blob->height * 0.40)

	mov	rbx, QWORD PTR blob$[rsp]
	lea	rdx, QWORD PTR median$[rsp+4]
	lea	rcx, QWORD PTR [rsi+8]
$LL4@vc_trab_fa:
	mov	eax, DWORD PTR [rcx+4]
	mov	r9d, DWORD PTR [rcx]
	cmp	eax, r9d
	jle	SHORT $LN2@vc_trab_fa
	movd	xmm0, DWORD PTR [rbx+8]
	cvtdq2pd xmm0, xmm0
	movd	xmm1, r9d
	cvtdq2pd xmm1, xmm1
	mulsd	xmm0, xmm7
	comisd	xmm0, xmm1
	jbe	SHORT $LN2@vc_trab_fa
	movd	xmm0, DWORD PTR [rbx+12]
	cvtdq2pd xmm0, xmm0
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	mulsd	xmm0, xmm6
	comisd	xmm1, xmm0
	jbe	SHORT $LN2@vc_trab_fa

; 1527 : 		{
; 1528 : 			median[count][0] = i;
; 1529 : 			median[count][1] = blobs[i].height;

	mov	DWORD PTR [rdx], eax

; 1530 : 			median[count++][2] = blobs[i].y;

	inc	edi
	mov	eax, DWORD PTR [rcx-4]
	mov	DWORD PTR [rdx+4], eax
	mov	DWORD PTR [rdx-4], r8d
	add	rdx, 12
$LN2@vc_trab_fa:

; 1510 : 
; 1511 : 	//Salva e executa a imagem dos blobs
; 1512 : 	//save("fase3_blobs.pgm", bImg);
; 1513 : 
; 1514 : 	//Free
; 1515 : 	//free(prewitt);
; 1516 : 	//free(binary);
; 1517 : 	//free(bImg);
; 1518 : 
; 1519 : 	//Inicializate median array
; 1520 : 	int median[255][3], count = 0, medianI;
; 1521 : 	float mean = 0;
; 1522 : 
; 1523 : 	//Primeiro filtro nos blobs
; 1524 : 	for (i = 0; i < nLabels; i++)

	inc	r8d
	add	rcx, 36					; 00000024H
	cmp	r8d, r14d
	jl	SHORT $LL4@vc_trab_fa
$LN3@vc_trab_fa:

; 1539 : 		for (j = 0; j < count; j++)

	movsxd	rbp, edi
	test	edi, edi
	jle	SHORT $LN6@vc_trab_fa
	lea	r9, QWORD PTR median$[rsp+8]
	mov	rsi, rbp
	npad	12
$LL7@vc_trab_fa:
	movd	xmm0, DWORD PTR [r9]

; 1537 : 	{
; 1538 : 		mean += median[i][2];

	lea	r8, QWORD PTR median$[rsp+4]
	cvtdq2ps xmm0, xmm0
	mov	r11, rbp
	addss	xmm3, xmm0
$LL10@vc_trab_fa:

; 1540 : 			if (median[j][1] > median[i][1])

	mov	r10d, DWORD PTR [r9-4]
	cmp	DWORD PTR [r8], r10d
	jle	SHORT $LN8@vc_trab_fa

; 1541 : 			{
; 1542 : 				int tmpI = median[i][0];
; 1543 : 				int tmpHeight = median[i][1];
; 1544 : 				int tmpY = median[i][2];
; 1545 : 				median[i][0] = median[j][0];

	mov	eax, DWORD PTR [r8-4]
	mov	ecx, DWORD PTR [r9-8]
	mov	edx, DWORD PTR [r9]
	mov	DWORD PTR [r9-8], eax

; 1546 : 				median[i][1] = median[j][1];

	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [r9-4], eax

; 1547 : 				median[i][2] = median[j][2];

	mov	eax, DWORD PTR [r8+4]
	mov	DWORD PTR [r9], eax

; 1548 : 				median[j][0] = tmpI;

	mov	DWORD PTR [r8-4], ecx

; 1549 : 				median[j][1] = tmpHeight;

	mov	DWORD PTR [r8], r10d

; 1550 : 				median[j][2] = tmpY;

	mov	DWORD PTR [r8+4], edx
$LN8@vc_trab_fa:

; 1539 : 		for (j = 0; j < count; j++)

	add	r8, 12
	sub	r11, 1
	jne	SHORT $LL10@vc_trab_fa

; 1531 : 			//printf("Label: %d | Perimetro: %d | Centro-MASSA: %d,%d | Area: %d | X: %d | Y : %d Width: %d | Height: %d\n", blobs[i].label, blobs[i].perimeter, blobs[i].xc, blobs[i].yc, blobs[i].area, blobs[i].x, blobs[i].y, blobs[i].width, blobs[i].height);
; 1532 : 		}
; 1533 : 	}
; 1534 : 
; 1535 : 	//Ordena o array por ordem ascendente
; 1536 : 	for (i = 0; i < count; i++)

	add	r9, 12
	sub	rsi, 1
	jne	SHORT $LL7@vc_trab_fa
	mov	rsi, QWORD PTR blobs$1$[rsp]
$LN6@vc_trab_fa:
	movd	xmm0, edi

; 1551 : 			}
; 1552 : 	}
; 1553 : 
; 1554 : 	//Lista o array ordenado
; 1555 : 	//printf("\n\n");
; 1556 : 	//for (i = 0; i < count; i++)
; 1557 : 	//	printf("Index : %d \t|\tHeight: %d \t|\tY : %d\n", median[i][0], median[i][1], median[i][2]);
; 1558 : 
; 1559 : 	//Calcula a media e a mediana
; 1560 : 	mean = mean / (float)count;
; 1561 : 	medianI = count % 2 == 0 ? (count / 2) : ((count - 1) / 2);

	mov	eax, edi
	cvtdq2ps xmm0, xmm0
	divss	xmm3, xmm0
	test	dil, 1
	je	SHORT $LN231@vc_trab_fa
	lea	eax, DWORD PTR [rdi-1]
$LN231@vc_trab_fa:

; 1562 : 	count = 0;

	cdq
	xor	r10d, r10d
	sub	eax, edx
	sar	eax, 1

; 1563 : 
; 1564 : 	//Calcula quantos blobs tem com o novo filtro
; 1565 : 	//printf("\n\n");
; 1566 : 	for (i = 0; i < nLabels; i++)

	test	r14d, r14d
	jle	$LN33@vc_trab_fa

; 1567 : 	{
; 1568 : 		if (blobs[i].height > blobs[i].width && blobs[i].width < blob->width * 0.15 && blobs[i].height > blob->height * 0.40 && (blobs[median[medianI][0]].height - 5) < blobs[i].height && (blobs[median[medianI][0]].height + 5) > blobs[i].height && (mean - 10) < blobs[i].y && (mean + 10) > blobs[i].y)

	movss	xmm4, DWORD PTR __real@41200000
	lea	r15, QWORD PTR [rsi+8]
	cdqe
	mov	rdx, r15
	mov	r11, r14
	mov	QWORD PTR tv4511[rsp], r14
	lea	rbx, QWORD PTR [rax+rax*2]
	mov	QWORD PTR tv4705[rsp], rbx
	npad	9
$LL13@vc_trab_fa:
	mov	r8d, DWORD PTR [rdx+4]
	mov	eax, DWORD PTR [rdx]
	mov	r12, QWORD PTR blob$[rsp]
	cmp	r8d, eax
	jle	SHORT $LN11@vc_trab_fa
	movd	xmm0, DWORD PTR [r12+8]
	cvtdq2pd xmm0, xmm0
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	mulsd	xmm0, xmm7
	comisd	xmm0, xmm1
	jbe	SHORT $LN11@vc_trab_fa
	movd	xmm0, DWORD PTR [r12+12]
	cvtdq2pd xmm0, xmm0
	movd	xmm1, r8d
	cvtdq2pd xmm1, xmm1
	mulsd	xmm0, xmm6
	comisd	xmm1, xmm0
	jbe	SHORT $LN11@vc_trab_fa
	movsxd	rax, DWORD PTR median$[rsp+rbx*4]
	lea	rcx, QWORD PTR [rax+rax*8]
	mov	r9d, DWORD PTR [rsi+rcx*4+12]
	lea	eax, DWORD PTR [r9-5]
	cmp	eax, r8d
	jge	SHORT $LN11@vc_trab_fa
	lea	eax, DWORD PTR [r9+5]
	cmp	eax, r8d
	jle	SHORT $LN11@vc_trab_fa
	movd	xmm1, DWORD PTR [rdx-4]
	movaps	xmm0, xmm3
	cvtdq2ps xmm1, xmm1
	subss	xmm0, xmm4
	comiss	xmm1, xmm0
	jbe	SHORT $LN11@vc_trab_fa
	movaps	xmm0, xmm3
	addss	xmm0, xmm4
	comiss	xmm0, xmm1
	jbe	SHORT $LN11@vc_trab_fa

; 1569 : 		{
; 1570 : 			count++;

	inc	r10d
$LN11@vc_trab_fa:

; 1563 : 
; 1564 : 	//Calcula quantos blobs tem com o novo filtro
; 1565 : 	//printf("\n\n");
; 1566 : 	for (i = 0; i < nLabels; i++)

	add	rdx, 36					; 00000024H
	sub	r11, 1
	jne	$LL13@vc_trab_fa

; 1571 : 			//printf("Label: %d | Perimetro: %d | Centro-MASSA: %d,%d | Area: %d | X: %d | Y : %d Width: %d | Height: %d\n", blobs[i].label, blobs[i].perimeter, blobs[i].xc, blobs[i].yc, blobs[i].area, blobs[i].x, blobs[i].y, blobs[i].width, blobs[i].height);
; 1572 : 		}
; 1573 : 	}
; 1574 : 
; 1575 : 	//Verifica se o total de blobs é igual a 6
; 1576 : 	if (count == 6)

	mov	rbx, QWORD PTR result$[rsp]
	cmp	r10d, 6
	jne	$LN33@vc_trab_fa

; 1577 : 	{
; 1578 : 
; 1579 : 		//VARS AUX
; 1580 : 		int bx = blob->x,					//x min
; 1581 : 			by = blob->y,					//y min
; 1582 : 			bMaxx = blob->x + blob->width,	//x max

	mov	r11d, DWORD PTR [r12+8]

; 1583 : 			bMaxY = blob->y + blob->height; //y max
; 1584 : 
; 1585 : 		//Pinta a matricula
; 1586 : 		for (y = 0; y < original->height; y++)

	xor	r9d, r9d
	mov	esi, DWORD PTR [r12+12]
	mov	edi, DWORD PTR [r12]
	add	r11d, edi
	mov	r14d, DWORD PTR [r12+4]
	add	esi, r14d
	cmp	DWORD PTR [r13+12], r9d
	jle	$LN218@vc_trab_fa
	npad	9
$LL16@vc_trab_fa:

; 1587 : 			for (x = 0; x < original->width; x++)

	xor	edx, edx
	cmp	DWORD PTR [r13+8], edx
	jle	$LN14@vc_trab_fa
	npad	4
$LL19@vc_trab_fa:

; 1588 : 			{
; 1589 : 				pos = y * original->bytesperline + x * original->channels;

	mov	r10d, DWORD PTR [r13+16]
	mov	eax, DWORD PTR [r13+24]
	imul	r10d, edx
	imul	eax, r9d
	add	r10d, eax

; 1590 : 
; 1591 : 				if ((y == by && (x >= bx && x <= bMaxx)) ||	   //horizontal - top
; 1592 : 					(x == bx && (y >= by && y <= bMaxY)) ||	   //veritcal   - right
; 1593 : 					(y == bMaxY && (x >= bx && x <= bMaxx)) || //horizontal - down

	cmp	r9d, r14d
	jne	SHORT $LN38@vc_trab_fa
	cmp	edx, edi
	jl	SHORT $LN40@vc_trab_fa
	cmp	edx, r11d
	jle	SHORT $LN36@vc_trab_fa
$LN38@vc_trab_fa:
	cmp	edx, edi
	jne	SHORT $LN40@vc_trab_fa
	cmp	r9d, r14d
	jl	SHORT $LN40@vc_trab_fa
	cmp	r9d, esi
	jle	SHORT $LN36@vc_trab_fa
$LN40@vc_trab_fa:
	cmp	r9d, esi
	jne	SHORT $LN42@vc_trab_fa
	cmp	edx, edi
	jl	SHORT $LN42@vc_trab_fa
	cmp	edx, r11d
	jle	SHORT $LN36@vc_trab_fa
$LN42@vc_trab_fa:
	cmp	edx, r11d
	jne	$LN17@vc_trab_fa
	cmp	r9d, r14d
	jl	$LN17@vc_trab_fa
	cmp	r9d, esi
	jg	$LN17@vc_trab_fa
$LN36@vc_trab_fa:
	movsxd	r8, r10d

; 1594 : 					(x == bMaxx && (y >= by && y <= bMaxY)))   //vertical   - left
; 1595 : 				{
; 1596 : 					if (x == bx)

	cmp	edx, edi
	jne	SHORT $LN43@vc_trab_fa

; 1597 : 					{ //Vertical - left
; 1598 : 						result->data[pos] = 255;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax], 255			; 000000ffH

; 1599 : 						result->data[pos + 1] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax+1], 0
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax+2], 0

; 1600 : 						result->data[pos + 2] = 0;
; 1601 : 						//
; 1602 : 						result->data[pos - 3] = 255;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax-3], 255		; 000000ffH

; 1603 : 						result->data[pos - 2] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax-2], 0

; 1604 : 						result->data[pos - 1] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax-1], 0
$LN43@vc_trab_fa:

; 1605 : 					}
; 1606 : 					if (y == by)

	cmp	r9d, r14d
	jne	SHORT $LN130@vc_trab_fa

; 1607 : 					{ //Horizontal - Up
; 1608 : 						result->data[pos] = 255;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax], 255			; 000000ffH

; 1609 : 						result->data[pos + 1] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax+1], 0
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax+2], 0

; 1610 : 						result->data[pos + 2] = 0;
; 1611 : 						//
; 1612 : 						result->data[pos + result->bytesperline] = 255;

	mov	eax, DWORD PTR [rbx+24]
	add	eax, r10d
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH

; 1613 : 						result->data[pos + 1 + result->bytesperline] = 0;

	mov	eax, DWORD PTR [rbx+24]
	add	eax, r10d
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rcx+rax+1], 0
	mov	eax, DWORD PTR [rbx+24]
	add	eax, r10d
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rcx+rax+2], 0
$LN130@vc_trab_fa:

; 1614 : 						result->data[pos + 2 + result->bytesperline] = 0;
; 1615 : 					}
; 1616 : 					if (y == bMaxY)

	cmp	r9d, esi
	jne	SHORT $LN134@vc_trab_fa

; 1617 : 					{ //Horizontal - Down
; 1618 : 						result->data[pos] = 255;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax], 255			; 000000ffH

; 1619 : 						result->data[pos + 1] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax+1], 0
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax+2], 0

; 1620 : 						result->data[pos + 2] = 0;
; 1621 : 						//
; 1622 : 						result->data[pos - result->bytesperline] = 255;

	mov	eax, r10d
	sub	eax, DWORD PTR [rbx+24]
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH

; 1623 : 						result->data[pos + 1 - result->bytesperline] = 0;

	mov	eax, r10d
	sub	eax, DWORD PTR [rbx+24]
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rcx+rax+1], 0
	sub	r10d, DWORD PTR [rbx+24]
	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, r10d
	mov	BYTE PTR [rcx+rax+2], 0
$LN134@vc_trab_fa:

; 1624 : 						result->data[pos + 2 - result->bytesperline] = 0;
; 1625 : 					}
; 1626 : 					if (x == bMaxx)

	cmp	edx, r11d
	jne	SHORT $LN17@vc_trab_fa

; 1627 : 					{ //Vertical - Right
; 1628 : 						result->data[pos] = 255;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax], 255			; 000000ffH

; 1629 : 						result->data[pos + 1] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax+1], 0
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax+2], 0

; 1630 : 						result->data[pos + 2] = 0;
; 1631 : 						//
; 1632 : 						result->data[pos + 3] = 255;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax+3], 255		; 000000ffH

; 1633 : 						result->data[pos + 4] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax+4], 0
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [r8+rax+5], 0
$LN17@vc_trab_fa:

; 1587 : 			for (x = 0; x < original->width; x++)

	inc	edx
	cmp	edx, DWORD PTR [r13+8]
	jl	$LL19@vc_trab_fa
$LN14@vc_trab_fa:

; 1583 : 			bMaxY = blob->y + blob->height; //y max
; 1584 : 
; 1585 : 		//Pinta a matricula
; 1586 : 		for (y = 0; y < original->height; y++)

	inc	r9d
	cmp	r9d, DWORD PTR [r13+12]
	jl	$LL16@vc_trab_fa
$LN218@vc_trab_fa:

; 1634 : 						result->data[pos + 5] = 0;
; 1635 : 					}
; 1636 : 				}
; 1637 : 			}
; 1638 : 
; 1639 : 		//Pinta os numeros e letras
; 1640 : 		for (i = 0; i < nLabels; i++)

	movsd	xmm5, QWORD PTR __real@3f847ae147ae147b
	npad	1
$LL22@vc_trab_fa:

; 1641 : 		{
; 1642 : 
; 1643 : 			bx = blobs[i].x - (blobs[i].x * 0.01);						//x min

	mov	ecx, DWORD PTR [r15-8]

; 1644 : 			by = blobs[i].y - (blobs[i].y * 0.01);						//y min
; 1645 : 			bMaxx = blobs[i].x + blobs[i].width + (blobs[i].x * 0.01);	//x max
; 1646 : 			bMaxY = blobs[i].y + blobs[i].height + (blobs[i].y * 0.01); //y max
; 1647 : 
; 1648 : 			for (y = 0; y < original->height; y++)

	xor	r9d, r9d
	mov	edx, DWORD PTR [r15-4]
	movd	xmm0, ecx
	add	ecx, DWORD PTR [r15]
	cvtdq2pd xmm0, xmm0
	movaps	xmm2, xmm0
	mulsd	xmm2, xmm5
	subsd	xmm0, xmm2
	cvttsd2si esi, xmm0
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	movaps	xmm1, xmm0
	mulsd	xmm1, xmm5
	subsd	xmm0, xmm1
	cvttsd2si ebp, xmm0
	movd	xmm0, ecx
	mov	ecx, DWORD PTR [r15+4]
	cvtdq2pd xmm0, xmm0
	add	ecx, edx
	addsd	xmm0, xmm2
	cvttsd2si edi, xmm0
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	addsd	xmm0, xmm1
	cvttsd2si r14d, xmm0
	cmp	DWORD PTR [r13+12], r9d
	jle	$LN20@vc_trab_fa
	npad	3
$LL25@vc_trab_fa:

; 1649 : 				for (x = 0; x < original->width; x++)

	xor	r8d, r8d
	cmp	DWORD PTR [r13+8], r8d
	jle	$LN23@vc_trab_fa
	npad	3
$LL28@vc_trab_fa:

; 1650 : 				{
; 1651 : 					pos = y * original->bytesperline + x * original->channels;

	mov	r11d, DWORD PTR [r13+16]
	mov	eax, DWORD PTR [r13+24]

; 1652 : 
; 1653 : 					if (blobs[i].height > blobs[i].width && blobs[i].width < blob->width * 0.15 && blobs[i].height > blob->height * 0.40 && (blobs[median[medianI][0]].height - 5) < blobs[i].height && (blobs[median[medianI][0]].height + 5) > blobs[i].height && (mean - 10) < blobs[i].y && (mean + 10) > blobs[i].y)

	mov	edx, DWORD PTR [r15+4]
	imul	eax, r9d
	imul	r11d, r8d
	add	r11d, eax
	mov	eax, DWORD PTR [r15]
	cmp	edx, eax
	jle	$LN26@vc_trab_fa
	movd	xmm0, DWORD PTR [r12+8]
	cvtdq2pd xmm0, xmm0
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	mulsd	xmm0, xmm7
	comisd	xmm0, xmm1
	jbe	$LN26@vc_trab_fa
	movd	xmm0, DWORD PTR [r12+12]
	cvtdq2pd xmm0, xmm0
	movd	xmm1, edx
	cvtdq2pd xmm1, xmm1
	mulsd	xmm0, xmm6
	comisd	xmm1, xmm0
	jbe	$LN26@vc_trab_fa
	mov	rax, QWORD PTR tv4705[rsp]
	movsxd	rax, DWORD PTR median$[rsp+rax*4]
	lea	rcx, QWORD PTR [rax+rax*8]
	mov	rax, QWORD PTR blobs$1$[rsp]
	mov	r10d, DWORD PTR [rax+rcx*4+12]
	lea	eax, DWORD PTR [r10-5]
	cmp	eax, edx
	jge	$LN26@vc_trab_fa
	lea	eax, DWORD PTR [r10+5]
	cmp	eax, edx
	jle	$LN26@vc_trab_fa
	movd	xmm1, DWORD PTR [r15-4]
	movaps	xmm0, xmm3
	cvtdq2ps xmm1, xmm1
	subss	xmm0, xmm4
	comiss	xmm1, xmm0
	jbe	$LN26@vc_trab_fa
	movaps	xmm0, xmm3
	addss	xmm0, xmm4
	comiss	xmm0, xmm1
	jbe	$LN26@vc_trab_fa

; 1654 : 						if ((y == by && (x >= bx && x <= bMaxx)) ||	   //horizontal - top
; 1655 : 							(x == bx && (y >= by && y <= bMaxY)) ||	   //veritcal - right
; 1656 : 							(y == bMaxY && (x >= bx && x <= bMaxx)) || //horizontal - down

	cmp	r9d, ebp
	jne	SHORT $LN51@vc_trab_fa
	cmp	r8d, esi
	jl	SHORT $LN53@vc_trab_fa
	cmp	r8d, edi
	jle	SHORT $LN49@vc_trab_fa
$LN51@vc_trab_fa:
	cmp	r8d, esi
	jne	SHORT $LN53@vc_trab_fa
	cmp	r9d, ebp
	jl	SHORT $LN53@vc_trab_fa
	cmp	r9d, r14d
	jle	SHORT $LN49@vc_trab_fa
$LN53@vc_trab_fa:
	cmp	r9d, r14d
	jne	SHORT $LN55@vc_trab_fa
	cmp	r8d, esi
	jl	SHORT $LN55@vc_trab_fa
	cmp	r8d, edi
	jle	SHORT $LN49@vc_trab_fa
$LN55@vc_trab_fa:
	cmp	r8d, edi
	jne	$LN26@vc_trab_fa
	cmp	r9d, ebp
	jl	$LN26@vc_trab_fa
	cmp	r9d, r14d
	jg	$LN26@vc_trab_fa
$LN49@vc_trab_fa:

; 1657 : 							(x == bMaxx && (y >= by && y <= bMaxY)))   // vertical-left
; 1658 : 						{
; 1659 : 							if (x == bx)

	movsxd	rdx, r11d
	cmp	r8d, esi
	jne	SHORT $LN193@vc_trab_fa

; 1660 : 							{ //Vertical - left
; 1661 : 								result->data[pos] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax], 0

; 1662 : 								result->data[pos + 1] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax+1], 0

; 1663 : 								result->data[pos + 2] = 255;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax+2], 255		; 000000ffH

; 1664 : 								//
; 1665 : 								result->data[pos - 3] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax-3], 0

; 1666 : 								result->data[pos - 2] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax-2], 0

; 1667 : 								result->data[pos - 1] = 255;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax-1], 255		; 000000ffH
$LN193@vc_trab_fa:

; 1668 : 							}
; 1669 : 							if (y == by)

	cmp	r9d, ebp
	jne	SHORT $LN194@vc_trab_fa

; 1670 : 							{ //Horizontal - Up
; 1671 : 								result->data[pos] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax], 0

; 1672 : 								result->data[pos + 1] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax+1], 0

; 1673 : 								result->data[pos + 2] = 255;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax+2], 255		; 000000ffH

; 1674 : 								//
; 1675 : 								result->data[pos + result->bytesperline] = 0;

	mov	eax, DWORD PTR [rbx+24]
	add	eax, r11d
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rcx+rax], 0

; 1676 : 								result->data[pos + 1 + result->bytesperline] = 0;

	mov	eax, DWORD PTR [rbx+24]
	add	eax, r11d
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rcx+rax+1], 0

; 1677 : 								result->data[pos + 2 + result->bytesperline] = 255;

	mov	eax, DWORD PTR [rbx+24]
	add	eax, r11d
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rcx+rax+2], 255		; 000000ffH
$LN194@vc_trab_fa:

; 1678 : 							}
; 1679 : 							if (y == bMaxY)

	cmp	r9d, r14d
	jne	SHORT $LN195@vc_trab_fa

; 1680 : 							{ //Horizontal - Down
; 1681 : 								result->data[pos] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax], 0

; 1682 : 								result->data[pos + 1] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax+1], 0

; 1683 : 								result->data[pos + 2] = 255;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax+2], 255		; 000000ffH

; 1684 : 								//
; 1685 : 								result->data[pos - result->bytesperline] = 0;

	mov	eax, r11d
	sub	eax, DWORD PTR [rbx+24]
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rcx+rax], 0

; 1686 : 								result->data[pos + 1 - result->bytesperline] = 0;

	mov	eax, r11d
	sub	eax, DWORD PTR [rbx+24]
	movsxd	rcx, eax
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rcx+rax+1], 0

; 1687 : 								result->data[pos + 2 - result->bytesperline] = 255;

	sub	r11d, DWORD PTR [rbx+24]
	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, r11d
	mov	BYTE PTR [rcx+rax+2], 255		; 000000ffH
$LN195@vc_trab_fa:

; 1688 : 							}
; 1689 : 							if (x == bMaxx)

	cmp	r8d, edi
	jne	SHORT $LN26@vc_trab_fa

; 1690 : 							{ //Vertical - Right
; 1691 : 								result->data[pos] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax], 0

; 1692 : 								result->data[pos + 1] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax+1], 0

; 1693 : 								result->data[pos + 2] = 255;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax+2], 255		; 000000ffH

; 1694 : 								//
; 1695 : 								result->data[pos + 3] = 0;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax+3], 0
	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax+4], 0

; 1696 : 								result->data[pos + 4] = 0;
; 1697 : 								result->data[pos + 5] = 255;

	mov	rax, QWORD PTR [rbx]
	mov	BYTE PTR [rdx+rax+5], 255		; 000000ffH
$LN26@vc_trab_fa:

; 1649 : 				for (x = 0; x < original->width; x++)

	inc	r8d
	cmp	r8d, DWORD PTR [r13+8]
	jl	$LL28@vc_trab_fa
$LN23@vc_trab_fa:

; 1644 : 			by = blobs[i].y - (blobs[i].y * 0.01);						//y min
; 1645 : 			bMaxx = blobs[i].x + blobs[i].width + (blobs[i].x * 0.01);	//x max
; 1646 : 			bMaxY = blobs[i].y + blobs[i].height + (blobs[i].y * 0.01); //y max
; 1647 : 
; 1648 : 			for (y = 0; y < original->height; y++)

	inc	r9d
	cmp	r9d, DWORD PTR [r13+12]
	jl	$LL25@vc_trab_fa
$LN20@vc_trab_fa:

; 1634 : 						result->data[pos + 5] = 0;
; 1635 : 					}
; 1636 : 				}
; 1637 : 			}
; 1638 : 
; 1639 : 		//Pinta os numeros e letras
; 1640 : 		for (i = 0; i < nLabels; i++)

	add	r15, 36					; 00000024H
	sub	QWORD PTR tv4511[rsp], 1
	jne	$LL22@vc_trab_fa

; 1705 : 	//
; 1706 : 	return 0;

	xor	eax, eax
	jmp	SHORT $LN227@vc_trab_fa
$LN33@vc_trab_fa:

; 1698 : 							}
; 1699 : 						}
; 1700 : 				}
; 1701 : 		}
; 1702 : 	}
; 1703 : 	else
; 1704 : 		return 1;

	mov	eax, 1
$LN227@vc_trab_fa:
	movaps	xmm6, XMMWORD PTR [rsp+3152]
	mov	r15, QWORD PTR [rsp+3168]
	mov	r14, QWORD PTR [rsp+3176]
	mov	rdi, QWORD PTR [rsp+3184]
	mov	rsi, QWORD PTR [rsp+3192]
	mov	rbp, QWORD PTR [rsp+3232]
	movaps	xmm7, XMMWORD PTR [rsp+3136]

; 1707 : }

	add	rsp, 3200				; 00000c80H
	pop	r13
	pop	r12
	pop	rbx
	ret	0
vc_trab_fase3 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_gray_edge_prewitt
_TEXT	SEGMENT
tv6312 = 32
tv6335 = 36
bytesperline$1$ = 40
tv6332 = 44
tv6390 = 48
tv6333 = 52
datasrc$1$ = 56
tv6389 = 64
tv6342 = 64
tv6337 = 72
tv6328 = 72
tv6343 = 80
x$1$ = 80
datadst$1$ = 88
tv6325 = 96
tv6372 = 100
tv6371 = 104
tv6370 = 108
tv6369 = 112
tv6368 = 116
tv6367 = 120
tv6327 = 124
width$1$ = 128
height$1$ = 132
tv6384 = 136
tv6336 = 144
tv6309 = 152
hist$ = 160
__$ArrayPad$ = 1184
src$ = 1280
dst$ = 1288
th$ = 1296
vc_gray_edge_prewitt PROC				; COMDAT

; 864  : {

$LN91:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 1216				; 000004c0H
	movaps	XMMWORD PTR [rsp+1200], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 865  : 	unsigned char *datasrc = (unsigned char *)src->data;

	mov	r13, QWORD PTR [rcx]
	mov	rsi, rdx

; 866  : 	unsigned char *datadst = (unsigned char *)dst->data;

	mov	r14, QWORD PTR [rdx]

; 867  : 	int width = src->width;
; 868  : 	int height = src->height;
; 869  : 	int bytesperline = src->bytesperline;
; 870  : 	int channels = src->channels;
; 871  : 	int x, y;
; 872  : 	long int posX, posA, posB, posC, posD, posE, posF, posG, posH;
; 873  : 	int i, size;
; 874  : 	int histmax, histthreshold;
; 875  : 	int sumx, sumy;
; 876  : 	int hist[256] = {0};

	mov	r8d, 1024				; 00000400H
	mov	edi, DWORD PTR [rcx+8]
	xor	edx, edx
	mov	ebp, DWORD PTR [rcx+12]
	movaps	xmm6, xmm2
	mov	ebx, DWORD PTR [rcx+24]
	mov	r15d, DWORD PTR [rcx+16]
	lea	rcx, QWORD PTR hist$[rsp]
	mov	QWORD PTR datasrc$1$[rsp], r13
	mov	QWORD PTR datadst$1$[rsp], r14
	mov	DWORD PTR width$1$[rsp], edi
	mov	DWORD PTR height$1$[rsp], ebp
	mov	DWORD PTR bytesperline$1$[rsp], ebx
	call	memset

; 877  : 
; 878  : 	// Verificação de erros
; 879  : 	if ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))

	test	edi, edi
	jle	$LN24@vc_gray_ed
	test	ebp, ebp
	jle	$LN24@vc_gray_ed
	test	r13, r13
	je	$LN24@vc_gray_ed

; 881  : 	if ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))

	cmp	edi, DWORD PTR [rsi+8]
	jne	$LN24@vc_gray_ed
	cmp	ebp, DWORD PTR [rsi+12]
	jne	$LN24@vc_gray_ed
	cmp	r15d, DWORD PTR [rsi+16]
	jne	$LN24@vc_gray_ed

; 882  : 		return 0;
; 883  : 	if (channels != 1)

	cmp	r15d, 1
	jne	$LN24@vc_gray_ed

; 884  : 		return 0;
; 885  : 
; 886  : 	size = width * height;

	mov	r11d, ebp

; 887  : 
; 888  : 	for (y = 1; y < height - 1; y++)

	lea	eax, DWORD PTR [rbp-1]
	imul	r11d, edi
	xor	esi, esi
	mov	DWORD PTR tv6384[rsp], r11d
	cmp	eax, r15d
	jle	$LN88@vc_gray_ed

; 884  : 		return 0;
; 885  : 
; 886  : 	size = width * height;

	lea	r11d, DWORD PTR [rdi-1]
	mov	QWORD PTR [rsp+1296], r12
	lea	r8d, DWORD PTR [rbx+2]
	mov	DWORD PTR tv6390[rsp], r11d
	lea	edx, DWORD PTR [rbx+rbx]
	mov	DWORD PTR tv6333[rsp], r8d
	lea	ecx, DWORD PTR [rax-1]
	mov	DWORD PTR tv6332[rsp], edx
	mov	QWORD PTR tv6336[rsp], rcx
	mov	r9d, esi
	mov	DWORD PTR tv6335[rsp], esi
	npad	11
$LL4@vc_gray_ed:

; 889  : 	{
; 890  : 		for (x = 1; x < width - 1; x++)

	mov	r10d, 1
	cmp	r11d, r10d
	jle	$LN2@vc_gray_ed
	cmp	r11d, 4
	jle	$LC55@vc_gray_ed

; 891  : 		{
; 892  : 			posA = (y - 1) * bytesperline + (x - 1) * channels;
; 893  : 			posB = (y - 1) * bytesperline + x * channels;
; 894  : 			posC = (y - 1) * bytesperline + (x + 1) * channels;
; 895  : 			posD = y * bytesperline + (x - 1) * channels;

	lea	r12d, DWORD PTR [r8+r9]
	mov	r8d, edx
	lea	ecx, DWORD PTR [r9+rbx]
	mov	DWORD PTR tv6312[rsp], r12d
	sub	r8d, ecx
	mov	edx, r9d
	sub	edx, ecx
	add	r8d, r9d
	mov	DWORD PTR tv6328[rsp], r8d
	mov	DWORD PTR tv6327[rsp], edx
	lea	eax, DWORD PTR [rdx+1]
	mov	DWORD PTR tv6371[rsp], eax
	lea	r9d, DWORD PTR [rdx-2]
	lea	eax, DWORD PTR [rdx+2]
	mov	DWORD PTR tv6369[rsp], eax
	lea	esi, DWORD PTR [rdx-1]
	lea	eax, DWORD PTR [rdx+3]
	mov	DWORD PTR tv6367[rsp], eax
	lea	r10d, DWORD PTR [r8-2]
	lea	eax, DWORD PTR [r8+1]
	mov	DWORD PTR tv6372[rsp], eax
	lea	eax, DWORD PTR [r8+2]
	mov	DWORD PTR tv6370[rsp], eax
	lea	eax, DWORD PTR [r8+3]
	mov	DWORD PTR tv6368[rsp], eax
	lea	eax, DWORD PTR [r8-1]
	mov	DWORD PTR tv6325[rsp], eax
	lea	eax, DWORD PTR [r11-5]
	shr	eax, 2
	inc	eax
	mov	ecx, eax
	mov	QWORD PTR tv6389[rsp], rcx
	lea	eax, DWORD PTR [rax*4+1]
	mov	DWORD PTR x$1$[rsp], eax
	npad	8
$LL56@vc_gray_ed:

; 908  : 			sumx += datasrc[posH] * +1;

	mov	rbp, QWORD PTR datasrc$1$[rsp]
	lea	eax, DWORD PTR [r12+r10]
	movsxd	rdi, DWORD PTR tv6312[rsp]
	movsxd	rcx, eax
	lea	eax, DWORD PTR [r12+r9]
	movsxd	r15, r12d
	movzx	ebx, BYTE PTR [rcx+r13]
	movsxd	rcx, eax
	lea	eax, DWORD PTR [r8+r12]
	movzx	r11d, BYTE PTR [rcx+r13]
	movzx	ecx, BYTE PTR [rdi+rbp-2]
	movsxd	r13, eax
	lea	eax, DWORD PTR [rdx+r12]
	movzx	edx, BYTE PTR [r15+rbp]
	sub	edx, ecx
	movsxd	r12, eax
	sub	edx, r11d

; 909  : 			sumx = sumx / 3; // 3 = 1 + 1 + 1

	mov	eax, 1431655766				; 55555556H
	movzx	r9d, BYTE PTR [rbp+r13]
	sub	edx, ebx
	movzx	r8d, BYTE PTR [r12+rbp]
	add	edx, r8d
	add	edx, r9d
	imul	edx

; 910  : 
; 911  : 			sumy = datasrc[posA] * -1;
; 912  : 			sumy += datasrc[posB] * -1;

	lea	eax, DWORD PTR [rsi+rdi]
	movsxd	rsi, eax
	mov	r10d, edx

; 913  : 			sumy += datasrc[posC] * -1;
; 914  : 
; 915  : 			sumy += datasrc[posF] * +1;
; 916  : 			sumy += datasrc[posG] * +1;

	mov	eax, DWORD PTR tv6325[rsp]
	add	eax, edi
	shr	r10d, 31
	movsxd	rdi, eax
	add	r10d, edx
	movzx	eax, BYTE PTR [rsi+rbp]

; 919  : 
; 920  : 			datadst[posX] = (unsigned char)sqrt((double)(sumx * sumx + sumy * sumy));

	imul	r10d, r10d
	movzx	ecx, BYTE PTR [rdi+rbp]
	sub	ecx, eax
	mov	eax, 1431655766				; 55555556H
	sub	ecx, r8d
	sub	ecx, r11d
	add	ecx, r9d
	add	ecx, ebx
	movsxd	rbx, DWORD PTR tv6312[rsp]
	imul	ecx
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	edx, edx
	add	edx, r10d
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	call	sqrt
	movsxd	rdx, DWORD PTR tv6312[rsp]
	cvttsd2si eax, xmm0
	lea	rcx, QWORD PTR [rdx+1]
	mov	QWORD PTR tv6309[rsp], rcx
	mov	BYTE PTR [rbx+r14-1], al
	movzx	r10d, BYTE PTR [rsi+rbp]
	mov	rsi, QWORD PTR datasrc$1$[rsp]
	movzx	edi, BYTE PTR [rdi+rbp]
	mov	eax, DWORD PTR tv6372[rsp]
	add	eax, edx
	movzx	ecx, BYTE PTR [rcx+rsi]
	movsxd	r14, eax
	mov	eax, DWORD PTR tv6371[rsp]
	add	eax, edx
	movzx	r11d, BYTE PTR [r14+rbp]
	movsxd	rbp, eax
	movzx	eax, BYTE PTR [rbx+rsi-1]
	sub	ecx, eax
	mov	eax, 1431655766				; 55555556H
	sub	ecx, edi
	movzx	r8d, BYTE PTR [rsi+rbp]
	sub	ecx, r10d
	add	ecx, r8d
	add	ecx, r11d
	imul	ecx
	movzx	eax, BYTE PTR [r12+rsi]
	movzx	ecx, BYTE PTR [rsi+r13]
	mov	r9d, edx
	shr	r9d, 31
	add	r9d, edx
	sub	ecx, eax
	imul	r9d, r9d
	sub	ecx, r10d
	mov	eax, 1431655766				; 55555556H
	sub	ecx, r8d
	add	ecx, edi
	add	ecx, r11d
	imul	ecx
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	edx, edx
	add	edx, r9d
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	call	sqrt
	mov	rcx, QWORD PTR datadst$1$[rsp]
	cvttsd2si eax, xmm0
	mov	BYTE PTR [r15+rcx], al
	movzx	r10d, BYTE PTR [r12+rsi]
	movzx	ebx, BYTE PTR [rsi+r13]
	mov	r13, rsi
	movsxd	r12, DWORD PTR tv6312[rsp]
	mov	eax, DWORD PTR tv6370[rsp]
	movsxd	r15, DWORD PTR tv6312[rsp]
	add	eax, r12d
	movsxd	rsi, eax
	mov	eax, DWORD PTR tv6369[rsp]
	add	eax, r12d
	movzx	ecx, BYTE PTR [r15+r13+2]
	movzx	r11d, BYTE PTR [rsi+r13]
	movsxd	rdi, eax
	movzx	eax, BYTE PTR [r12+r13]
	sub	ecx, eax
	mov	eax, 1431655766				; 55555556H
	sub	ecx, r10d
	movzx	r8d, BYTE PTR [rdi+r13]
	sub	ecx, ebx
	add	ecx, r8d
	add	ecx, r11d
	imul	ecx
	movzx	eax, BYTE PTR [r13+rbp]
	movzx	ecx, BYTE PTR [r14+r13]
	mov	r9d, edx
	sub	ecx, eax
	shr	r9d, 31
	add	r9d, edx
	sub	ecx, r10d
	sub	ecx, r8d
	imul	r9d, r9d
	add	ecx, ebx
	mov	eax, 1431655766				; 55555556H
	add	ecx, r11d
	imul	ecx
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	edx, edx
	add	edx, r9d
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	call	sqrt
	mov	rdx, QWORD PTR tv6309[rsp]
	mov	rcx, QWORD PTR datadst$1$[rsp]
	cvttsd2si eax, xmm0
	mov	BYTE PTR [rdx+rcx], al
	mov	eax, DWORD PTR tv6368[rsp]
	movzx	r11d, BYTE PTR [r13+rbp]
	add	eax, r12d
	movzx	ebx, BYTE PTR [r14+r13]
	movsxd	rcx, eax
	mov	eax, DWORD PTR tv6367[rsp]
	add	eax, r12d
	movzx	r10d, BYTE PTR [rcx+r13]
	movsxd	rcx, eax
	movzx	eax, BYTE PTR [rdx+r13]
	movzx	r8d, BYTE PTR [rcx+r13]
	movzx	ecx, BYTE PTR [r12+r13+3]
	sub	ecx, eax
	sub	ecx, r11d
	sub	ecx, ebx

; 909  : 			sumx = sumx / 3; // 3 = 1 + 1 + 1

	add	ecx, r8d
	mov	eax, 1431655766				; 55555556H
	add	ecx, r10d
	imul	ecx

; 910  : 
; 911  : 			sumy = datasrc[posA] * -1;
; 912  : 			sumy += datasrc[posB] * -1;

	movzx	eax, BYTE PTR [rdi+r13]

; 913  : 			sumy += datasrc[posC] * -1;
; 914  : 
; 915  : 			sumy += datasrc[posF] * +1;
; 916  : 			sumy += datasrc[posG] * +1;

	movzx	ecx, BYTE PTR [rsi+r13]
	mov	r9d, edx

; 917  : 			sumy += datasrc[posH] * +1;
; 918  : 			sumy = sumy / 3; // 3 = 1 + 1 + 1

	sub	ecx, eax
	shr	r9d, 31
	add	r9d, edx
	sub	ecx, r8d
	sub	ecx, r11d

; 919  : 
; 920  : 			datadst[posX] = (unsigned char)sqrt((double)(sumx * sumx + sumy * sumy));

	imul	r9d, r9d
	add	ecx, r10d
	mov	eax, 1431655766				; 55555556H
	add	ecx, ebx
	imul	ecx
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	edx, edx
	add	edx, r9d
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	call	sqrt
	mov	edx, DWORD PTR tv6327[rsp]
	add	r12d, 4
	sub	QWORD PTR tv6389[rsp], 1
	mov	r14, QWORD PTR datadst$1$[rsp]
	mov	r8d, DWORD PTR tv6328[rsp]
	cvttsd2si eax, xmm0
	mov	DWORD PTR tv6312[rsp], r12d
	lea	r9d, DWORD PTR [rdx-2]
	lea	esi, DWORD PTR [rdx-1]
	lea	r10d, DWORD PTR [r8-2]
	mov	BYTE PTR [r15+r14+2], al
	jne	$LL56@vc_gray_ed

; 889  : 	{
; 890  : 		for (x = 1; x < width - 1; x++)

	mov	r10d, DWORD PTR x$1$[rsp]
	mov	r11d, DWORD PTR tv6390[rsp]
	mov	r9d, DWORD PTR tv6335[rsp]
	mov	ebx, DWORD PTR bytesperline$1$[rsp]
	mov	edx, DWORD PTR tv6332[rsp]
	cmp	r10d, r11d
	jge	$LN89@vc_gray_ed
$LC55@vc_gray_ed:
	add	edx, r9d
	lea	ecx, DWORD PTR [r9+r10]
	add	edx, r10d
	movsxd	r12, ecx
	movsxd	rsi, edx
	lea	r8d, DWORD PTR [r9+r10]
	add	r8d, ebx
	movsxd	r15, edx
	movsxd	rax, edx
	inc	r15
	mov	rdx, QWORD PTR datasrc$1$[rsp]
	dec	rax
	movsxd	rdi, r8d
	dec	r12
	add	rdi, r14
	movsxd	rbp, ecx
	movsxd	r14, ecx
	add	rsi, r13
	lea	rcx, QWORD PTR [rdx+1]
	inc	r14
	add	r14, r13
	add	rbp, r13
	add	r15, r13
	add	r12, r13
	add	r13, rax
	dec	rdx
	movsxd	rax, r8d
	add	rcx, rax
	movsxd	rax, r8d
	add	rdx, rax
	mov	QWORD PTR tv6343[rsp], rcx
	mov	r8d, r11d
	mov	QWORD PTR tv6342[rsp], rdx
	sub	r8d, r10d
	mov	QWORD PTR tv6337[rsp], r8
$LC75@vc_gray_ed:

; 896  : 			posX = y * bytesperline + x * channels;
; 897  : 			posE = y * bytesperline + (x + 1) * channels;
; 898  : 			posF = (y + 1) * bytesperline + (x - 1) * channels;
; 899  : 			posG = (y + 1) * bytesperline + x * channels;
; 900  : 			posH = (y + 1) * bytesperline + (x + 1) * channels;
; 901  : 
; 902  : 			sumx = datasrc[posA] * -1;
; 903  : 			sumx += datasrc[posD] * -1;
; 904  : 			sumx += datasrc[posF] * -1;
; 905  : 
; 906  : 			sumx += datasrc[posC] * +1;
; 907  : 			sumx += datasrc[posE] * +1;

	movzx	ecx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rdx]
	movzx	r9d, BYTE PTR [r12]
	sub	ecx, eax
	movzx	r8d, BYTE PTR [r14]
	sub	ecx, r9d

; 908  : 			sumx += datasrc[posH] * +1;

	movzx	r10d, BYTE PTR [r15]

; 909  : 			sumx = sumx / 3; // 3 = 1 + 1 + 1

	mov	eax, 1431655766				; 55555556H
	movzx	ebx, BYTE PTR [r13]
	sub	ecx, ebx
	add	ecx, r8d
	add	ecx, r10d
	imul	ecx

; 910  : 
; 911  : 			sumy = datasrc[posA] * -1;
; 912  : 			sumy += datasrc[posB] * -1;

	movzx	eax, BYTE PTR [rbp]

; 913  : 			sumy += datasrc[posC] * -1;
; 914  : 
; 915  : 			sumy += datasrc[posF] * +1;
; 916  : 			sumy += datasrc[posG] * +1;

	movzx	ecx, BYTE PTR [rsi]
	mov	r11d, edx
	sub	ecx, eax
	shr	r11d, 31
	add	r11d, edx
	sub	ecx, r8d
	sub	ecx, r9d

; 919  : 
; 920  : 			datadst[posX] = (unsigned char)sqrt((double)(sumx * sumx + sumy * sumy));

	imul	r11d, r11d
	add	ecx, r10d
	mov	eax, 1431655766				; 55555556H
	add	ecx, ebx
	imul	ecx
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	edx, edx
	add	edx, r11d
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	call	sqrt
	mov	rdx, QWORD PTR tv6342[rsp]
	lea	rdi, QWORD PTR [rdi+1]
	mov	rcx, QWORD PTR tv6343[rsp]
	lea	r13, QWORD PTR [r13+1]
	inc	rdx
	lea	r12, QWORD PTR [r12+1]
	inc	rcx
	mov	QWORD PTR tv6342[rsp], rdx
	sub	QWORD PTR tv6337[rsp], 1
	lea	r15, QWORD PTR [r15+1]
	cvttsd2si eax, xmm0
	mov	QWORD PTR tv6343[rsp], rcx
	lea	r14, QWORD PTR [r14+1]
	lea	rbp, QWORD PTR [rbp+1]
	lea	rsi, QWORD PTR [rsi+1]
	mov	BYTE PTR [rdi-1], al
	jne	$LC75@vc_gray_ed

; 889  : 	{
; 890  : 		for (x = 1; x < width - 1; x++)

	mov	r13, QWORD PTR datasrc$1$[rsp]
	mov	r9d, DWORD PTR tv6335[rsp]
	mov	r14, QWORD PTR datadst$1$[rsp]
	mov	r11d, DWORD PTR tv6390[rsp]
	mov	ebx, DWORD PTR bytesperline$1$[rsp]
	mov	edx, DWORD PTR tv6332[rsp]
$LN89@vc_gray_ed:

; 887  : 
; 888  : 	for (y = 1; y < height - 1; y++)

	mov	r8d, DWORD PTR tv6333[rsp]
$LN2@vc_gray_ed:
	add	r9d, ebx
	sub	QWORD PTR tv6336[rsp], 1
	mov	DWORD PTR tv6335[rsp], r9d
	jne	$LL4@vc_gray_ed
	mov	edi, DWORD PTR width$1$[rsp]
	xor	esi, esi
	mov	ebp, DWORD PTR height$1$[rsp]
	mov	r11d, DWORD PTR tv6384[rsp]
	mov	r12, QWORD PTR [rsp+1296]
$LN88@vc_gray_ed:

; 921  : 		}
; 922  : 	}
; 923  : 
; 924  : 	// Compute a grey level histogram
; 925  : 	for (y = 0; y < height; y++)

	movsxd	r10, ebx
	mov	r8, r14
	mov	r9d, ebp
	npad	6
$LL10@vc_gray_ed:

; 926  : 	{
; 927  : 		for (x = 0; x < width; x++)
; 928  : 		{
; 929  : 			hist[datadst[y * bytesperline + x * channels]]++;

	mov	rcx, r8
	mov	edx, edi
	npad	11
$LL13@vc_gray_ed:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	inc	DWORD PTR hist$[rsp+rax*4]
	sub	rdx, 1
	jne	SHORT $LL13@vc_gray_ed

; 921  : 		}
; 922  : 	}
; 923  : 
; 924  : 	// Compute a grey level histogram
; 925  : 	for (y = 0; y < height; y++)

	add	r8, r10
	sub	r9, 1
	jne	SHORT $LL10@vc_gray_ed

; 930  : 		}
; 931  : 	}
; 932  : 
; 933  : 	// Threshold at the middle of the occupied levels
; 934  : 	histmax = 0;

	movd	xmm1, r11d
	mov	eax, esi
	cvtdq2ps xmm1, xmm1

; 935  : 	for (i = 0; i <= 255; i++)

	mov	r9d, esi
	mov	rcx, rsi
	mulss	xmm1, xmm6
$LL16@vc_gray_ed:

; 936  : 	{
; 937  : 		histmax += hist[i];

	add	eax, DWORD PTR hist$[rsp+rcx*4]
	movd	xmm0, eax

; 938  : 
; 939  : 		// th = Prewitt Threshold
; 940  : 		if (histmax >= (((float)size) * th))

	cvtdq2ps xmm0, xmm0
	comiss	xmm0, xmm1
	jae	SHORT $LN87@vc_gray_ed
	add	eax, DWORD PTR hist$[rsp+rcx*4+4]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	comiss	xmm0, xmm1
	jae	SHORT $LN57@vc_gray_ed
	add	eax, DWORD PTR hist$[rsp+rcx*4+8]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	comiss	xmm0, xmm1
	jae	SHORT $LN58@vc_gray_ed
	add	eax, DWORD PTR hist$[rsp+rcx*4+12]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	comiss	xmm0, xmm1
	jae	SHORT $LN59@vc_gray_ed

; 935  : 	for (i = 0; i <= 255; i++)

	add	rcx, 4
	add	r9d, 4
	cmp	rcx, 255				; 000000ffH
	jle	SHORT $LL16@vc_gray_ed
	jmp	SHORT $LN87@vc_gray_ed
$LN59@vc_gray_ed:

; 938  : 
; 939  : 		// th = Prewitt Threshold
; 940  : 		if (histmax >= (((float)size) * th))

	add	r9d, 3
	jmp	SHORT $LN87@vc_gray_ed
$LN58@vc_gray_ed:
	add	r9d, 2
	jmp	SHORT $LN87@vc_gray_ed
$LN57@vc_gray_ed:
	inc	r9d
$LN87@vc_gray_ed:

; 941  : 			break;
; 942  : 	}
; 943  : 	histthreshold = i;

	movsxd	rbx, ebx
	mov	r11d, ebp
	npad	11
$LL19@vc_gray_ed:

; 947  : 		for (x = 0; x < width; x++)

	mov	r8, r14
	mov	r10d, edi
	npad	10
$LL22@vc_gray_ed:

; 948  : 		{
; 949  : 			posX = y * bytesperline + x * channels;
; 950  : 
; 951  : 			if (datadst[posX] >= histthreshold)

	movzx	ecx, BYTE PTR [r8]
	lea	r8, QWORD PTR [r8+1]
	cmp	ecx, r9d
	mov	edx, 255				; 000000ffH
	cmovl	edx, esi
	mov	BYTE PTR [r8-1], dl
	sub	r10, 1
	jne	SHORT $LL22@vc_gray_ed

; 944  : 
; 945  : 	// Apply the threshold
; 946  : 	for (y = 0; y < height; y++)

	add	r14, rbx
	sub	r11, 1
	jne	SHORT $LL19@vc_gray_ed

; 952  : 				datadst[posX] = 255;
; 953  : 			else
; 954  : 				datadst[posX] = 0;
; 955  : 		}
; 956  : 
; 957  : 	return 1;

	lea	eax, QWORD PTR [r10+1]
	jmp	SHORT $LN1@vc_gray_ed
$LN24@vc_gray_ed:

; 880  : 		return 0;

	xor	eax, eax
$LN1@vc_gray_ed:

; 958  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	movaps	xmm6, XMMWORD PTR [rsp+1200]
	add	rsp, 1216				; 000004c0H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
vc_gray_edge_prewitt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_rgb_gray
_TEXT	SEGMENT
original$ = 32
converted$ = 40
vc_rgb_gray PROC					; COMDAT

; 418  : {

$LN20:
	sub	rsp, 24

; 419  : 	int pos, posAux, x, y;
; 420  : 	for (x = 0; x < original->width; x++)

	xor	r8d, r8d
	mov	r11, rdx
	mov	r9, rcx
	cmp	DWORD PTR [rcx+8], r8d
	jle	$LN18@vc_rgb_gra
	mov	eax, DWORD PTR [rcx+12]
	movsd	xmm3, QWORD PTR __real@3fe2e147ae147ae1
	movsd	xmm4, QWORD PTR __real@3fd3333333333333
	movsd	xmm5, QWORD PTR __real@3fbc28f5c28f5c29
	movaps	XMMWORD PTR [rsp], xmm6
	movsd	xmm6, QWORD PTR __real@4008000000000000
	npad	2
$LL4@vc_rgb_gra:

; 421  : 	{
; 422  : 		for (y = 0; y < original->height; y++)

	xor	r10d, r10d
	test	eax, eax
	jle	$LN2@vc_rgb_gra
	npad	5
$LL7@vc_rgb_gra:

; 423  : 		{
; 424  : 			pos = y * original->bytesperline + x * original->channels;

	mov	ecx, r10d
	mov	eax, r8d
	imul	eax, DWORD PTR [r9+16]
	imul	ecx, DWORD PTR [r9+24]
	add	ecx, eax

; 425  : 			posAux = y * converted->bytesperline + x * converted->channels;
; 426  : 			converted->data[posAux] = ((0.3 * original->data[pos] + 0.59 * original->data[pos + 1] + 0.11 * original->data[pos + 2]) / 3);

	movsxd	rdx, ecx
	mov	rcx, QWORD PTR [r9]
	movzx	eax, BYTE PTR [rdx+rcx+1]
	movd	xmm2, eax
	movzx	eax, BYTE PTR [rdx+rcx]
	cvtdq2pd xmm2, xmm2
	movd	xmm0, eax
	movzx	eax, BYTE PTR [rdx+rcx+2]
	mov	ecx, DWORD PTR [r11+24]
	mulsd	xmm2, xmm3
	imul	ecx, r10d
	inc	r10d
	movd	xmm1, eax
	mov	eax, DWORD PTR [r11+16]
	imul	eax, r8d
	cvtdq2pd xmm0, xmm0
	add	ecx, eax
	mov	rax, QWORD PTR [r11]
	movsxd	rcx, ecx
	cvtdq2pd xmm1, xmm1
	mulsd	xmm0, xmm4
	mulsd	xmm1, xmm5
	addsd	xmm2, xmm0
	addsd	xmm2, xmm1
	divsd	xmm2, xmm6
	cvttsd2si edx, xmm2
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR [r9+12]
	cmp	r10d, eax
	jl	$LL7@vc_rgb_gra
$LN2@vc_rgb_gra:

; 419  : 	int pos, posAux, x, y;
; 420  : 	for (x = 0; x < original->width; x++)

	inc	r8d
	cmp	r8d, DWORD PTR [r9+8]
	jl	$LL4@vc_rgb_gra

; 427  : 		}
; 428  : 	}
; 429  : 
; 430  : 	return 0;

	movaps	xmm6, XMMWORD PTR [rsp]
$LN18@vc_rgb_gra:

; 431  : }

	xor	eax, eax
	add	rsp, 24
	ret	0
vc_rgb_gray ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_trab_detect
_TEXT	SEGMENT
original$ = 80
vc_trab_detect PROC					; COMDAT

; 1766 : {

$LN56:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 1767 : 
; 1768 : 	//VARS
; 1769 : 	int x, y, pos;
; 1770 : 	int yMax = -1;
; 1771 : 	int maxTrans = 0, aux = 0;
; 1772 : 	int check = 0;
; 1773 : 	check = original->data[0];
; 1774 : 
; 1775 : 	IVC *temp = vc_image_new(original->width, original->height, 1, 255);

	mov	r15d, DWORD PTR [rcx+12]
	mov	rbx, rcx
	mov	r14d, DWORD PTR [rcx+8]
	mov	ebp, -1
	xor	edi, edi
	mov	r12d, edi

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	lea	ecx, QWORD PTR [rbp+33]
	call	QWORD PTR __imp_malloc
	mov	rsi, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	je	SHORT $LN54@vc_trab_de

; 41   : 		return NULL;
; 42   : 	if ((levels <= 0) || (levels > 255))
; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rax+8], r14d

; 46   : 	image->height = height;
; 47   : 	image->channels = channels;
; 48   : 	image->levels = levels;
; 49   : 	image->bytesperline = image->width * image->channels;

	mov	DWORD PTR [rax+24], r14d

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	r14d, r15d
	mov	DWORD PTR [rax+12], r15d
	mov	DWORD PTR [rax+16], 1
	mov	DWORD PTR [rax+20], 255			; 000000ffH
	movsxd	rcx, r14d
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rsi], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN23@vc_trab_de

; 71   : 		free(image);

	mov	rcx, rsi
	call	QWORD PTR __imp_free
$LN54@vc_trab_de:

; 1776 : 
; 1777 : 	//Calcula linha com maior numero de transições
; 1778 : 	for (y = 0; y < original->height; y++)

	mov	rsi, rdi
$LN23@vc_trab_de:
	mov	r14d, edi
	cmp	DWORD PTR [rbx+12], edi
	jle	$LN3@vc_trab_de

; 1779 : 	{
; 1780 : 		aux = 0;
; 1781 : 		check = original->data[(y * original->width) + 0];

	mov	r15d, DWORD PTR [rbx+8]
	mov	QWORD PTR [rsp+80], r13
	mov	r13, QWORD PTR [rbx]
	npad	1
$LL4@vc_trab_de:
	mov	ecx, r15d
	mov	r8d, edi
	imul	ecx, r14d
	movsxd	rax, ecx
	movzx	r9d, BYTE PTR [rax+r13]

; 1782 : 		for (x = 1; x < original->width; x++)

	cmp	r15d, 1
	jle	SHORT $LN6@vc_trab_de

; 1783 : 		{
; 1784 : 			//pos = y * original->bytesperline + x * original->channels;
; 1785 : 			if (check != original->data[(y * original->width) + x])

	movsxd	rax, ecx
	lea	r10, QWORD PTR [r13+1]
	add	r10, rax
	lea	r11d, DWORD PTR [r15-1]
	npad	10
$LL37@vc_trab_de:
	movzx	ecx, BYTE PTR [r10]
	lea	eax, DWORD PTR [r8+1]
	cmp	r9d, ecx
	lea	r10, QWORD PTR [r10+1]
	mov	edx, r9d
	mov	r9d, ecx
	cmove	eax, r8d
	cmp	edx, ecx
	mov	r8d, eax
	cmove	r9d, edx
	sub	r11, 1
	jne	SHORT $LL37@vc_trab_de
$LN6@vc_trab_de:

; 1776 : 
; 1777 : 	//Calcula linha com maior numero de transições
; 1778 : 	for (y = 0; y < original->height; y++)

	cmp	r8d, r12d
	mov	eax, r14d
	cmovle	eax, ebp
	inc	r14d
	cmp	r8d, r12d
	mov	ebp, eax
	cmovle	r8d, r12d
	mov	r12d, r8d
	cmp	r14d, DWORD PTR [rbx+12]
	jl	SHORT $LL4@vc_trab_de
	mov	r13, QWORD PTR [rsp+80]
	npad	5
$LL10@vc_trab_de:

; 1800 : 	{
; 1801 : 		for (x = 1; x < original->width; x++)

	mov	edx, 1
	cmp	DWORD PTR [rbx+8], edx
	jle	SHORT $LN8@vc_trab_de
	npad	6
$LL13@vc_trab_de:

; 1802 : 		{
; 1803 : 			pos = y * original->bytesperline + x * original->channels;

	mov	ecx, DWORD PTR [rbx+16]
	mov	eax, DWORD PTR [rbx+24]
	imul	ecx, edx
	imul	eax, edi
	add	ecx, eax
	movsxd	r8, ecx
	mov	rcx, QWORD PTR [rsi]

; 1804 : 			if (y == yMax)

	cmp	edi, ebp
	jne	SHORT $LN16@vc_trab_de

; 1805 : 				temp->data[pos] = 127;

	mov	al, 127					; 0000007fH
	jmp	SHORT $LN11@vc_trab_de
$LN16@vc_trab_de:

; 1806 : 			else
; 1807 : 				temp->data[pos] = original->data[pos];

	mov	rax, QWORD PTR [rbx]
	movzx	eax, BYTE PTR [r8+rax]
$LN11@vc_trab_de:

; 1800 : 	{
; 1801 : 		for (x = 1; x < original->width; x++)

	inc	edx
	mov	BYTE PTR [rcx+r8], al
	cmp	edx, DWORD PTR [rbx+8]
	jl	SHORT $LL13@vc_trab_de
$LN8@vc_trab_de:

; 1786 : 			{
; 1787 : 				check = original->data[(y * original->width) + x];
; 1788 : 				aux++;
; 1789 : 			}
; 1790 : 		}
; 1791 : 		if (aux > maxTrans)
; 1792 : 		{
; 1793 : 			maxTrans = aux;
; 1794 : 			yMax = y;
; 1795 : 		}
; 1796 : 	}
; 1797 : 
; 1798 : 	//Pinta na imagem uma linha no Y encontrado
; 1799 : 	for (y = 0; y < original->height; y++)

	inc	edi
	cmp	edi, DWORD PTR [rbx+12]
	jl	SHORT $LL10@vc_trab_de
$LN3@vc_trab_de:

; 1808 : 		}
; 1809 : 	}
; 1810 : 	//save("fase1_detect.pgm", temp);
; 1811 : 	//vc_write_image(aux, temp);
; 1812 : 	return yMax;
; 1813 : }

	mov	rbx, QWORD PTR [rsp+88]
	mov	eax, ebp
	mov	rbp, QWORD PTR [rsp+96]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
vc_trab_detect ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_trab_fase2
_TEXT	SEGMENT
nLabels$ = 32
max$1$ = 36
original$ = 128
license$ = 136
detected_line$ = 144
index$1$ = 152
vc_trab_fase2 PROC					; COMDAT

; 1412 : {

$LN110:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 56					; 00000038H

; 1413 : 
; 1414 : 	//VARS
; 1415 : 	IVC *prewitt, *filter, *clean, *img;
; 1416 : 	int nLabels = 0, max = 0, index = -1, i = 0;
; 1417 : 	int x, y, pos;
; 1418 : 
; 1419 : 	//Inicialize
; 1420 : 	img = vc_image_new(original->width, original->height, 1, 255);

	mov	ebp, DWORD PTR [rcx+12]
	xor	r13d, r13d
	mov	esi, DWORD PTR [rcx+8]
	mov	rdi, rcx
	mov	r15, rdx
	mov	DWORD PTR nLabels$[rsp], r13d
	mov	DWORD PTR max$1$[rsp], r13d

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	lea	ecx, QWORD PTR [r13+32]
	call	QWORD PTR __imp_malloc
	mov	rbx, rax

; 39   : 
; 40   : 	if (image == NULL)

	mov	r12d, 255				; 000000ffH
	test	rax, rax
	je	SHORT $LN106@vc_trab_fa

; 42   : 	if ((levels <= 0) || (levels > 255))
; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rax+8], esi

; 46   : 	image->height = height;
; 47   : 	image->channels = channels;
; 48   : 	image->levels = levels;
; 49   : 	image->bytesperline = image->width * image->channels;

	mov	DWORD PTR [rax+24], esi

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	esi, ebp
	mov	DWORD PTR [rax+12], ebp
	mov	DWORD PTR [rax+16], 1
	mov	DWORD PTR [rax+20], r12d
	movsxd	rcx, esi
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rbx], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN21@vc_trab_fa

; 71   : 		free(image);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN106@vc_trab_fa:

; 1421 : 	clean = vc_image_new(original->width, original->height, 1, 255);

	mov	rbx, r13
$LN21@vc_trab_fa:
	mov	r14d, DWORD PTR [rdi+12]

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H

; 1421 : 	clean = vc_image_new(original->width, original->height, 1, 255);

	mov	ebp, DWORD PTR [rdi+8]

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	call	QWORD PTR __imp_malloc
	mov	rsi, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	je	SHORT $LN107@vc_trab_fa

; 42   : 	if ((levels <= 0) || (levels > 255))
; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rax+8], ebp

; 46   : 	image->height = height;
; 47   : 	image->channels = channels;
; 48   : 	image->levels = levels;
; 49   : 	image->bytesperline = image->width * image->channels;

	mov	DWORD PTR [rax+24], ebp

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	ebp, r14d
	mov	DWORD PTR [rax+12], r14d
	mov	DWORD PTR [rax+16], 1
	mov	DWORD PTR [rax+20], r12d
	movsxd	rcx, ebp
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rsi], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN31@vc_trab_fa

; 71   : 		free(image);

	mov	rcx, rsi
	call	QWORD PTR __imp_free
$LN107@vc_trab_fa:

; 1422 : 	prewitt = vc_image_new(original->width, original->height, 1, 255);

	mov	rsi, r13
$LN31@vc_trab_fa:
	mov	r14d, DWORD PTR [rdi+12]

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H

; 1422 : 	prewitt = vc_image_new(original->width, original->height, 1, 255);

	mov	ebp, DWORD PTR [rdi+8]

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	call	QWORD PTR __imp_malloc
	mov	r13, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	je	SHORT $LN108@vc_trab_fa

; 42   : 	if ((levels <= 0) || (levels > 255))
; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rax+8], ebp

; 46   : 	image->height = height;
; 47   : 	image->channels = channels;
; 48   : 	image->levels = levels;
; 49   : 	image->bytesperline = image->width * image->channels;

	mov	DWORD PTR [rax+24], ebp

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	ebp, r14d
	mov	DWORD PTR [rax+12], r14d
	mov	DWORD PTR [rax+16], 1
	mov	DWORD PTR [rax+20], r12d
	movsxd	rcx, ebp
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r13], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN41@vc_trab_fa

; 71   : 		free(image);

	mov	rcx, r13
	call	QWORD PTR __imp_free
$LN108@vc_trab_fa:

; 1423 : 	filter = vc_image_new(original->width, original->height, 1, 255);

	xor	r13d, r13d
$LN41@vc_trab_fa:
	mov	r14d, DWORD PTR [rdi+12]

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H

; 1423 : 	filter = vc_image_new(original->width, original->height, 1, 255);

	mov	ebp, DWORD PTR [rdi+8]

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	call	QWORD PTR __imp_malloc
	mov	r12, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	jne	SHORT $LN48@vc_trab_fa

; 41   : 		return NULL;

	xor	r14d, r14d
	mov	r12d, r14d
	jmp	SHORT $LN47@vc_trab_fa
$LN48@vc_trab_fa:

; 42   : 	if ((levels <= 0) || (levels > 255))
; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rax+8], ebp

; 46   : 	image->height = height;
; 47   : 	image->channels = channels;
; 48   : 	image->levels = levels;
; 49   : 	image->bytesperline = image->width * image->channels;

	mov	DWORD PTR [rax+24], ebp

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	ebp, r14d
	mov	DWORD PTR [rax+12], r14d
	mov	DWORD PTR [rax+16], 1
	mov	DWORD PTR [rax+20], 255			; 000000ffH
	movsxd	rcx, ebp
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r12], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN51@vc_trab_fa

; 71   : 		free(image);

	mov	rcx, r12
	call	QWORD PTR __imp_free

; 54   : 		return vc_image_free(image);

	xor	r14d, r14d
	mov	r12d, r14d
	jmp	SHORT $LN47@vc_trab_fa
$LN51@vc_trab_fa:

; 55   : 	}
; 56   : 
; 57   : 	return image;

	xor	r14d, r14d
$LN47@vc_trab_fa:

; 1424 : 	memcpy(img->data, original->data, original->bytesperline * original->height);

	mov	eax, DWORD PTR [rdi+24]
	imul	eax, DWORD PTR [rdi+12]
	mov	rdx, QWORD PTR [rdi]
	mov	rcx, QWORD PTR [rbx]
	movsxd	r8, eax
	call	memcpy

; 1394 : 	int aux = original->height * percent;

	mov	edx, DWORD PTR [rbx+12]

; 1397 : 
; 1398 : 	for (y = 0; y < original->height; y++)

	mov	r9d, r14d
	mov	ebp, DWORD PTR detected_line$[rsp]
	mov	eax, ebp
	movd	xmm0, edx

; 72   : 		image = NULL;
; 73   : 	}
; 74   : 
; 75   : 	return image;
; 76   : }
; 77   : 
; 78   : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; 79   : //    FUN��ES: LEITURA E ESCRITA DE IMAGENS (PBM, PGM E PPM)
; 80   : //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; 81   : 
; 82   : char *netpbm_get_token(FILE *file, char *tok, int len)
; 83   : {
; 84   : 	char *t;
; 85   : 	int c;
; 86   : 
; 87   : 	for (;;)
; 88   : 	{
; 89   : 		while (isspace(c = getc(file)))
; 90   : 			;
; 91   : 		if (c != '#')
; 92   : 			break;
; 93   : 		do
; 94   : 			c = getc(file);
; 95   : 		while ((c != '\n') && (c != EOF));
; 96   : 		if (c == EOF)
; 97   : 			break;
; 98   : 	}
; 99   : 
; 100  : 	t = tok;
; 101  : 
; 102  : 	if (c != EOF)
; 103  : 	{
; 104  : 		do
; 105  : 		{
; 106  : 			*t++ = c;
; 107  : 			c = getc(file);
; 108  : 		} while ((!isspace(c)) && (c != '#') && (c != EOF) && (t - tok < len - 1));
; 109  : 
; 110  : 		if (c == '#')
; 111  : 			ungetc(c, file);
; 112  : 	}
; 113  : 
; 114  : 	*t = 0;
; 115  : 
; 116  : 	return tok;
; 117  : }
; 118  : 
; 119  : long int unsigned_char_to_bit(unsigned char *datauchar, unsigned char *databit, int width, int height)
; 120  : {
; 121  : 	int x, y;
; 122  : 	int countbits;
; 123  : 	long int pos, counttotalbytes;
; 124  : 	unsigned char *p = databit;
; 125  : 
; 126  : 	*p = 0;
; 127  : 	countbits = 1;
; 128  : 	counttotalbytes = 0;
; 129  : 
; 130  : 	for (y = 0; y < height; y++)
; 131  : 	{
; 132  : 		for (x = 0; x < width; x++)
; 133  : 		{
; 134  : 			pos = width * y + x;
; 135  : 
; 136  : 			if (countbits <= 8)
; 137  : 			{
; 138  : 				// Numa imagem PBM:
; 139  : 				// 1 = Preto
; 140  : 				// 0 = Branco
; 141  : 				//*p |= (datauchar[pos] != 0) << (8 - countbits);
; 142  : 
; 143  : 				// Na nossa imagem:
; 144  : 				// 1 = Branco
; 145  : 				// 0 = Preto
; 146  : 				*p |= (datauchar[pos] == 0) << (8 - countbits);
; 147  : 
; 148  : 				countbits++;
; 149  : 			}
; 150  : 			if ((countbits > 8) || (x == width - 1))
; 151  : 			{
; 152  : 				p++;
; 153  : 				*p = 0;
; 154  : 				countbits = 1;
; 155  : 				counttotalbytes++;
; 156  : 			}
; 157  : 		}
; 158  : 	}
; 159  : 
; 160  : 	return counttotalbytes;
; 161  : }
; 162  : 
; 163  : void bit_to_unsigned_char(unsigned char *databit, unsigned char *datauchar, int width, int height)
; 164  : {
; 165  : 	int x, y;
; 166  : 	int countbits;
; 167  : 	long int pos;
; 168  : 	unsigned char *p = databit;
; 169  : 
; 170  : 	countbits = 1;
; 171  : 
; 172  : 	for (y = 0; y < height; y++)
; 173  : 	{
; 174  : 		for (x = 0; x < width; x++)
; 175  : 		{
; 176  : 			pos = width * y + x;
; 177  : 
; 178  : 			if (countbits <= 8)
; 179  : 			{
; 180  : 				// Numa imagem PBM:
; 181  : 				// 1 = Preto
; 182  : 				// 0 = Branco
; 183  : 				//datauchar[pos] = (*p & (1 << (8 - countbits))) ? 1 : 0;
; 184  : 
; 185  : 				// Na nossa imagem:
; 186  : 				// 1 = Branco
; 187  : 				// 0 = Preto
; 188  : 				datauchar[pos] = (*p & (1 << (8 - countbits))) ? 0 : 1;
; 189  : 
; 190  : 				countbits++;
; 191  : 			}
; 192  : 			if ((countbits > 8) || (x == width - 1))
; 193  : 			{
; 194  : 				p++;
; 195  : 				countbits = 1;
; 196  : 			}
; 197  : 		}
; 198  : 	}
; 199  : }
; 200  : 
; 201  : IVC *vc_read_image(char *filename)
; 202  : {
; 203  : 	FILE *file = NULL;
; 204  : 	IVC *image = NULL;
; 205  : 	unsigned char *tmp;
; 206  : 	char tok[20];
; 207  : 	long int size, sizeofbinarydata;
; 208  : 	int width, height, channels;
; 209  : 	int levels = 255;
; 210  : 	int v;
; 211  : 
; 212  : 	// Abre o ficheiro
; 213  : 	if ((file = fopen(filename, "rb")) != NULL)
; 214  : 	{
; 215  : 		// Efectua a leitura do header
; 216  : 		netpbm_get_token(file, tok, sizeof(tok));
; 217  : 
; 218  : 		if (strcmp(tok, "P4") == 0)
; 219  : 		{
; 220  : 			channels = 1;
; 221  : 			levels = 1;
; 222  : 		} // Se PBM (Binary [0,1])
; 223  : 		else if (strcmp(tok, "P5") == 0)
; 224  : 			channels = 1; // Se PGM (Gray [0,MAX(level,255)])
; 225  : 		else if (strcmp(tok, "P6") == 0)
; 226  : 			channels = 3; // Se PPM (RGB [0,MAX(level,255)])
; 227  : 		else
; 228  : 		{
; 229  : #ifdef VC_DEBUG
; 230  : 			printf("ERROR -> vc_read_image():\n\tFile is not a valid PBM, PGM or PPM file.\n\tBad magic number!\n");
; 231  : #endif
; 232  : 
; 233  : 			fclose(file);
; 234  : 			return NULL;
; 235  : 		}
; 236  : 
; 237  : 		if (levels == 1) // PBM
; 238  : 		{
; 239  : 			if (sscanf(netpbm_get_token(file, tok, sizeof(tok)), "%d", &width) != 1 ||
; 240  : 				sscanf(netpbm_get_token(file, tok, sizeof(tok)), "%d", &height) != 1)
; 241  : 			{
; 242  : #ifdef VC_DEBUG
; 243  : 				printf("ERROR -> vc_read_image():\n\tFile is not a valid PBM file.\n\tBad size!\n");
; 244  : #endif
; 245  : 
; 246  : 				fclose(file);
; 247  : 				return NULL;
; 248  : 			}
; 249  : 
; 250  : 			// Aloca mem�ria para imagem
; 251  : 			image = vc_image_new(width, height, channels, levels);
; 252  : 			if (image == NULL)
; 253  : 				return NULL;
; 254  : 
; 255  : 			sizeofbinarydata = (image->width / 8 + ((image->width % 8) ? 1 : 0)) * image->height;
; 256  : 			tmp = (unsigned char *)malloc(sizeofbinarydata);
; 257  : 			if (tmp == NULL)
; 258  : 				return 0;
; 259  : 
; 260  : #ifdef VC_DEBUG
; 261  : 			printf("============================== IMAGEM ABERTA ==================================\n");
; 262  : 			printf("Imagem: %d x %d | Channels: %d | Levels: %d\n", image->width, image->height, image->channels, image->levels);
; 263  : 			printf("Localização: %s", filename);
; 264  : 			printf("\n===============================================================================\n\n");
; 265  : #endif
; 266  : 
; 267  : 			if ((v = fread(tmp, sizeof(unsigned char), sizeofbinarydata, file)) != sizeofbinarydata)
; 268  : 			{
; 269  : #ifdef VC_DEBUG
; 270  : 				printf("ERROR -> vc_read_image():\n\tPremature EOF on file.\n");
; 271  : #endif
; 272  : 
; 273  : 				vc_image_free(image);
; 274  : 				fclose(file);
; 275  : 				free(tmp);
; 276  : 				return NULL;
; 277  : 			}
; 278  : 
; 279  : 			bit_to_unsigned_char(tmp, image->data, image->width, image->height);
; 280  : 
; 281  : 			free(tmp);
; 282  : 		}
; 283  : 		else // PGM ou PPM
; 284  : 		{
; 285  : 			if (sscanf(netpbm_get_token(file, tok, sizeof(tok)), "%d", &width) != 1 ||
; 286  : 				sscanf(netpbm_get_token(file, tok, sizeof(tok)), "%d", &height) != 1 ||
; 287  : 				sscanf(netpbm_get_token(file, tok, sizeof(tok)), "%d", &levels) != 1 || levels <= 0 || levels > 255)
; 288  : 			{
; 289  : #ifdef VC_DEBUG
; 290  : 				printf("ERROR -> vc_read_image():\n\tFile is not a valid PGM or PPM file.\n\tBad size!\n");
; 291  : #endif
; 292  : 
; 293  : 				fclose(file);
; 294  : 				return NULL;
; 295  : 			}
; 296  : 
; 297  : 			// Aloca mem�ria para imagem
; 298  : 			image = vc_image_new(width, height, channels, levels);
; 299  : 			if (image == NULL)
; 300  : 				return NULL;
; 301  : 
; 302  : #ifdef VC_DEBUG
; 303  : 			printf("============================== IMAGEM ABERTA ==================================\n");
; 304  : 			printf("Imagem: %d x %d | Channels: %d | Levels: %d\n", image->width, image->height, image->channels, image->levels);
; 305  : 			printf("Localização: %s", filename);
; 306  : 			printf("\n===============================================================================\n\n");
; 307  : #endif
; 308  : 
; 309  : 			size = image->width * image->height * image->channels;
; 310  : 
; 311  : 			if ((v = fread(image->data, sizeof(unsigned char), size, file)) != size)
; 312  : 			{
; 313  : #ifdef VC_DEBUG
; 314  : 				printf("ERROR -> vc_read_image():\n\tPremature EOF on file.\n");
; 315  : #endif
; 316  : 
; 317  : 				vc_image_free(image);
; 318  : 				fclose(file);
; 319  : 				return NULL;
; 320  : 			}
; 321  : 		}
; 322  : 
; 323  : 		fclose(file);
; 324  : 	}
; 325  : 	else
; 326  : 	{
; 327  : #ifdef VC_DEBUG
; 328  : 		printf("ERROR -> vc_read_image():\n\tFile not found.\n");
; 329  : #endif
; 330  : 	}
; 331  : 
; 332  : 	return image;
; 333  : }
; 334  : 
; 335  : int vc_write_image(char *filename, IVC *image)
; 336  : {
; 337  : 	FILE *file = NULL;
; 338  : 	unsigned char *tmp;
; 339  : 	long int totalbytes, sizeofbinarydata;
; 340  : 
; 341  : 	if (image == NULL)
; 342  : 		return 0;
; 343  : 
; 344  : 	if ((file = fopen(filename, "wb")) != NULL)
; 345  : 	{
; 346  : 		if (image->levels == 1)
; 347  : 		{
; 348  : 			sizeofbinarydata = (image->width / 8 + ((image->width % 8) ? 1 : 0)) * image->height + 1;
; 349  : 			tmp = (unsigned char *)malloc(sizeofbinarydata);
; 350  : 			if (tmp == NULL)
; 351  : 				return 0;
; 352  : 
; 353  : 			fprintf(file, "%s %d %d\n", "P4", image->width, image->height);
; 354  : 
; 355  : 			totalbytes = unsigned_char_to_bit(image->data, tmp, image->width, image->height);
; 356  : 			printf("Total = %ld\n", totalbytes);
; 357  : 			if (fwrite(tmp, sizeof(unsigned char), totalbytes, file) != totalbytes)
; 358  : 			{
; 359  : #ifdef VC_DEBUG
; 360  : 				fprintf(stderr, "ERROR -> vc_read_image():\n\tError writing PBM, PGM or PPM file.\n");
; 361  : #endif
; 362  : 
; 363  : 				fclose(file);
; 364  : 				free(tmp);
; 365  : 				return 0;
; 366  : 			}
; 367  : 
; 368  : 			free(tmp);
; 369  : 		}
; 370  : 		else
; 371  : 		{
; 372  : 			fprintf(file, "%s %d %d 255\n", (image->channels == 1) ? "P5" : "P6", image->width, image->height);
; 373  : 
; 374  : 			if (fwrite(image->data, image->bytesperline, image->height, file) != image->height)
; 375  : 			{
; 376  : #ifdef VC_DEBUG
; 377  : 				fprintf(stderr, "ERROR -> vc_read_image():\n\tError writing PBM, PGM or PPM file.\n");
; 378  : #endif
; 379  : 
; 380  : 				fclose(file);
; 381  : 				return 0;
; 382  : 			}
; 383  : 		}
; 384  : 		printf("============================== IMAGEM GERADA ==================================\n");
; 385  : 		printf("Imagem: %d x %d | Channels: %d | Levels: %d\n", image->width, image->height, image->channels, image->levels);
; 386  : 		printf("Localização: %s\n", filename);
; 387  : 		printf("===============================================================================\n\n");
; 388  : 		fclose(file);
; 389  : 
; 390  : 		return 1;
; 391  : 	}
; 392  : 
; 393  : 	return 0;
; 394  : }
; 395  : 
; 396  : #pragma endregion
; 397  : 
; 398  : #pragma region Save and Run
; 399  : 
; 400  : char *conc(const char *first, char *second)
; 401  : {
; 402  : 	char *aux = _strdup(first);
; 403  : 	strcat(aux, second);
; 404  : 	return aux;
; 405  : }
; 406  : 
; 407  : void save(char *filename, IVC *image)
; 408  : {
; 409  : 	char *filepath = conc(results, filename);
; 410  : 	vc_write_image(filepath, image);
; 411  : }
; 412  : 
; 413  : #pragma endregion
; 414  : 
; 415  : #pragma region RGB to GRAY
; 416  : 
; 417  : int vc_rgb_gray(IVC *original, IVC *converted)
; 418  : {
; 419  : 	int pos, posAux, x, y;
; 420  : 	for (x = 0; x < original->width; x++)
; 421  : 	{
; 422  : 		for (y = 0; y < original->height; y++)
; 423  : 		{
; 424  : 			pos = y * original->bytesperline + x * original->channels;
; 425  : 			posAux = y * converted->bytesperline + x * converted->channels;
; 426  : 			converted->data[posAux] = ((0.3 * original->data[pos] + 0.59 * original->data[pos + 1] + 0.11 * original->data[pos + 2]) / 3);
; 427  : 		}
; 428  : 	}
; 429  : 
; 430  : 	return 0;
; 431  : }
; 432  : 
; 433  : #pragma endregion
; 434  : 
; 435  : #pragma region Manuseamento de channels
; 436  : 
; 437  : int vc_only_red(IVC *original, IVC *converted)
; 438  : {
; 439  : 	int pos, x, y;
; 440  : 
; 441  : 	for (x = 0; x < original->width; x++)
; 442  : 	{
; 443  : 		for (y = 0; y < original->height; y++)
; 444  : 		{
; 445  : 			pos = y * original->bytesperline + x * original->channels;
; 446  : 			converted->data[pos] = original->data[pos];
; 447  : 			converted->data[pos + 1] = original->data[pos];
; 448  : 			converted->data[pos + 2] = original->data[pos];
; 449  : 		}
; 450  : 	}
; 451  : 
; 452  : 	return 0;
; 453  : }
; 454  : 
; 455  : int vc_only_green(IVC *original, IVC *converted)
; 456  : {
; 457  : 	int pos, x, y;
; 458  : 
; 459  : 	for (x = 0; x < original->width; x++)
; 460  : 	{
; 461  : 		for (y = 0; y < original->height; y++)
; 462  : 		{
; 463  : 			pos = y * original->bytesperline + x * original->channels;
; 464  : 			converted->data[pos + 1] = original->data[pos + 1];
; 465  : 			converted->data[pos] = 0;
; 466  : 			converted->data[pos + 2] = 0;
; 467  : 		}
; 468  : 	}
; 469  : 
; 470  : 	return 0;
; 471  : }
; 472  : 
; 473  : int vc_only_blue(IVC *original, IVC *converted)
; 474  : {
; 475  : 	int pos, x, y;
; 476  : 
; 477  : 	for (x = 0; x < original->width; x++)
; 478  : 	{
; 479  : 		for (y = 0; y < original->height; y++)
; 480  : 		{
; 481  : 			pos = y * original->bytesperline + x * original->channels;
; 482  : 			converted->data[pos + 2] = original->data[pos + 2];
; 483  : 			converted->data[pos + 1] = 0;
; 484  : 			converted->data[pos] = 0;
; 485  : 		}
; 486  : 	}
; 487  : 
; 488  : 	return 0;
; 489  : }
; 490  : 
; 491  : int vc_remove_red(IVC *original, IVC *converted)
; 492  : {
; 493  : 	int pos, x, y;
; 494  : 
; 495  : 	for (x = 0; x < original->width; x++)
; 496  : 	{
; 497  : 		for (y = 0; y < original->height; y++)
; 498  : 		{
; 499  : 			pos = y * original->bytesperline + x * original->channels;
; 500  : 
; 501  : 			converted->data[pos] = 0;
; 502  : 			converted->data[pos + 1] = original->data[pos + 1];
; 503  : 			converted->data[pos + 2] = original->data[pos + 2];
; 504  : 		}
; 505  : 	}
; 506  : 	return 0;
; 507  : }
; 508  : 
; 509  : int vc_remove_green(IVC *original, IVC *converted)
; 510  : {
; 511  : 	int pos, x, y;
; 512  : 
; 513  : 	for (x = 0; x < original->width; x++)
; 514  : 	{
; 515  : 		for (y = 0; y < original->height; y++)
; 516  : 		{
; 517  : 			pos = y * original->bytesperline + x * original->channels;
; 518  : 			converted->data[pos] = original->data[pos];
; 519  : 			converted->data[pos + 1] = 0;
; 520  : 			converted->data[pos + 2] = original->data[pos + 2];
; 521  : 		}
; 522  : 	}
; 523  : 	return 0;
; 524  : }
; 525  : 
; 526  : int vc_remove_blue(IVC *original, IVC *converted)
; 527  : {
; 528  : 	int pos, x, y;
; 529  : 
; 530  : 	for (x = 0; x < original->width; x++)
; 531  : 	{
; 532  : 		for (y = 0; y < original->height; y++)
; 533  : 		{
; 534  : 			pos = y * original->bytesperline + x * original->channels;
; 535  : 			converted->data[pos] = original->data[pos];
; 536  : 			converted->data[pos + 1] = original->data[pos + 1];
; 537  : 			converted->data[pos + 2] = 0;
; 538  : 		}
; 539  : 	}
; 540  : 
; 541  : 	return 0;
; 542  : }
; 543  : 
; 544  : #pragma endregion
; 545  : 
; 546  : #pragma region Binary
; 547  : 
; 548  : float vc_media(IVC *original)
; 549  : {
; 550  : 	int pos, x, y;
; 551  : 	float media = 0;
; 552  : 
; 553  : 	if (original->channels == 1)
; 554  : 	{
; 555  : 		for (x = 0; x < original->width; x++)
; 556  : 			for (y = 0; y < original->height; y++)
; 557  : 			{
; 558  : 				pos = y * original->bytesperline + x * original->channels;
; 559  : 				media += original->data[pos];
; 560  : 			}
; 561  : 	}
; 562  : 	else if (original->channels == 3)
; 563  : 	{
; 564  : 		for (x = 0; x < original->width; x++)
; 565  : 			for (y = 0; y < original->height; y++)
; 566  : 			{
; 567  : 				pos = y * original->bytesperline + x * original->channels;
; 568  : 				media += (original->data[pos] + original->data[pos + 1] + original->data[pos + 2]) / 3;
; 569  : 			}
; 570  : 	}
; 571  : 	return (media / (original->bytesperline * original->height));
; 572  : }
; 573  : 
; 574  : int vc_rgb_gray_to_binary_global_mean(IVC *original, IVC *converted)
; 575  : {
; 576  : 	int pos, posAux, x, y;
; 577  : 	float media = vc_media(original), meanAux = 0;
; 578  : 
; 579  : 	for (x = 0; x < original->width; x++)
; 580  : 	{
; 581  : 		for (y = 0; y < original->height; y++)
; 582  : 		{
; 583  : 			pos = y * original->bytesperline + x * original->channels;
; 584  : 			posAux = y * converted->bytesperline + x * converted->channels;
; 585  : 			meanAux = (original->channels == 1 ? original->data[pos] : (original->data[pos] + original->data[pos + 1] + original->data[pos + 2])) / original->channels;
; 586  : 			converted->data[posAux] = meanAux > media ? 255 : 0;
; 587  : 		}
; 588  : 	}
; 589  : 
; 590  : 	return 1;
; 591  : }
; 592  : 
; 593  : int vc_rgb_gray_to_binary(IVC *original, IVC *converted, int threshold)
; 594  : {
; 595  : 	int pos, posAux, x, y;
; 596  : 	float meanAux;
; 597  : 
; 598  : 	for (x = 0; x < original->width; x++)
; 599  : 	{
; 600  : 		for (y = 0; y < original->height; y++)
; 601  : 		{
; 602  : 			pos = y * original->bytesperline + x * original->channels;
; 603  : 			posAux = y * converted->bytesperline + x * converted->channels;
; 604  : 			meanAux = (original->channels == 1 ? original->data[pos] : (original->data[pos] + original->data[pos + 1] + original->data[pos + 2])) / original->channels;
; 605  : 			converted->data[posAux] = meanAux > threshold ? 255 : 0;
; 606  : 		}
; 607  : 	}
; 608  : 
; 609  : 	return 1;
; 610  : }
; 611  : 
; 612  : int vc_gray_to_binary_bernsen(IVC *original, IVC *converted, int kernel, int c)
; 613  : {
; 614  : 	long int pos, posk;
; 615  : 	float meanAux;
; 616  : 	int channels = original->channels, bytesperline = original->bytesperline;
; 617  : 	int offset = (kernel - 1) / 2;
; 618  : 	int x, kx, y, ky;
; 619  : 	int width = original->width, height = original->height;
; 620  : 	int max = 0, min = 255;
; 621  : 	float threshold;
; 622  : 	int count = 0;
; 623  : 
; 624  : 	if ((original->width <= 0) || (original->height <= 0) || (original->data == NULL))
; 625  : 		return 0;
; 626  : 	if ((original->width != converted->width) || (original->height != converted->height) || (original->channels != converted->channels))
; 627  : 		return 0;
; 628  : 	if (channels != 1)
; 629  : 		return 0;
; 630  : 
; 631  : 	for (y = 0; y < original->height; y++)
; 632  : 		for (x = 0; x < original->width; x++)
; 633  : 		{
; 634  : 			pos = y * original->bytesperline + x * original->channels;
; 635  : 			min = 255;
; 636  : 			max = 0;
; 637  : 			count = 0;
; 638  : 			//
; 639  : 			for (ky = -offset; ky <= offset; ky++)
; 640  : 				for (kx = -offset; kx <= offset; kx++)
; 641  : 				{
; 642  : 					if ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))
; 643  : 					{
; 644  : 						posk = (y + ky) * bytesperline + (x + kx) * channels;
; 645  : 
; 646  : 						if (original->data[posk] > max)
; 647  : 							max = original->data[posk];
; 648  : 						if (original->data[posk] < min)
; 649  : 							min = original->data[posk];
; 650  : 					}
; 651  : 				}
; 652  : 
; 653  : 			//
; 654  : 			if ((max - min) < c)
; 655  : 				threshold = 255 / 2;
; 656  : 			else
; 657  : 				threshold = (unsigned char)((float)(max + min) / (float)2);
; 658  : 
; 659  : 			if (original->data[pos] > threshold)
; 660  : 				converted->data[pos] = 255;
; 661  : 			else
; 662  : 				converted->data[pos] = 0;
; 663  : 		}
; 664  : 
; 665  : 	return 1;
; 666  : }
; 667  : 
; 668  : int vc_binary_dilate(IVC *original, IVC *converted, int kernel)
; 669  : {
; 670  : 	long int pos, posk;
; 671  : 	float meanAux;
; 672  : 	int channels = original->channels, bytesperline = original->bytesperline;
; 673  : 	int offset = (kernel - 1) / 2;
; 674  : 	int x, kx, y, ky;
; 675  : 	int width = original->width, height = original->height;
; 676  : 	float threshold;
; 677  : 
; 678  : 	if ((original->width <= 0) || (original->height <= 0) || (original->data == NULL))
; 679  : 		return 0;
; 680  : 	if ((original->width != converted->width) || (original->height != converted->height) || (original->channels != converted->channels))
; 681  : 		return 0;
; 682  : 	if (channels != 1)
; 683  : 		return 0;
; 684  : 
; 685  : 	for (y = 0; y < original->height; y++)
; 686  : 		for (x = 0; x < original->width; x++)
; 687  : 		{
; 688  : 			pos = y * original->bytesperline + x * original->channels;
; 689  : 			//
; 690  : 			converted->data[pos] = 0;
; 691  : 			for (ky = -offset; ky <= offset; ky++)
; 692  : 				for (kx = -offset; kx <= offset; kx++)
; 693  : 					if ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))
; 694  : 					{
; 695  : 						posk = (y + ky) * bytesperline + (x + kx) * channels;
; 696  : 						//
; 697  : 						if (original->data[posk] == 255)
; 698  : 							converted->data[pos] = 255;
; 699  : 					}
; 700  : 		}
; 701  : 
; 702  : 	return 1;
; 703  : }
; 704  : 
; 705  : int vc_binary_erode(IVC *original, IVC *converted, int kernel)
; 706  : {
; 707  : 	long int pos, posk;
; 708  : 	float meanAux;
; 709  : 	int channels = original->channels, bytesperline = original->bytesperline;
; 710  : 	int offset = (kernel - 1) / 2;
; 711  : 	int x, kx, y, ky;
; 712  : 	int width = original->width, height = original->height;
; 713  : 	float threshold;
; 714  : 
; 715  : 	if ((original->width <= 0) || (original->height <= 0) || (original->data == NULL))
; 716  : 		return 0;
; 717  : 	if ((original->width != converted->width) || (original->height != converted->height) || (original->channels != converted->channels))
; 718  : 		return 0;
; 719  : 	if (channels != 1)
; 720  : 		return 0;
; 721  : 
; 722  : 	for (y = 0; y < original->height; y++)
; 723  : 		for (x = 0; x < original->width; x++)
; 724  : 		{
; 725  : 			pos = y * original->bytesperline + x * original->channels;
; 726  : 			//
; 727  : 			converted->data[pos] = 255;
; 728  : 			for (ky = -offset; ky <= offset; ky++)
; 729  : 				for (kx = -offset; kx <= offset; kx++)
; 730  : 					if ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))
; 731  : 					{
; 732  : 						posk = (y + ky) * bytesperline + (x + kx) * channels;
; 733  : 						//
; 734  : 						if (original->data[posk] == 0)
; 735  : 							converted->data[pos] = 0;
; 736  : 					}
; 737  : 		}
; 738  : 
; 739  : 	return 1;
; 740  : }
; 741  : 
; 742  : int vc_binary_open(IVC *original, IVC *converted, int kernel)
; 743  : {
; 744  : 	IVC *temp;
; 745  : 	temp = vc_image_new(original->width, original->height, 1, 255);
; 746  : 
; 747  : 	//Erode
; 748  : 	vc_binary_erode(original, temp, kernel);
; 749  : 	//Dilate
; 750  : 	vc_binary_dilate(temp, converted, kernel);
; 751  : 
; 752  : 	return 1;
; 753  : }
; 754  : 
; 755  : int vc_binary_close(IVC *original, IVC *converted, int kernel)
; 756  : {
; 757  : 	IVC *temp;
; 758  : 	temp = vc_image_new(original->width, original->height, 1, 255);
; 759  : 
; 760  : 	//Dilate
; 761  : 	vc_binary_dilate(original, temp, kernel);
; 762  : 	//Erode
; 763  : 	vc_binary_erode(temp, converted, kernel);
; 764  : 
; 765  : 	return 1;
; 766  : }
; 767  : 
; 768  : #pragma endregion
; 769  : 
; 770  : #pragma region Labeling
; 771  : // Etiquetagem de blobs
; 772  : // src		: Imagem binaria de entrada
; 773  : // dst		: Imagem grayscale (ira conter as etiquetas)
; 774  : // nlabels	: Endereco de memoria de uma varievel, onde sera armazenado o numero de etiquetas encontradas.
; 775  : // OVC*		: Retorna um array de estruturas de blobs (objectos), com respectivas etiquetas. � necessario libertar posteriormente esta memoria.
; 776  : 
; 777  : int vc_binary_blob_info(IVC *src, OVC *blobs, int nblobs)
; 778  : {
; 779  : 	if (src)
; 780  : 		return -1;
; 781  : 
; 782  : 	unsigned char *data = (unsigned char *)src->data;
; 783  : 	int width = src->width;
; 784  : 	int height = src->height;
; 785  : 	int bytesperline = src->bytesperline;
; 786  : 	int channels = src->channels;
; 787  : 	int x, y, i;
; 788  : 	long int pos;
; 789  : 	int xmin, ymin, xmax, ymax;
; 790  : 	long int sumx, sumy;
; 791  : 
; 792  : 	// Verifica��o de erros
; 793  : 	if ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))
; 794  : 		return 0;
; 795  : 	if (channels != 1)
; 796  : 		return 0;
; 797  : 
; 798  : 	// Conta �rea de cada blob
; 799  : 	for (i = 0; i < nblobs; i++)
; 800  : 	{
; 801  : 		xmin = width - 1;
; 802  : 		ymin = height - 1;
; 803  : 		xmax = 0;
; 804  : 		ymax = 0;
; 805  : 
; 806  : 		sumx = 0;
; 807  : 		sumy = 0;
; 808  : 
; 809  : 		blobs[i].area = 0;
; 810  : 
; 811  : 		for (y = 1; y < height - 1; y++)
; 812  : 			for (x = 1; x < width - 1; x++)
; 813  : 			{
; 814  : 				pos = y * bytesperline + x * channels;
; 815  : 
; 816  : 				if (data[pos] == blobs[i].label)
; 817  : 				{
; 818  : 					// �rea
; 819  : 					blobs[i].area++;
; 820  : 
; 821  : 					// Centro de Gravidade
; 822  : 					sumx += x;
; 823  : 					sumy += y;
; 824  : 
; 825  : 					// Bounding Box
; 826  : 					if (xmin > x)
; 827  : 						xmin = x;
; 828  : 					if (ymin > y)
; 829  : 						ymin = y;
; 830  : 					if (xmax < x)
; 831  : 						xmax = x;
; 832  : 					if (ymax < y)
; 833  : 						ymax = y;
; 834  : 
; 835  : 					// Per�metro
; 836  : 					// Se pelo menos um dos quatro vizinhos n�o pertence ao mesmo label, ent�o � um pixel de contorno
; 837  : 					if ((data[pos - 1] != blobs[i].label) || (data[pos + 1] != blobs[i].label) || (data[pos - bytesperline] != blobs[i].label) || (data[pos + bytesperline] != blobs[i].label))
; 838  : 						blobs[i].perimeter++;
; 839  : 				}
; 840  : 			}
; 841  : 
; 842  : 		// Bounding Box
; 843  : 		blobs[i].x = xmin;
; 844  : 		blobs[i].y = ymin;
; 845  : 		blobs[i].width = (xmax - xmin) + 1;
; 846  : 		blobs[i].height = (ymax - ymin) + 1;
; 847  : 
; 848  : 		// Centro de Gravidade
; 849  : 		//blobs[i].xc = (xmax - xmin) / 2;
; 850  : 		//blobs[i].yc = (ymax - ymin) / 2;
; 851  : 		blobs[i].xc = sumx / MAX(blobs[i].area, 1);
; 852  : 		blobs[i].yc = sumy / MAX(blobs[i].area, 1);
; 853  : 	}
; 854  : 
; 855  : 	return 1;
; 856  : }
; 857  : 
; 858  : #pragma endregion
; 859  : 
; 860  : #pragma region Edge
; 861  : 
; 862  : // Detecção de contornos pelos operadores Prewitt
; 863  : int vc_gray_edge_prewitt(IVC *src, IVC *dst, float th) // th = [0.001, 1.000]
; 864  : {
; 865  : 	unsigned char *datasrc = (unsigned char *)src->data;
; 866  : 	unsigned char *datadst = (unsigned char *)dst->data;
; 867  : 	int width = src->width;
; 868  : 	int height = src->height;
; 869  : 	int bytesperline = src->bytesperline;
; 870  : 	int channels = src->channels;
; 871  : 	int x, y;
; 872  : 	long int posX, posA, posB, posC, posD, posE, posF, posG, posH;
; 873  : 	int i, size;
; 874  : 	int histmax, histthreshold;
; 875  : 	int sumx, sumy;
; 876  : 	int hist[256] = {0};
; 877  : 
; 878  : 	// Verificação de erros
; 879  : 	if ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))
; 880  : 		return 0;
; 881  : 	if ((src->width != dst->width) || (src->height != dst->height) || (src->channels != dst->channels))
; 882  : 		return 0;
; 883  : 	if (channels != 1)
; 884  : 		return 0;
; 885  : 
; 886  : 	size = width * height;
; 887  : 
; 888  : 	for (y = 1; y < height - 1; y++)
; 889  : 	{
; 890  : 		for (x = 1; x < width - 1; x++)
; 891  : 		{
; 892  : 			posA = (y - 1) * bytesperline + (x - 1) * channels;
; 893  : 			posB = (y - 1) * bytesperline + x * channels;
; 894  : 			posC = (y - 1) * bytesperline + (x + 1) * channels;
; 895  : 			posD = y * bytesperline + (x - 1) * channels;
; 896  : 			posX = y * bytesperline + x * channels;
; 897  : 			posE = y * bytesperline + (x + 1) * channels;
; 898  : 			posF = (y + 1) * bytesperline + (x - 1) * channels;
; 899  : 			posG = (y + 1) * bytesperline + x * channels;
; 900  : 			posH = (y + 1) * bytesperline + (x + 1) * channels;
; 901  : 
; 902  : 			sumx = datasrc[posA] * -1;
; 903  : 			sumx += datasrc[posD] * -1;
; 904  : 			sumx += datasrc[posF] * -1;
; 905  : 
; 906  : 			sumx += datasrc[posC] * +1;
; 907  : 			sumx += datasrc[posE] * +1;
; 908  : 			sumx += datasrc[posH] * +1;
; 909  : 			sumx = sumx / 3; // 3 = 1 + 1 + 1
; 910  : 
; 911  : 			sumy = datasrc[posA] * -1;
; 912  : 			sumy += datasrc[posB] * -1;
; 913  : 			sumy += datasrc[posC] * -1;
; 914  : 
; 915  : 			sumy += datasrc[posF] * +1;
; 916  : 			sumy += datasrc[posG] * +1;
; 917  : 			sumy += datasrc[posH] * +1;
; 918  : 			sumy = sumy / 3; // 3 = 1 + 1 + 1
; 919  : 
; 920  : 			datadst[posX] = (unsigned char)sqrt((double)(sumx * sumx + sumy * sumy));
; 921  : 		}
; 922  : 	}
; 923  : 
; 924  : 	// Compute a grey level histogram
; 925  : 	for (y = 0; y < height; y++)
; 926  : 	{
; 927  : 		for (x = 0; x < width; x++)
; 928  : 		{
; 929  : 			hist[datadst[y * bytesperline + x * channels]]++;
; 930  : 		}
; 931  : 	}
; 932  : 
; 933  : 	// Threshold at the middle of the occupied levels
; 934  : 	histmax = 0;
; 935  : 	for (i = 0; i <= 255; i++)
; 936  : 	{
; 937  : 		histmax += hist[i];
; 938  : 
; 939  : 		// th = Prewitt Threshold
; 940  : 		if (histmax >= (((float)size) * th))
; 941  : 			break;
; 942  : 	}
; 943  : 	histthreshold = i;
; 944  : 
; 945  : 	// Apply the threshold
; 946  : 	for (y = 0; y < height; y++)
; 947  : 		for (x = 0; x < width; x++)
; 948  : 		{
; 949  : 			posX = y * bytesperline + x * channels;
; 950  : 
; 951  : 			if (datadst[posX] >= histthreshold)
; 952  : 				datadst[posX] = 255;
; 953  : 			else
; 954  : 				datadst[posX] = 0;
; 955  : 		}
; 956  : 
; 957  : 	return 1;
; 958  : }
; 959  : 
; 960  : int vc_binary_edge_prewitt(IVC *src, IVC *dst, float th) // th = [0.001 a 1.000]
; 961  : {
; 962  : 
; 963  : 	unsigned char *datasrc = (unsigned char *)src->data;
; 964  : 	unsigned char *datadst = (unsigned char *)dst->data;
; 965  : 	int width = src->width;
; 966  : 	int height = src->height;
; 967  : 	int bytesperline = src->bytesperline;
; 968  : 	int channels = src->channels;
; 969  : 	int x, y;
; 970  : 	long int posX, posA, posB, posC, posD, posE, posF, posG, posH;
; 971  : 	int i, size;
; 972  : 	int histmax, histthreshold;
; 973  : 	int sumx, sumy;
; 974  : 	int hist[256] = {0};
; 975  : 
; 976  : 	IVC *dest = vc_image_new(dst->width, dst->height, dst->channels, dst->levels);
; 977  : 
; 978  : 	//verificao de erros
; 979  : 	if ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))
; 980  : 		return 0;
; 981  : 	if ((src->width != dst->width) || (src->height != dst->height))
; 982  : 		return 0;
; 983  : 	if ((src->channels != 1) || (dst->channels != 1))
; 984  : 		return 0;
; 985  : 
; 986  : 	size = width * height;
; 987  : 
; 988  : 	for (y = 1; y < height - 1; y++)
; 989  : 	{
; 990  : 		for (x = 1; x < width - 1; x++)
; 991  : 		{
; 992  : 			posA = (y - 1) * bytesperline + (x - 1) * channels;
; 993  : 			posB = (y - 1) * bytesperline + x * channels;
; 994  : 			posC = (y - 1) * bytesperline + (x + 1) * channels;
; 995  : 			posD = y * bytesperline + (x - 1) * channels;
; 996  : 			posX = y * bytesperline + x * channels;
; 997  : 			posE = y * bytesperline + (x + 1) * channels;
; 998  : 			posF = (y + 1) * bytesperline + (x - 1) * channels;
; 999  : 			posG = (y + 1) * bytesperline + x * channels;
; 1000 : 			posH = (y + 1) * bytesperline + (x + 1) * channels;
; 1001 : 
; 1002 : 			//         _______________________
; 1003 : 			//        |     |    |    |
; 1004 : 			//        | POS_A | POS_B | POS_C |
; 1005 : 			//        |  -1  |  -1  |  1  |
; 1006 : 			//        |_______|_______|_______|
; 1007 : 			//        |     |    |    |
; 1008 : 			//        | POS_D | POS_X | POS_E |
; 1009 : 			//        |  -1  |   0  |  1  |
; 1010 : 			//        |_______|_______|_______|
; 1011 : 			//        |     |    |    |
; 1012 : 			//        | POS_F | POS_G | POS_H |
; 1013 : 			//        |  -1  |   1  |  1  |
; 1014 : 			//        |_______|_______|_______|
; 1015 : 
; 1016 : 			// Convolução
; 1017 : 			sumx = datasrc[posA] * -1;
; 1018 : 			sumx += datasrc[posD] * -1;
; 1019 : 			sumx += datasrc[posF] * -1;
; 1020 : 
; 1021 : 			sumx += datasrc[posC] * +1;
; 1022 : 			sumx += datasrc[posE] * +1;
; 1023 : 			sumx += datasrc[posH] * +1;
; 1024 : 			sumx = sumx / 3; // 3 = 1 + 1 + 1
; 1025 : 			// magnitude = 3
; 1026 : 
; 1027 : 			sumy = datasrc[posA] * -1;
; 1028 : 			sumy += datasrc[posB] * -1;
; 1029 : 			sumy += datasrc[posC] * -1;
; 1030 : 
; 1031 : 			sumy += datasrc[posF] * +1;
; 1032 : 			sumy += datasrc[posG] * +1;
; 1033 : 			sumy += datasrc[posH] * +1;
; 1034 : 			sumy = sumy / 3; // 3 = 1 + 1 + 1
; 1035 : 			// magnitude = 3
; 1036 : 
; 1037 : 			// Calcular a magnitude do vector:
; 1038 : 			datadst[posX] = (unsigned char)sqrt((double)(sumx * sumx + sumy * sumy));
; 1039 : 			//datadst[posX] = (unsigned char) (sqrt((double) (sumx*sumx + sumy*sumy)) / 4.0);
; 1040 : 		}
; 1041 : 	}
; 1042 : 
; 1043 : 	// Compute a grey level histogram
; 1044 : 	for (y = 0; y < height; y++)
; 1045 : 	{
; 1046 : 		for (x = 0; x < width; x++)
; 1047 : 		{
; 1048 : 			hist[datadst[y * bytesperline + x * channels]]++;
; 1049 : 		}
; 1050 : 	}
; 1051 : 
; 1052 : 	// Threshold at the middle of the occupied levels
; 1053 : 	histmax = 0;
; 1054 : 	for (i = 0; i <= 255; i++)
; 1055 : 	{
; 1056 : 		histmax += hist[i];
; 1057 : 
; 1058 : 		// th = Prewitt Threshold
; 1059 : 		if (histmax >= (((float)size) * th))
; 1060 : 			break;
; 1061 : 	}
; 1062 : 	histthreshold = i;
; 1063 : 	//vc_gray_to_binary_bernsen(datadst, , <#int kernel#>, <#int c#>)
; 1064 : 
; 1065 : 	// Apply the threshold
; 1066 : 	for (y = 0; y < height; y++)
; 1067 : 	{
; 1068 : 		for (x = 0; x < width; x++)
; 1069 : 		{
; 1070 : 			posX = y * bytesperline + x * channels;
; 1071 : 
; 1072 : 			// Aplica threshold: -> Se a Magnitude(x,y) > th entao é pixel de contorno
; 1073 : 			// datadst[posX] = Magnitude  &&  histthreshold = th
; 1074 : 			if (datadst[posX] >= histthreshold)
; 1075 : 				datadst[posX] = 255;
; 1076 : 			else
; 1077 : 				datadst[posX] = 0;
; 1078 : 		}
; 1079 : 	}
; 1080 : 	return 1;
; 1081 : }
; 1082 : 
; 1083 : #pragma endregion
; 1084 : 
; 1085 : #pragma region Histograma
; 1086 : 
; 1087 : float* vc_histogram_array(IVC* original) {
; 1088 : 	//VARS
; 1089 : 	int pos, y, x, max = original->levels + 1, maior = 0;
; 1090 : 	float* array;
; 1091 : 
; 1092 : 	//Inicializa array
; 1093 : 	array = (float *)malloc(max);
; 1094 : 	array[0] = 0;
; 1095 : 	for (int i = 0; i < max; i++) array[i] = 0;
; 1096 : 
; 1097 : 	//Gera vetor do histogram
; 1098 : 	for (y = 0; y < original->height; y++)
; 1099 : 		for (x = 0; x < original->width; x++)
; 1100 : 		{
; 1101 : 			pos = y * original->bytesperline + x * original->channels;
; 1102 : 			if (original->data[pos] != 0)
; 1103 : 				array[original->data[pos]]++;
; 1104 : 		}
; 1105 : 
; 1106 : 	return array;
; 1107 : }
; 1108 : 
; 1109 : IVC* vc_gray_histogram_show(IVC* original) {
; 1110 : 	//VARS
; 1111 : 	int pos, y, x, max = original->levels + 1, maior = 0;
; 1112 : 	float* array;
; 1113 : 	int n = original->width * original->height;
; 1114 : 	IVC* converted;
; 1115 : 	converted = vc_image_new(255, 350, 1, 255);
; 1116 : 
; 1117 : 	array = vc_histogram_array(original);
; 1118 : 
; 1119 : 	//Calcular index com maior valor
; 1120 : 	for (int i = 1; i < max; i++) {
; 1121 : 		if (array[i] > maior) maior = array[i];
; 1122 : 	}
; 1123 : 
; 1124 : 	//coloca os valores entre 0-300
; 1125 : 	for (int i = 1; i < max; i++) {
; 1126 : 		array[i] = (array[i] * 300) / maior;
; 1127 : 	}
; 1128 : 	printf("0 : %d , 255 : %d\n", array[0], array[255]);
; 1129 : 
; 1130 : 	//Paint
; 1131 : 	for (y = 0; y < converted->height; y++)
; 1132 : 		for (x = 0; x < converted->width; x++)
; 1133 : 		{
; 1134 : 			pos = y * converted->bytesperline + x * converted->channels;
; 1135 : 			//Reset
; 1136 : 			converted->data[pos] = 0;
; 1137 : 
; 1138 : 			//Paint
; 1139 : 			if (y > 20 && y <= 320 && x <= 255) {
; 1140 : 				if ((320 - y) > array[x]) {
; 1141 : 					converted->data[pos] = 255;
; 1142 : 				}
; 1143 : 			}
; 1144 : 			else if (y > 320)
; 1145 : 				converted->data[pos] = x;
; 1146 : 			else
; 1147 : 				converted->data[pos] = 255;
; 1148 : 		}
; 1149 : 	return converted;
; 1150 : }
; 1151 : 
; 1152 : int vc_rgb_histogram_show(IVC* original, IVC* converted) {
; 1153 : 	//VARS
; 1154 : 	int pos, y, x, max = original->levels + 1, i;
; 1155 : 	float *r, *g, *b;
; 1156 : 	int maior_r, maior_g, maior_b;
; 1157 : 	int n = original->width * original->height;
; 1158 : 	r = (float*)malloc(max * sizeof(float));
; 1159 : 	g = (float*)malloc(max * sizeof(float));
; 1160 : 	b = (float*)malloc(max * sizeof(float));
; 1161 : 
; 1162 : 	//Inicializa array
; 1163 : 	r[0] = 0;
; 1164 : 	g[0] = 0;
; 1165 : 	b[0] = 0;
; 1166 : 	for (i = 1; i < max; i++) {
; 1167 : 		r[i] = 0;
; 1168 : 		g[i] = 0;
; 1169 : 		b[i] = 0;
; 1170 : 	}
; 1171 : 
; 1172 : 	//Gera vetor do histogram
; 1173 : 	for (y = 0; y < original->height; y++)
; 1174 : 		for (x = 0; x < original->width; x++)
; 1175 : 		{
; 1176 : 			pos = y * original->bytesperline + x * original->channels;
; 1177 : 			if (original->data[pos] != 0) r[original->data[pos]]++;
; 1178 : 			if (original->data[pos + 1] != 0) g[original->data[pos + 1]]++;
; 1179 : 			if (original->data[pos + 2] != 0) b[original->data[pos + 2]]++;
; 1180 : 		}
; 1181 : 
; 1182 : 	//Calcular index com maior valor
; 1183 : 	for (int i = 1; i < max; i++) {
; 1184 : 		if (r[i] > maior_r) maior_r = r[i];
; 1185 : 		if (g[i] > maior_g) maior_g = g[i];
; 1186 : 		if (b[i] > maior_b) maior_b = b[i];
; 1187 : 	}
; 1188 : 
; 1189 : 	//coloca os valores entre 0-300
; 1190 : 	for (i = 1; i < max; i++) {
; 1191 : 		r[i] = (r[i] * 300) / maior_r;
; 1192 : 		g[i] = (g[i] * 300) / maior_g;
; 1193 : 		b[i] = (b[i] * 300) / maior_b;
; 1194 : 	}
; 1195 : 
; 1196 : 	//Paint
; 1197 : 	for (y = 0; y < converted->height; y++)
; 1198 : 		for (x = 0; x < converted->width; x++)
; 1199 : 		{
; 1200 : 			pos = y * converted->bytesperline + x * converted->channels;
; 1201 : 
; 1202 : 			//Paint
; 1203 : 			//Red
; 1204 : 			if (x == 255 || x == 510) {
; 1205 : 				converted->data[pos] = 0;
; 1206 : 				converted->data[pos + 1] = 0;
; 1207 : 				converted->data[pos + 2] = 0;
; 1208 : 			}
; 1209 : 			else if (y <= 300 && x <= 255) {
; 1210 : 				if ((320 - y) > r[x]) {
; 1211 : 					converted->data[pos] = 255;
; 1212 : 					converted->data[pos + 1] = 255;
; 1213 : 					converted->data[pos + 2] = 255;
; 1214 : 				}
; 1215 : 			}
; 1216 : 			else if (y > 300 && x <= 255) { //Bottom
; 1217 : 				converted->data[pos] = x;
; 1218 : 				converted->data[pos + 1] = 0;
; 1219 : 				converted->data[pos + 2] = 0;
; 1220 : 			}
; 1221 : 
; 1222 : 			// Green
; 1223 : 			else if (y <= 300 && x > 255 && x <= 510) {
; 1224 : 				if ((320 - y) > g[x - 255] && x > 255 && x <= 510) {
; 1225 : 					converted->data[pos] = 255;
; 1226 : 					converted->data[pos + 1] = 255;
; 1227 : 					converted->data[pos + 2] = 255;
; 1228 : 				}
; 1229 : 			}
; 1230 : 			else if (y > 300 && x > 255 && x <= 510) { //Bottom
; 1231 : 				converted->data[pos] = 0;
; 1232 : 				converted->data[pos + 1] = x;
; 1233 : 				converted->data[pos + 2] = 0;
; 1234 : 			}
; 1235 : 
; 1236 : 			// Blue
; 1237 : 			else if (y <= 300 && x > 510 && x <= 765) {
; 1238 : 				if ((300 - y) > b[x - 510] && x > 510 && x <= 765) {
; 1239 : 					converted->data[pos] = 255;
; 1240 : 					converted->data[pos + 1] = 255;
; 1241 : 					converted->data[pos + 2] = 255;
; 1242 : 				}
; 1243 : 			}
; 1244 : 			else if (y > 300 && x > 510 && x <= 765) { //Bottom
; 1245 : 				converted->data[pos] = 0;
; 1246 : 				converted->data[pos + 1] = 0;
; 1247 : 				converted->data[pos + 2] = x;
; 1248 : 			}
; 1249 : 		}
; 1250 : 	return 1;
; 1251 : }
; 1252 : 
; 1253 : int vc_gray_histogram_equalization(IVC* original, IVC* converted) {
; 1254 : 	//VARS
; 1255 : 	int pos, y, x, max = original->levels + 1;
; 1256 : 	float* array;
; 1257 : 	int n = original->width * original->height;
; 1258 : 
; 1259 : 	//Vetor de histogram
; 1260 : 	array = vc_histogram_array(original);
; 1261 : 
; 1262 : 	//Calcular vetor da acumulada
; 1263 : 	for (int i = 1; i < max; i++) {
; 1264 : 		array[i] = array[i - 1] + ((array[i] / n) * original->levels);
; 1265 : 	}
; 1266 : 
; 1267 : 	//Correr a imagem para atribuir a acumulada
; 1268 : 	for (y = 0; y < original->height; y++)
; 1269 : 		for (x = 0; x < original->width; x++)
; 1270 : 		{
; 1271 : 			pos = y * original->bytesperline + x * original->channels;
; 1272 : 			if (original->data[pos] != 0)
; 1273 : 				converted->data[pos] = array[original->data[pos]];
; 1274 : 		}
; 1275 : 	return 1;
; 1276 : }
; 1277 : 
; 1278 : int vc_rgb_histogram_equalization(IVC* original, IVC* converted) {
; 1279 : 	//VARS
; 1280 : 	int pos, y, x, max = original->levels + 1, i;
; 1281 : 	float *r, *g, *b;
; 1282 : 	int n = original->width * original->height;
; 1283 : 	r = (float*)malloc(max * sizeof(float));
; 1284 : 	g = (float*)malloc(max * sizeof(float));
; 1285 : 	b = (float*)malloc(max * sizeof(float));
; 1286 : 
; 1287 : 	//Inicializa array
; 1288 : 	r[0] = 0;
; 1289 : 	g[0] = 0;
; 1290 : 	b[0] = 0;
; 1291 : 	for (i = 1; i < max; i++) {
; 1292 : 		r[i] = 0;
; 1293 : 		g[i] = 0;
; 1294 : 		b[i] = 0;
; 1295 : 	}
; 1296 : 
; 1297 : 	//Gera vetor do histogram
; 1298 : 	for (y = 0; y < original->height; y++)
; 1299 : 		for (x = 0; x < original->width; x++)
; 1300 : 		{
; 1301 : 			pos = y * original->bytesperline + x * original->channels;
; 1302 : 			if (original->data[pos] != 0) r[original->data[pos]]++;
; 1303 : 			if (original->data[pos + 1] != 0) g[original->data[pos + 1]]++;
; 1304 : 			if (original->data[pos + 2] != 0) b[original->data[pos + 2]]++;
; 1305 : 		}
; 1306 : 
; 1307 : 	//Calcular vetor da acumulada
; 1308 : 	for (i = 1; i < max; i++) {
; 1309 : 		r[i] = r[i - 1] + ((r[i] / n) * original->levels);
; 1310 : 		g[i] = g[i - 1] + ((g[i] / n) * original->levels);
; 1311 : 		b[i] = b[i - 1] + ((b[i] / n) * original->levels);
; 1312 : 	}
; 1313 : 
; 1314 : 	//Correr a imagem para atribuir a acumulada
; 1315 : 	for (y = 0; y < original->height; y++)
; 1316 : 		for (x = 0; x < original->width; x++)
; 1317 : 		{
; 1318 : 			pos = y * original->bytesperline + x * original->channels;
; 1319 : 			if (original->data[pos] != 0) converted->data[pos] = r[original->data[pos]];
; 1320 : 			if (original->data[pos + 1] != 0) converted->data[pos + 1] = g[original->data[pos + 1]];
; 1321 : 			if (original->data[pos + 2] != 0) converted->data[pos + 2] = b[original->data[pos + 2]];
; 1322 : 		}
; 1323 : 	return 1;
; 1324 : }
; 1325 : #pragma endregion
; 1326 : 
; 1327 : #pragma region Filters
; 1328 : 
; 1329 : int vc_gray_lowpass_mean_filter(IVC *original, IVC *converted)
; 1330 : {
; 1331 : 	long int pos, posk, count = 0;
; 1332 : 	float meanAux;
; 1333 : 	int channels = original->channels, bytesperline = original->bytesperline;
; 1334 : 	int offset = 1;
; 1335 : 	int x, kx, y, ky;
; 1336 : 	int width = original->width, height = original->height;
; 1337 : 	float threshold;
; 1338 : 	int mask[9] = {1, 1, 1,
; 1339 : 				   1, 1, 1,
; 1340 : 				   1, 1, 1};
; 1341 : 
; 1342 : 	if ((original->width <= 0) || (original->height <= 0) || (original->data == NULL))
; 1343 : 		return 0;
; 1344 : 	if ((original->width != converted->width) || (original->height != converted->height) || (original->channels != converted->channels))
; 1345 : 		return 0;
; 1346 : 	if (channels != 1)
; 1347 : 		return 0;
; 1348 : 
; 1349 : 	//Copy borders from original to converted
; 1350 : 	for (y = 0; y < original->height; y++)
; 1351 : 		for (x = 0; x < original->width; x++)
; 1352 : 			if (y == 0 || y == (original->height - 1) || x == 0 || x == (original->width - 1))
; 1353 : 				converted->data[(y * original->width) + x] = original->data[(y * original->width) + x];
; 1354 : 
; 1355 : 	//Apply mask
; 1356 : 	for (y = 1; y < original->height; y++)
; 1357 : 		for (x = 1; x < original->width; x++)
; 1358 : 		{
; 1359 : 			pos = y * original->bytesperline + x * original->channels;
; 1360 : 			count = 0;
; 1361 : 			meanAux = 0;
; 1362 : 			//
; 1363 : 			for (ky = -offset; ky <= offset; ky++)
; 1364 : 				for (kx = -offset; kx <= offset; kx++)
; 1365 : 				{
; 1366 : 					posk = (y + ky) * bytesperline + (x + kx) * channels;
; 1367 : 					//
; 1368 : 					meanAux += original->data[posk] * mask[count++];
; 1369 : 				}
; 1370 : 			//
; 1371 : 			meanAux /= 9;
; 1372 : 			converted->data[pos] = meanAux;
; 1373 : 		}
; 1374 : 
; 1375 : 	return 0;
; 1376 : }
; 1377 : 
; 1378 : #pragma endregion
; 1379 : 
; 1380 : #pragma region Trabalho
; 1381 : //Fase 1
; 1382 : 
; 1383 : 
; 1384 : //Limpa uma percentagem da imagem baseado no Y onde foi detectada a matricula
; 1385 : int vc_trab_clean(IVC* original, IVC* converted, int license_line, float percent)
; 1386 : {
; 1387 : 	int x, y, pos;
; 1388 : 
; 1389 : 	if (percent <= 0)
; 1390 : 		return 0;
; 1391 : 
; 1392 : 	//Calcula as percentagens
; 1393 : 	percent /= 100;
; 1394 : 	int aux = original->height * percent;

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@3e19999a
	cvttss2si ecx, xmm0
	sub	eax, ecx

; 1395 : 	float min = license_line - aux >= 0 ? license_line - aux : 0,

	cmovs	eax, r14d
	movd	xmm2, eax
	lea	eax, DWORD PTR [rcx+rbp]

; 1396 : 		max = license_line + aux <= original->height ? license_line + aux : original->height;

	cmp	eax, edx
	cvtdq2ps xmm2, xmm2
	cmovg	eax, edx
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1

; 1397 : 
; 1398 : 	for (y = 0; y < original->height; y++)

	test	edx, edx
	jle	SHORT $LN59@vc_trab_fa
	mov	r15d, 255				; 000000ffH
$LL60@vc_trab_fa:

; 1399 : 		for (x = 0; x < original->width; x++)

	cmp	DWORD PTR [rbx+8], 0
	mov	r8d, r14d
	jle	SHORT $LN58@vc_trab_fa
	movd	xmm0, r9d
	cvtdq2ps xmm0, xmm0
	npad	9
$LL63@vc_trab_fa:

; 1400 : 		{
; 1401 : 			pos = y * original->bytesperline + x * original->channels;

	mov	ecx, DWORD PTR [rbx+16]
	mov	eax, DWORD PTR [rbx+24]
	imul	ecx, r8d
	imul	eax, r9d
	add	ecx, eax

; 1402 : 			if (y <= min || y >= max)

	comiss	xmm2, xmm0
	jae	SHORT $LN94@vc_trab_fa
	comiss	xmm0, xmm1
	jae	SHORT $LN94@vc_trab_fa

; 1404 : 			else
; 1405 : 				converted->data[pos] = original->data[pos] == 255 ? 255 : original->data[pos];

	mov	rax, QWORD PTR [rbx]
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rdx+rax]
	mov	rax, QWORD PTR [rsi]
	cmp	cl, r15b
	cmove	ecx, r15d
	mov	BYTE PTR [rdx+rax], cl
	jmp	SHORT $LN61@vc_trab_fa
$LN94@vc_trab_fa:

; 1403 : 				converted->data[pos] = 0;

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, ecx
	mov	BYTE PTR [rcx+rax], 0
$LN61@vc_trab_fa:

; 1399 : 		for (x = 0; x < original->width; x++)

	inc	r8d
	cmp	r8d, DWORD PTR [rbx+8]
	jl	SHORT $LL63@vc_trab_fa
$LN58@vc_trab_fa:

; 1397 : 
; 1398 : 	for (y = 0; y < original->height; y++)

	inc	r9d
	cmp	r9d, DWORD PTR [rbx+12]
	jl	SHORT $LL60@vc_trab_fa
	mov	r15, QWORD PTR license$[rsp]
$LN59@vc_trab_fa:

; 1425 : 
; 1426 : 	//Clean
; 1427 : 	vc_trab_clean(img, clean, detected_line, 15);
; 1428 : 	//vc_write_image("clean.pgm", clean);
; 1429 : 	//save("fase2_clean.pgm", clean);
; 1430 : 
; 1431 : 	//Prewitt
; 1432 : 	vc_binary_edge_prewitt(clean, prewitt, 0.985);

	movss	xmm2, DWORD PTR __real@3f7c28f6
	mov	rdx, r13
	mov	rcx, rsi
	call	vc_binary_edge_prewitt

; 1433 : 	//vc_write_image("fase2_prewitt.pgm", prewitt);
; 1434 : 
; 1435 : 	//Filter Mean
; 1436 : 	vc_binary_dilate(prewitt, filter, 3);

	mov	rdx, r12
	mov	rcx, r13
	call	vc_binary_dilate

; 1437 : 	//vc_write_image("fase2_filter.pgm", filter);
; 1438 : 
; 1439 : 	//Get Blobs
; 1440 : 	OVC *blobs = vc_binary_blob_labelling(filter, license, &nLabels);

	lea	r8, QWORD PTR nLabels$[rsp]
	mov	rdx, r15
	mov	rcx, r12
	call	vc_binary_blob_labelling

; 1441 : 	vc_binary_blob_info(license, blobs, nLabels);

	mov	esi, DWORD PTR nLabels$[rsp]
	mov	rdx, rax
	mov	r8d, esi
	mov	rcx, r15
	mov	rbx, rax
	call	vc_binary_blob_info
	mov	r8d, r14d

; 1442 : 
; 1443 : 	//Encontra a matricula
; 1444 : 	for (i = 0; i < nLabels; i++)

	test	esi, esi
	jle	$LN103@vc_trab_fa
	mov	edi, DWORD PTR max$1$[rsp]
	lea	rcx, QWORD PTR [rbx+12]
	mov	r15d, -1
$LL85@vc_trab_fa:

; 1445 : 	{
; 1446 : 		if (blobs[i].y < detected_line && (blobs[i].y + blobs[i].height) > detected_line)

	mov	r9d, DWORD PTR [rcx-8]
	cmp	r9d, ebp
	jge	SHORT $LN86@vc_trab_fa
	mov	edx, DWORD PTR [rcx]
	lea	eax, DWORD PTR [r9+rdx]
	cmp	eax, ebp
	jle	SHORT $LN86@vc_trab_fa

; 1447 : 		{ //blob que esta entre a linha da matricula
; 1448 : 			if (blobs[i].area > max && (blobs[i].height - blobs[i].y) < (blobs[i].width - blobs[i].x))

	mov	r10d, DWORD PTR [rcx+4]
	cmp	r10d, edi
	jle	SHORT $LN86@vc_trab_fa
	mov	eax, DWORD PTR [rcx-4]
	sub	edx, r9d
	sub	eax, DWORD PTR [rcx-12]
	cmp	edx, eax
	jge	SHORT $LN86@vc_trab_fa

; 1449 : 			{
; 1450 : 				//tenta encontrar o blob com maior area que esta na linha da matricula
; 1451 : 				max = blobs[i].area;

	mov	edi, r10d

; 1452 : 				index = i;

	mov	r15d, r8d
$LN86@vc_trab_fa:

; 1442 : 
; 1443 : 	//Encontra a matricula
; 1444 : 	for (i = 0; i < nLabels; i++)

	inc	r8d
	add	rcx, 36					; 00000024H
	cmp	r8d, esi
	jl	SHORT $LL85@vc_trab_fa

; 1453 : 				//printf("Label: %d | Perimetro: %d | Centro-MASSA: %d,%d | Area: %d | X: %d | Y : %d Width: %d | Height: %d\n", blobs[i].label, blobs[i].perimeter, blobs[i].xc, blobs[i].yc, blobs[i].area, blobs[i].x, blobs[i].y, blobs[i].width, blobs[i].height);
; 1454 : 			}
; 1455 : 		}
; 1456 : 	}
; 1457 : 
; 1458 : 	//Extrai a matricula entrontrada para uma nova imagem
; 1459 : 	if (index != -1)

	mov	rdi, QWORD PTR original$[rsp]
	cmp	r15d, -1
	mov	DWORD PTR index$1$[rsp], r15d
	mov	r15, QWORD PTR license$[rsp]
	je	$LN105@vc_trab_fa

; 1460 : 		for (y = 0; y < original->height; y++)

	cmp	DWORD PTR [rdi+12], 0
	mov	r10d, r14d
	jle	$LN105@vc_trab_fa
	movsxd	rbp, DWORD PTR index$1$[rsp]
$LL7@vc_trab_fa:

; 1461 : 			for (x = 0; x < original->width; x++)

	cmp	DWORD PTR [rdi+8], 0
	mov	r8d, r14d
	jle	SHORT $LN5@vc_trab_fa
	lea	r9, QWORD PTR [rbp*8]
	add	r9, rbp
	npad	7
$LL10@vc_trab_fa:

; 1462 : 			{
; 1463 : 				pos = y * original->bytesperline + x * original->channels;

	mov	edx, DWORD PTR [rdi+24]
	mov	eax, DWORD PTR [rdi+16]

; 1464 : 
; 1465 : 				if (y >= blobs[index].y && x >= blobs[index].x && y <= (blobs[index].y + blobs[index].height) && x <= (blobs[index].x + blobs[index].width))

	mov	ecx, DWORD PTR [rbx+r9*4+4]
	imul	edx, r10d
	imul	eax, r8d
	add	edx, eax
	cmp	r10d, ecx
	jl	SHORT $LN14@vc_trab_fa
	mov	r11d, DWORD PTR [rbx+r9*4]
	cmp	r8d, r11d
	jl	SHORT $LN14@vc_trab_fa
	add	ecx, DWORD PTR [rbx+r9*4+12]
	cmp	r10d, ecx
	jg	SHORT $LN14@vc_trab_fa
	mov	ecx, DWORD PTR [rbx+r9*4+8]
	add	ecx, r11d
	cmp	r8d, ecx
	jg	SHORT $LN14@vc_trab_fa

; 1466 : 					license->data[pos] = original->data[pos];

	mov	rax, QWORD PTR [rdi]
	mov	rcx, QWORD PTR [r15]
	movsxd	rdx, edx
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN8@vc_trab_fa
$LN14@vc_trab_fa:

; 1467 : 				else
; 1468 : 					license->data[pos] = 255;

	mov	rax, QWORD PTR [r15]
	movsxd	rcx, edx
	mov	BYTE PTR [rcx+rax], 255			; 000000ffH
$LN8@vc_trab_fa:

; 1461 : 			for (x = 0; x < original->width; x++)

	inc	r8d
	cmp	r8d, DWORD PTR [rdi+8]
	jl	SHORT $LL10@vc_trab_fa
$LN5@vc_trab_fa:

; 1460 : 		for (y = 0; y < original->height; y++)

	inc	r10d
	cmp	r10d, DWORD PTR [rdi+12]
	jl	$LL7@vc_trab_fa

; 1442 : 
; 1443 : 	//Encontra a matricula
; 1444 : 	for (i = 0; i < nLabels; i++)

	jmp	SHORT $LN6@vc_trab_fa
$LN103@vc_trab_fa:
	mov	ebp, -1
	jmp	SHORT $LN6@vc_trab_fa
$LN105@vc_trab_fa:

; 1469 : 			}
; 1470 : 
; 1471 : 	//Salva e executa a matricula recortada
; 1472 : 	//save("fase2_license.pgm", license);
; 1473 : 
; 1474 : 	//Clean
; 1475 : 	//free(prewitt);
; 1476 : 	//free(filter);
; 1477 : 	//free(clean);
; 1478 : 	//
; 1479 : 	return &(blobs[index]);

	mov	ebp, DWORD PTR index$1$[rsp]
$LN6@vc_trab_fa:
	movsxd	rax, ebp
	lea	rcx, QWORD PTR [rax+rax*8]
	lea	rax, QWORD PTR [rbx+rcx*4]

; 1480 : }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
vc_trab_fase2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_binary_dilate
_TEXT	SEGMENT
tv939 = 64
original$ = 64
converted$ = 72
y$1$ = 80
kernel$dead$ = 80
vc_binary_dilate PROC					; COMDAT

; 669  : {

$LN46:
	mov	DWORD PTR [rsp+24], r8d
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r15
	sub	rsp, 16

; 670  : 	long int pos, posk;
; 671  : 	float meanAux;
; 672  : 	int channels = original->channels, bytesperline = original->bytesperline;
; 673  : 	int offset = (kernel - 1) / 2;
; 674  : 	int x, kx, y, ky;
; 675  : 	int width = original->width, height = original->height;

	mov	ebp, DWORD PTR [rcx+8]
	mov	rsi, rdx
	mov	eax, DWORD PTR [rcx+16]
	mov	rdi, rcx
	mov	r15d, DWORD PTR [rcx+24]
	mov	r12d, DWORD PTR [rcx+12]

; 676  : 	float threshold;
; 677  : 
; 678  : 	if ((original->width <= 0) || (original->height <= 0) || (original->data == NULL))

	test	ebp, ebp
	jle	$LN15@vc_binary_
	test	r12d, r12d
	jle	$LN15@vc_binary_
	cmp	QWORD PTR [rcx], 0
	je	$LN15@vc_binary_

; 680  : 	if ((original->width != converted->width) || (original->height != converted->height) || (original->channels != converted->channels))

	cmp	ebp, DWORD PTR [rdx+8]
	jne	$LN15@vc_binary_
	cmp	r12d, DWORD PTR [rdx+12]
	jne	$LN15@vc_binary_
	cmp	eax, DWORD PTR [rdx+16]
	jne	$LN15@vc_binary_

; 681  : 		return 0;
; 682  : 	if (channels != 1)

	cmp	eax, 1
	jne	$LN15@vc_binary_

; 683  : 		return 0;
; 684  : 
; 685  : 	for (y = 0; y < original->height; y++)

	xor	edx, edx
	mov	QWORD PTR [rsp+72], rbx
	mov	r9d, r15d
	mov	QWORD PTR [rsp+8], r13
	neg	r9d
	mov	QWORD PTR [rsp], r14
	mov	DWORD PTR tv939[rsp], r9d
	mov	DWORD PTR y$1$[rsp], edx
$LL4@vc_binary_:

; 686  : 		for (x = 0; x < original->width; x++)

	cmp	DWORD PTR [rdi+8], 0
	jle	$LN2@vc_binary_
	mov	r8d, 1
	npad	13
$LL7@vc_binary_:

; 687  : 		{
; 688  : 			pos = y * original->bytesperline + x * original->channels;

	mov	eax, DWORD PTR [rdi+24]
	lea	r11d, DWORD PTR [r8-1]
	imul	eax, edx
	lea	r10d, DWORD PTR [rdx-1]
	mov	ecx, r11d
	mov	r13d, r8d
	imul	ecx, DWORD PTR [rdi+16]
	mov	r14d, 3
	add	ecx, eax

; 689  : 			//
; 690  : 			converted->data[pos] = 0;

	mov	rax, QWORD PTR [rsi]
	movsxd	rbx, ecx
	mov	BYTE PTR [rbx+rax], 0
	npad	6
$LL10@vc_binary_:

; 692  : 				for (kx = -offset; kx <= offset; kx++)
; 693  : 					if ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))

	test	r10d, r10d
	js	SHORT $LN33@vc_binary_
	cmp	r10d, r12d
	jge	SHORT $LN33@vc_binary_
	lea	eax, DWORD PTR [r8-2]
	test	eax, eax
	js	SHORT $LN11@vc_binary_
	cmp	eax, ebp
	jge	SHORT $LN11@vc_binary_

; 694  : 					{
; 695  : 						posk = (y + ky) * bytesperline + (x + kx) * channels;

	lea	ecx, DWORD PTR [rax+r9]

; 696  : 						//
; 697  : 						if (original->data[posk] == 255)

	mov	rax, QWORD PTR [rdi]
	movsxd	rdx, ecx
	cmp	BYTE PTR [rdx+rax], 255			; 000000ffH
	jne	SHORT $LN11@vc_binary_

; 698  : 							converted->data[pos] = 255;

	mov	rax, QWORD PTR [rsi]
	mov	BYTE PTR [rbx+rax], 255			; 000000ffH
$LN11@vc_binary_:

; 692  : 				for (kx = -offset; kx <= offset; kx++)
; 693  : 					if ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))

	test	r11d, r11d
	js	SHORT $LN44@vc_binary_
	cmp	r11d, ebp
	jge	SHORT $LN44@vc_binary_

; 694  : 					{
; 695  : 						posk = (y + ky) * bytesperline + (x + kx) * channels;

	lea	eax, DWORD PTR [r11+r9]

; 696  : 						//
; 697  : 						if (original->data[posk] == 255)

	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdi]
	cmp	BYTE PTR [rcx+rax], 255			; 000000ffH
	jne	SHORT $LN44@vc_binary_

; 698  : 							converted->data[pos] = 255;

	mov	rax, QWORD PTR [rsi]
	mov	BYTE PTR [rbx+rax], 255			; 000000ffH
$LN44@vc_binary_:

; 692  : 				for (kx = -offset; kx <= offset; kx++)
; 693  : 					if ((y + ky >= 0) && (y + ky < height) && (x + kx >= 0) && (x + kx < width))

	test	r8d, r8d
	js	SHORT $LN33@vc_binary_
	cmp	r8d, ebp
	jge	SHORT $LN33@vc_binary_

; 694  : 					{
; 695  : 						posk = (y + ky) * bytesperline + (x + kx) * channels;

	lea	eax, DWORD PTR [r8+r9]

; 696  : 						//
; 697  : 						if (original->data[posk] == 255)

	movsxd	rcx, eax
	mov	rax, QWORD PTR [rdi]
	cmp	BYTE PTR [rcx+rax], 255			; 000000ffH
	jne	SHORT $LN33@vc_binary_

; 698  : 							converted->data[pos] = 255;

	mov	rax, QWORD PTR [rsi]
	mov	BYTE PTR [rbx+rax], 255			; 000000ffH
$LN33@vc_binary_:

; 691  : 			for (ky = -offset; ky <= offset; ky++)

	add	r9d, r15d
	inc	r10d
	sub	r14, 1
	jne	SHORT $LL10@vc_binary_

; 686  : 		for (x = 0; x < original->width; x++)

	mov	edx, DWORD PTR y$1$[rsp]
	inc	r8d
	mov	r9d, DWORD PTR tv939[rsp]
	cmp	r13d, DWORD PTR [rdi+8]
	jl	$LL7@vc_binary_
$LN2@vc_binary_:

; 683  : 		return 0;
; 684  : 
; 685  : 	for (y = 0; y < original->height; y++)

	inc	edx
	add	r9d, r15d
	mov	DWORD PTR y$1$[rsp], edx
	mov	DWORD PTR tv939[rsp], r9d
	cmp	edx, DWORD PTR [rdi+12]
	jl	$LL4@vc_binary_

; 699  : 					}
; 700  : 		}
; 701  : 
; 702  : 	return 1;

	mov	r14, QWORD PTR [rsp]
	mov	eax, 1
	mov	r13, QWORD PTR [rsp+8]
	mov	rbx, QWORD PTR [rsp+72]

; 703  : }

	add	rsp, 16
	pop	r15
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN15@vc_binary_:

; 679  : 		return 0;

	xor	eax, eax

; 703  : }

	add	rsp, 16
	pop	r15
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
vc_binary_dilate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_image_new
_TEXT	SEGMENT
width$ = 48
height$ = 56
channels$ = 64
levels$ = 72
vc_image_new PROC					; COMDAT

; 37   : {

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
	mov	edi, ecx
	mov	esi, r9d

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H
	mov	ebp, r8d
	mov	r14d, edx
	call	QWORD PTR __imp_malloc
	mov	rbx, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	je	SHORT $LN4@vc_image_n

; 41   : 		return NULL;
; 42   : 	if ((levels <= 0) || (levels > 255))

	lea	r10d, DWORD PTR [rsi-1]
	cmp	r10d, 254				; 000000feH
	ja	SHORT $LN4@vc_image_n

; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;

	mov	DWORD PTR [rax+8], edi

; 46   : 	image->height = height;
; 47   : 	image->channels = channels;
; 48   : 	image->levels = levels;
; 49   : 	image->bytesperline = image->width * image->channels;

	imul	edi, ebp
	mov	DWORD PTR [rax+12], r14d
	mov	DWORD PTR [rax+16], ebp
	mov	DWORD PTR [rax+20], esi
	mov	DWORD PTR [rax+24], edi

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	edi, r14d
	movsxd	rcx, edi
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [rbx], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN5@vc_image_n

; 71   : 		free(image);

	mov	rcx, rbx
	call	QWORD PTR __imp_free
$LN4@vc_image_n:

; 58   : }

	xor	eax, eax
$LN1@vc_image_n:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN5@vc_image_n:

; 53   : 	{
; 54   : 		return vc_image_free(image);
; 55   : 	}
; 56   : 
; 57   : 	return image;

	mov	rax, rbx
	jmp	SHORT $LN1@vc_image_n
vc_image_new ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 97   :         static unsigned __int64 _OptionsStorage;
; 98   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 99   :     }

	ret	0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Stream$ = 80
_Format$ = 88
fprintf	PROC						; COMDAT

; 835  :     {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rdx

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]
	mov	rbx, rcx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 840  :         __crt_va_end(_ArgList);
; 841  :         return _Result;
; 842  :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_image_free
_TEXT	SEGMENT
image$ = 48
vc_image_free PROC					; COMDAT

; 62   : {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 63   : 	if (image != NULL)

	test	rcx, rcx
	je	SHORT $LN5@vc_image_f

; 64   : 	{
; 65   : 		if (image->data != NULL)

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN3@vc_image_f

; 66   : 		{
; 67   : 			free(image->data);

	call	QWORD PTR __imp_free

; 68   : 			image->data = NULL;

	mov	QWORD PTR [rbx], 0
$LN3@vc_image_f:

; 69   : 		}
; 70   : 
; 71   : 		free(image);

	mov	rcx, rbx
	call	QWORD PTR __imp_free

; 72   : 		image = NULL;
; 73   : 	}
; 74   : 
; 75   : 	return image;

	xor	eax, eax

; 76   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN5@vc_image_f:

; 72   : 		image = NULL;
; 73   : 	}
; 74   : 
; 75   : 	return image;

	mov	rax, rbx

; 76   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
vc_image_free ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT unsigned_char_to_bit
_TEXT	SEGMENT
datauchar$ = 16
databit$ = 24
width$ = 32
height$ = 40
unsigned_char_to_bit PROC				; COMDAT

; 120  : {

$LN22:
	mov	QWORD PTR [rsp+24], rsi
	push	rdi

; 127  : 	countbits = 1;
; 128  : 	counttotalbytes = 0;

	xor	r11d, r11d
	movsxd	rsi, r8d
	mov	BYTE PTR [rdx], 0
	mov	r10, rdx
	mov	rdi, rcx
	mov	eax, 1

; 129  : 
; 130  : 	for (y = 0; y < height; y++)

	test	r9d, r9d
	jle	SHORT $LN20@unsigned_c

; 121  : 	int x, y;
; 122  : 	int countbits;
; 123  : 	long int pos, counttotalbytes;
; 124  : 	unsigned char *p = databit;
; 125  : 
; 126  : 	*p = 0;

	mov	QWORD PTR [rsp+16], rbx
	mov	rbx, rsi
	mov	QWORD PTR [rsp+24], rbp
	mov	ebp, r9d
	npad	1
$LL4@unsigned_c:

; 131  : 	{
; 132  : 		for (x = 0; x < width; x++)

	xor	r9d, r9d
	test	esi, esi
	jle	SHORT $LN2@unsigned_c

; 133  : 		{
; 134  : 			pos = width * y + x;

	xor	r8d, r8d
	npad	6
$LL7@unsigned_c:

; 135  : 
; 136  : 			if (countbits <= 8)

	cmp	eax, 8
	jg	SHORT $LN10@unsigned_c

; 137  : 			{
; 138  : 				// Numa imagem PBM:
; 139  : 				// 1 = Preto
; 140  : 				// 0 = Branco
; 141  : 				//*p |= (datauchar[pos] != 0) << (8 - countbits);
; 142  : 
; 143  : 				// Na nossa imagem:
; 144  : 				// 1 = Branco
; 145  : 				// 0 = Preto
; 146  : 				*p |= (datauchar[pos] == 0) << (8 - countbits);

	cmp	BYTE PTR [rdi+r8], 0
	mov	ecx, 8
	sete	dl
	sub	ecx, eax
	shl	dl, cl

; 147  : 
; 148  : 				countbits++;

	inc	eax
	or	BYTE PTR [r10], dl

; 149  : 			}
; 150  : 			if ((countbits > 8) || (x == width - 1))

	cmp	eax, 8
	jg	SHORT $LN10@unsigned_c
	lea	ecx, DWORD PTR [rsi-1]
	cmp	r9d, ecx
	jne	SHORT $LN5@unsigned_c
$LN10@unsigned_c:

; 151  : 			{
; 152  : 				p++;

	inc	r10

; 153  : 				*p = 0;
; 154  : 				countbits = 1;

	mov	eax, 1

; 155  : 				counttotalbytes++;

	inc	r11d
	mov	BYTE PTR [r10], 0
$LN5@unsigned_c:

; 131  : 	{
; 132  : 		for (x = 0; x < width; x++)

	inc	r9d
	inc	r8
	cmp	r8, rbx
	jl	SHORT $LL7@unsigned_c
$LN2@unsigned_c:

; 129  : 
; 130  : 	for (y = 0; y < height; y++)

	add	rdi, rbx
	sub	rbp, 1
	jne	SHORT $LL4@unsigned_c

; 156  : 			}
; 157  : 		}
; 158  : 	}
; 159  : 
; 160  : 	return counttotalbytes;

	mov	rbp, QWORD PTR [rsp+24]
	mov	rbx, QWORD PTR [rsp+16]
$LN20@unsigned_c:

; 161  : }

	mov	rsi, QWORD PTR [rsp+32]
	mov	eax, r11d
	pop	rdi
	ret	0
unsigned_char_to_bit ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_rgb_gray_to_binary
_TEXT	SEGMENT
original$ = 16
converted$ = 24
threshold$dead$ = 32
vc_rgb_gray_to_binary PROC				; COMDAT

; 594  : {

$LN22:
	push	rdi

; 595  : 	int pos, posAux, x, y;
; 596  : 	float meanAux;
; 597  : 
; 598  : 	for (x = 0; x < original->width; x++)

	xor	r11d, r11d
	mov	rdi, rdx
	mov	r9, rcx
	cmp	DWORD PTR [rcx+8], r11d
	jle	$LN20@vc_rgb_gra
	mov	eax, DWORD PTR [rcx+12]
	movss	xmm1, DWORD PTR __real@430c0000
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	esi, 255				; 000000ffH
	npad	1
$LL4@vc_rgb_gra:

; 599  : 	{
; 600  : 		for (y = 0; y < original->height; y++)

	xor	r10d, r10d
	test	eax, eax
	jle	SHORT $LN2@vc_rgb_gra
	npad	9
$LL7@vc_rgb_gra:

; 601  : 		{
; 602  : 			pos = y * original->bytesperline + x * original->channels;
; 603  : 			posAux = y * converted->bytesperline + x * converted->channels;

	mov	eax, DWORD PTR [rdi+16]
	mov	ebx, DWORD PTR [r9+16]
	mov	ecx, ebx
	mov	r8d, DWORD PTR [rdi+24]
	imul	eax, r11d
	imul	r8d, r10d
	imul	ecx, r11d
	add	r8d, eax
	mov	eax, r10d
	imul	eax, DWORD PTR [r9+24]
	add	eax, ecx

; 604  : 			meanAux = (original->channels == 1 ? original->data[pos] : (original->data[pos] + original->data[pos + 1] + original->data[pos + 2])) / original->channels;

	cdqe
	add	rax, QWORD PTR [r9]
	cmp	ebx, 1
	jne	SHORT $LN9@vc_rgb_gra
	movzx	edx, BYTE PTR [rax]
	jmp	SHORT $LN10@vc_rgb_gra
$LN9@vc_rgb_gra:
	movzx	ecx, BYTE PTR [rax+1]
	movzx	edx, BYTE PTR [rax+2]
	add	edx, ecx
	movzx	ecx, BYTE PTR [rax]
	add	edx, ecx
$LN10@vc_rgb_gra:
	mov	eax, edx

; 605  : 			converted->data[posAux] = meanAux > threshold ? 255 : 0;

	movsxd	rcx, r8d
	cdq
	idiv	ebx
	xor	edx, edx
	movd	xmm0, eax
	mov	rax, QWORD PTR [rdi]
	cvtdq2ps xmm0, xmm0
	comiss	xmm0, xmm1
	cmova	edx, esi
	inc	r10d
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR [r9+12]
	cmp	r10d, eax
	jl	SHORT $LL7@vc_rgb_gra
$LN2@vc_rgb_gra:

; 595  : 	int pos, posAux, x, y;
; 596  : 	float meanAux;
; 597  : 
; 598  : 	for (x = 0; x < original->width; x++)

	inc	r11d
	cmp	r11d, DWORD PTR [r9+8]
	jl	$LL4@vc_rgb_gra

; 606  : 		}
; 607  : 	}
; 608  : 
; 609  : 	return 1;

	mov	rsi, QWORD PTR [rsp+24]
	mov	rbx, QWORD PTR [rsp+16]
$LN20@vc_rgb_gra:

; 610  : }

	mov	eax, 1
	pop	rdi
	ret	0
vc_rgb_gray_to_binary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_binary_blob_info
_TEXT	SEGMENT
tv1002 = 0
sumy$1$ = 80
src$ = 80
blobs$ = 88
nblobs$ = 96
tv1014 = 104
vc_binary_blob_info PROC				; COMDAT

; 778  : {

$LN42:
	sub	rsp, 72					; 00000048H

; 779  : 	if (src)

	test	rcx, rcx
	je	SHORT $LN11@vc_binary_

; 780  : 		return -1;

	mov	eax, -1

; 856  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN11@vc_binary_:

; 781  : 
; 782  : 	unsigned char *data = (unsigned char *)src->data;

	mov	r11, QWORD PTR [rcx]

; 783  : 	int width = src->width;
; 784  : 	int height = src->height;

	mov	eax, DWORD PTR ds:12
	mov	QWORD PTR [rsp+40], r12
	mov	r12d, DWORD PTR ds:8
	mov	QWORD PTR [rsp+16], r15

; 785  : 	int bytesperline = src->bytesperline;

	mov	r15d, DWORD PTR ds:24

; 786  : 	int channels = src->channels;
; 787  : 	int x, y, i;
; 788  : 	long int pos;
; 789  : 	int xmin, ymin, xmax, ymax;
; 790  : 	long int sumx, sumy;
; 791  : 
; 792  : 	// Verifica��o de erros
; 793  : 	if ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))

	test	r12d, r12d
	jle	$LN13@vc_binary_
	test	eax, eax
	jle	$LN13@vc_binary_
	test	r11, r11
	je	$LN13@vc_binary_

; 795  : 	if (channels != 1)

	cmp	DWORD PTR ds:16, 1
	jne	$LN13@vc_binary_

; 796  : 		return 0;
; 797  : 
; 798  : 	// Conta �rea de cada blob
; 799  : 	for (i = 0; i < nblobs; i++)

	movsxd	rcx, r8d
	mov	QWORD PTR tv1002[rsp], rcx
	test	r8d, r8d
	jle	$LN3@vc_binary_
	mov	QWORD PTR [rsp+88], rbx
	lea	r10, QWORD PTR [rdx+28]
	mov	QWORD PTR [rsp+64], rbp
	dec	r12d
	mov	QWORD PTR [rsp+56], rsi
	dec	eax
	mov	QWORD PTR [rsp+48], rdi
	mov	QWORD PTR [rsp+32], r13
	mov	QWORD PTR [rsp+24], r14
	mov	DWORD PTR tv1014[rsp], eax
	npad	6
$LL4@vc_binary_:

; 800  : 	{
; 801  : 		xmin = width - 1;
; 802  : 		ymin = height - 1;
; 803  : 		xmax = 0;

	xor	ebx, ebx

; 804  : 		ymax = 0;
; 805  : 
; 806  : 		sumx = 0;
; 807  : 		sumy = 0;

	xor	r14d, r14d
	xor	edi, edi
	mov	DWORD PTR sumy$1$[rsp], r14d
	xor	r13d, r13d

; 808  : 
; 809  : 		blobs[i].area = 0;

	mov	DWORD PTR [r10-12], ebx
	mov	r9d, 1
	xor	r8d, r8d
	mov	esi, r12d
	mov	ebp, eax

; 810  : 
; 811  : 		for (y = 1; y < height - 1; y++)

	cmp	eax, r9d
	jle	$LN6@vc_binary_
	npad	6
$LL7@vc_binary_:

; 812  : 			for (x = 1; x < width - 1; x++)

	mov	eax, 1
	cmp	r12d, eax
	jle	$LN5@vc_binary_

; 813  : 			{
; 814  : 				pos = y * bytesperline + x * channels;
; 815  : 
; 816  : 				if (data[pos] == blobs[i].label)

	mov	r8d, DWORD PTR [r10+4]
	mov	r14d, r9d
	imul	r14d, r15d
	npad	7
$LL10@vc_binary_:
	lea	ecx, DWORD PTR [r14+rax]
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rdx+r11]
	cmp	ecx, r8d
	jne	SHORT $LN8@vc_binary_

; 817  : 				{
; 818  : 					// �rea
; 819  : 					blobs[i].area++;

	inc	DWORD PTR [r10-12]

; 820  : 
; 821  : 					// Centro de Gravidade
; 822  : 					sumx += x;

	add	r13d, eax

; 823  : 					sumy += y;

	add	DWORD PTR sumy$1$[rsp], r9d

; 824  : 
; 825  : 					// Bounding Box
; 826  : 					if (xmin > x)
; 827  : 						xmin = x;
; 828  : 					if (ymin > y)

	mov	ecx, eax
	cmp	esi, eax
	cmovle	ecx, esi

; 829  : 						ymin = y;
; 830  : 					if (xmax < x)

	cmp	ebp, r9d
	mov	esi, ecx
	mov	ecx, r9d
	cmovle	ecx, ebp

; 831  : 						xmax = x;
; 832  : 					if (ymax < y)

	cmp	ebx, eax
	mov	ebp, ecx
	mov	ecx, eax
	cmovge	ecx, ebx
	cmp	edi, r9d
	mov	ebx, ecx
	mov	ecx, r9d
	cmovge	ecx, edi
	mov	edi, ecx

; 833  : 						ymax = y;
; 834  : 
; 835  : 					// Per�metro
; 836  : 					// Se pelo menos um dos quatro vizinhos n�o pertence ao mesmo label, ent�o � um pixel de contorno
; 837  : 					if ((data[pos - 1] != blobs[i].label) || (data[pos + 1] != blobs[i].label) || (data[pos - bytesperline] != blobs[i].label) || (data[pos + bytesperline] != blobs[i].label))

	movzx	ecx, BYTE PTR [rdx+r11-1]
	cmp	ecx, r8d
	jne	SHORT $LN21@vc_binary_
	movzx	ecx, BYTE PTR [rdx+r11+1]
	cmp	ecx, r8d
	jne	SHORT $LN21@vc_binary_
	lea	ecx, DWORD PTR [r9-1]
	imul	ecx, r15d
	add	ecx, eax
	movsxd	rcx, ecx
	movzx	edx, BYTE PTR [rcx+r11]
	cmp	edx, r8d
	jne	SHORT $LN21@vc_binary_
	lea	ecx, DWORD PTR [r9+1]
	imul	ecx, r15d
	add	ecx, eax
	movsxd	rcx, ecx
	movzx	edx, BYTE PTR [rcx+r11]
	cmp	edx, r8d
	je	SHORT $LN8@vc_binary_
$LN21@vc_binary_:

; 838  : 						blobs[i].perimeter++;

	inc	DWORD PTR [r10]
$LN8@vc_binary_:

; 812  : 			for (x = 1; x < width - 1; x++)

	inc	eax
	cmp	eax, r12d
	jl	$LL10@vc_binary_
$LN5@vc_binary_:

; 810  : 
; 811  : 		for (y = 1; y < height - 1; y++)

	inc	r9d
	cmp	r9d, DWORD PTR tv1014[rsp]
	jl	$LL7@vc_binary_
	mov	r8d, DWORD PTR [r10-12]
	mov	r14d, DWORD PTR sumy$1$[rsp]
$LN6@vc_binary_:

; 839  : 				}
; 840  : 			}
; 841  : 
; 842  : 		// Bounding Box
; 843  : 		blobs[i].x = xmin;
; 844  : 		blobs[i].y = ymin;
; 845  : 		blobs[i].width = (xmax - xmin) + 1;

	sub	ebx, esi
	mov	DWORD PTR [r10-28], esi

; 846  : 		blobs[i].height = (ymax - ymin) + 1;

	sub	edi, ebp
	mov	DWORD PTR [r10-24], ebp
	inc	ebx
	inc	edi

; 847  : 
; 848  : 		// Centro de Gravidade
; 849  : 		//blobs[i].xc = (xmax - xmin) / 2;
; 850  : 		//blobs[i].yc = (ymax - ymin) / 2;
; 851  : 		blobs[i].xc = sumx / MAX(blobs[i].area, 1);

	mov	ecx, 1
	mov	DWORD PTR [r10-20], ebx
	cmp	r8d, ecx
	mov	DWORD PTR [r10-16], edi
	mov	eax, r13d
	cmovg	ecx, r8d
	cdq
	idiv	ecx

; 852  : 		blobs[i].yc = sumy / MAX(blobs[i].area, 1);

	mov	ecx, 1
	mov	DWORD PTR [r10-8], eax
	cmp	r8d, ecx
	mov	eax, r14d
	cmovg	ecx, r8d
	cdq
	idiv	ecx
	mov	DWORD PTR [r10-4], eax
	add	r10, 36					; 00000024H
	sub	QWORD PTR tv1002[rsp], 1
	mov	eax, DWORD PTR tv1014[rsp]
	jne	$LL4@vc_binary_

; 796  : 		return 0;
; 797  : 
; 798  : 	// Conta �rea de cada blob
; 799  : 	for (i = 0; i < nblobs; i++)

	mov	r14, QWORD PTR [rsp+24]
	mov	r13, QWORD PTR [rsp+32]
	mov	rdi, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	mov	rbp, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+88]
$LN3@vc_binary_:

; 853  : 	}
; 854  : 
; 855  : 	return 1;

	mov	r12, QWORD PTR [rsp+40]
	mov	eax, 1
	mov	r15, QWORD PTR [rsp+16]

; 856  : }

	add	rsp, 72					; 00000048H
	ret	0
$LN13@vc_binary_:
	mov	r12, QWORD PTR [rsp+40]

; 794  : 		return 0;

	xor	eax, eax
	mov	r15, QWORD PTR [rsp+16]

; 856  : }

	add	rsp, 72					; 00000048H
	ret	0
vc_binary_blob_info ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_binary_edge_prewitt
_TEXT	SEGMENT
bytesperline$1$ = 32
channels$1$ = 36
tv9672 = 36
height$1$ = 40
tv9593 = 40
tv9627 = 44
levels$1$ = 48
tv9596 = 48
channels$1$ = 52
height$1$ = 56
tv9636 = 64
tv9585 = 64
tv9637 = 72
tv9583 = 72
tv9671 = 80
tv9638 = 80
tv9628 = 88
tv9620 = 88
x$1$ = 96
width$1$ = 100
tv9660 = 104
tv9624 = 112
tv9588 = 120
tv9622 = 128
datasrc$1$ = 136
tv9599 = 144
tv9626 = 152
tv9600 = 160
tv9579 = 168
datadst$1$ = 176
tv9568 = 184
tv9603 = 192
tv9606 = 200
tv9601 = 208
tv9604 = 216
tv9605 = 224
tv9590 = 232
tv9625 = 240
tv9623 = 248
tv9619 = 256
tv9589 = 264
tv9587 = 272
tv9569 = 280
tv9580 = 288
tv9582 = 296
tv9621 = 304
tv9584 = 312
tv9586 = 320
tv9581 = 328
tv9645 = 336
hist$ = 352
__$ArrayPad$ = 1376
src$ = 1472
dst$ = 1480
th$ = 1488
vc_binary_edge_prewitt PROC				; COMDAT

; 961  : {

$LN101:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 1408				; 00000580H
	movaps	XMMWORD PTR [rsp+1392], xmm6
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 962  : 
; 963  : 	unsigned char *datasrc = (unsigned char *)src->data;
; 964  : 	unsigned char *datadst = (unsigned char *)dst->data;
; 965  : 	int width = src->width;
; 966  : 	int height = src->height;

	mov	eax, DWORD PTR [rcx+12]
	mov	r14, rdx
	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rcx
	mov	rbp, QWORD PTR [rdx]

; 967  : 	int bytesperline = src->bytesperline;
; 968  : 	int channels = src->channels;
; 969  : 	int x, y;
; 970  : 	long int posX, posA, posB, posC, posD, posE, posF, posG, posH;
; 971  : 	int i, size;
; 972  : 	int histmax, histthreshold;
; 973  : 	int sumx, sumy;
; 974  : 	int hist[256] = {0};

	mov	r8d, 1024				; 00000400H
	mov	edi, DWORD PTR [rcx+8]
	xor	edx, edx
	movsxd	r12, DWORD PTR [rcx+16]
	movaps	xmm6, xmm2
	mov	DWORD PTR height$1$[rsp], eax
	mov	eax, DWORD PTR [rcx+24]
	lea	rcx, QWORD PTR hist$[rsp]
	mov	QWORD PTR datasrc$1$[rsp], rbx
	mov	QWORD PTR datadst$1$[rsp], rbp
	mov	DWORD PTR width$1$[rsp], edi
	mov	DWORD PTR bytesperline$1$[rsp], eax
	mov	DWORD PTR channels$1$[rsp], r12d
	call	memset

; 975  : 
; 976  : 	IVC *dest = vc_image_new(dst->width, dst->height, dst->channels, dst->levels);

	mov	eax, DWORD PTR [r14+20]

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	mov	ecx, 32					; 00000020H

; 975  : 
; 976  : 	IVC *dest = vc_image_new(dst->width, dst->height, dst->channels, dst->levels);

	mov	r13d, DWORD PTR [r14+8]
	mov	DWORD PTR levels$1$[rsp], eax
	mov	eax, DWORD PTR [r14+16]
	mov	DWORD PTR channels$1$[rsp], eax
	mov	eax, DWORD PTR [r14+12]
	mov	DWORD PTR height$1$[rsp], eax

; 38   : 	IVC *image = (IVC *)malloc(sizeof(IVC));

	call	QWORD PTR __imp_malloc
	mov	r15, rax

; 39   : 
; 40   : 	if (image == NULL)

	test	rax, rax
	je	SHORT $LN40@vc_binary_

; 41   : 		return NULL;
; 42   : 	if ((levels <= 0) || (levels > 255))

	mov	eax, DWORD PTR levels$1$[rsp]
	lea	ecx, DWORD PTR [rax-1]
	cmp	ecx, 254				; 000000feH
	ja	SHORT $LN40@vc_binary_

; 43   : 		return NULL;
; 44   : 
; 45   : 	image->width = width;
; 46   : 	image->height = height;
; 47   : 	image->channels = channels;

	mov	ecx, DWORD PTR channels$1$[rsp]
	mov	edx, DWORD PTR height$1$[rsp]
	mov	DWORD PTR [r15+8], r13d

; 48   : 	image->levels = levels;
; 49   : 	image->bytesperline = image->width * image->channels;

	imul	r13d, ecx
	mov	DWORD PTR [r15+16], ecx
	mov	DWORD PTR [r15+12], edx
	mov	DWORD PTR [r15+20], eax
	mov	DWORD PTR [r15+24], r13d

; 50   : 	image->data = (unsigned char *)malloc(image->width * image->height * image->channels * sizeof(char));

	imul	r13d, edx
	movsxd	rcx, r13d
	call	QWORD PTR __imp_malloc
	mov	QWORD PTR [r15], rax

; 51   : 
; 52   : 	if (image->data == NULL)

	test	rax, rax
	jne	SHORT $LN40@vc_binary_

; 71   : 		free(image);

	mov	rcx, r15
	call	QWORD PTR __imp_free
$LN40@vc_binary_:

; 977  : 
; 978  : 	//verificao de erros
; 979  : 	if ((src->width <= 0) || (src->height <= 0) || (src->data == NULL))

	mov	ecx, DWORD PTR [rsi+8]
	test	ecx, ecx
	jle	$LN24@vc_binary_
	mov	eax, DWORD PTR [rsi+12]
	test	eax, eax
	jle	$LN24@vc_binary_
	cmp	QWORD PTR [rsi], 0
	je	$LN24@vc_binary_

; 981  : 	if ((src->width != dst->width) || (src->height != dst->height))

	cmp	ecx, DWORD PTR [r14+8]
	jne	$LN24@vc_binary_
	cmp	eax, DWORD PTR [r14+12]
	jne	$LN24@vc_binary_

; 982  : 		return 0;
; 983  : 	if ((src->channels != 1) || (dst->channels != 1))

	cmp	DWORD PTR [rsi+16], 1
	jne	$LN24@vc_binary_
	cmp	DWORD PTR [r14+16], 1
	jne	$LN24@vc_binary_

; 984  : 		return 0;
; 985  : 
; 986  : 	size = width * height;

	mov	edx, DWORD PTR height$1$[rsp]
	mov	esi, edx
	imul	esi, edi

; 987  : 
; 988  : 	for (y = 1; y < height - 1; y++)

	lea	ecx, DWORD PTR [rdx-1]
	mov	DWORD PTR tv9660[rsp], esi
	cmp	ecx, 1
	jle	$LN99@vc_binary_

; 984  : 		return 0;
; 985  : 
; 986  : 	size = width * height;

	movsxd	r10, DWORD PTR bytesperline$1$[rsp]
	lea	r15d, DWORD PTR [rdi-1]
	mov	r11d, DWORD PTR bytesperline$1$[rsp]
	mov	edx, r10d
	neg	edx
	mov	DWORD PTR tv9672[rsp], r15d
	mov	QWORD PTR tv9599[rsp], r10
	mov	rdi, r12
	lea	r13d, DWORD PTR [r10+r10]
	mov	DWORD PTR tv9593[rsp], edx
	movsxd	rsi, r13d
	lea	eax, DWORD PTR [r12+r13]
	movsxd	r8, eax
	mov	r14, rsi
	sub	r14, r8
	mov	DWORD PTR tv9627[rsp], r13d
	add	r14, rbx
	mov	QWORD PTR tv9626[rsp], rsi
	mov	rax, r12
	mov	QWORD PTR tv9568[rsp], r8
	sub	rax, r8
	mov	QWORD PTR tv9606[rsp], r14
	mov	QWORD PTR tv9605[rsp], rax
	mov	r9, r8
	sub	r9, rsi
	lea	eax, DWORD PTR [r12+r10]
	cdqe
	sub	rax, r8
	mov	QWORD PTR tv9603[rsp], r9
	mov	QWORD PTR tv9604[rsp], rax
	mov	rax, r10
	sub	rax, rsi
	mov	QWORD PTR tv9569[rsp], rax
	mov	eax, r10d
	neg	eax
	add	eax, eax
	dec	ecx
	mov	DWORD PTR tv9596[rsp], eax
	mov	QWORD PTR tv9601[rsp], rcx
	mov	rax, r10
	npad	1
$LL4@vc_binary_:

; 989  : 	{
; 990  : 		for (x = 1; x < width - 1; x++)

	mov	r10d, 1
	cmp	r15d, r10d
	jle	$LN2@vc_binary_
	cmp	r15d, 4
	jle	$LC66@vc_binary_

; 991  : 		{
; 992  : 			posA = (y - 1) * bytesperline + (x - 1) * channels;
; 993  : 			posB = (y - 1) * bytesperline + x * channels;
; 994  : 			posC = (y - 1) * bytesperline + (x + 1) * channels;
; 995  : 			posD = y * bytesperline + (x - 1) * channels;

	lea	r11, QWORD PTR [r9+rsi]
	lea	r9d, DWORD PTR [rdx+r13]
	add	r14, r11
	lea	r10d, DWORD PTR [r12*4]
	lea	ecx, DWORD PTR [r12+r12]
	movsxd	rax, r10d
	mov	QWORD PTR tv9645[rsp], rax
	lea	edx, DWORD PTR [r12+r12*2]
	mov	rax, r11
	sub	rax, r8
	mov	r8d, DWORD PTR tv9596[rsp]
	sub	rax, rsi
	add	r8d, r13d
	mov	QWORD PTR tv9590[rsp], rax
	lea	eax, DWORD PTR [r9+rcx]
	cdqe
	sub	rax, rsi
	mov	QWORD PTR tv9589[rsp], rax
	sub	rax, rbx
	add	rax, rbp
	mov	QWORD PTR tv9625[rsp], rax
	lea	eax, DWORD PTR [rcx+r13]
	cdqe
	sub	rax, rsi
	mov	QWORD PTR tv9624[rsp], rax
	lea	eax, DWORD PTR [r8+rcx]
	cdqe
	lea	ecx, DWORD PTR [r12+r12*4]
	sub	rax, rsi
	mov	QWORD PTR tv9588[rsp], rax
	lea	eax, DWORD PTR [r9+rdx]
	cdqe
	sub	rax, rsi
	mov	QWORD PTR tv9587[rsp], rax
	sub	rax, rbx
	add	rax, rbp
	mov	QWORD PTR tv9623[rsp], rax
	lea	eax, DWORD PTR [r9+rcx]
	cdqe
	sub	rax, rsi
	mov	QWORD PTR tv9586[rsp], rax
	lea	eax, DWORD PTR [rdx+r13]
	cdqe
	sub	rax, rsi
	mov	QWORD PTR tv9622[rsp], rax
	lea	eax, DWORD PTR [r8+rdx]
	cdqe
	sub	rax, rsi
	mov	QWORD PTR tv9585[rsp], rax
	lea	eax, DWORD PTR [rcx+r13]
	cdqe
	sub	rax, rsi
	mov	QWORD PTR tv9621[rsp], rax
	lea	eax, DWORD PTR [r8+rcx]
	cdqe
	sub	rax, rsi
	mov	QWORD PTR tv9584[rsp], rax
	lea	eax, DWORD PTR [r8+r10]
	cdqe
	sub	rax, rsi
	mov	QWORD PTR tv9583[rsp], rax
	lea	eax, DWORD PTR [r10+r13]
	cdqe
	sub	rax, rsi
	mov	QWORD PTR tv9620[rsp], rax
	lea	eax, DWORD PTR [r9+r10]
	cdqe
	sub	rax, rsi
	mov	QWORD PTR tv9582[rsp], rax
	sub	rax, rbx
	add	rax, rbp
	mov	QWORD PTR tv9581[rsp], rax
	mov	rax, r11
	sub	rax, rsi
	add	rax, QWORD PTR tv9604[rsp]
	mov	QWORD PTR tv9580[rsp], rax
	sub	rax, rbx
	add	rax, rbp
	mov	QWORD PTR tv9619[rsp], rax
	mov	rax, r11
	sub	rax, rsi
	mov	r12, QWORD PTR tv9590[rsp]
	sub	r11, rsi
	mov	r13, QWORD PTR tv9625[rsp]
	mov	rbp, QWORD PTR tv9623[rsp]
	mov	rsi, QWORD PTR tv9619[rsp]
	mov	rdi, QWORD PTR tv9587[rsp]
	mov	QWORD PTR tv9600[rsp], rax
	mov	rax, QWORD PTR tv9605[rsp]
	add	rax, r11
	mov	QWORD PTR tv9579[rsp], rax
	lea	eax, DWORD PTR [r15-5]
	mov	r15, QWORD PTR tv9589[rsp]
	shr	eax, 2
	inc	eax
	mov	ecx, eax
	mov	QWORD PTR tv9671[rsp], rcx
	lea	eax, DWORD PTR [rax*4+1]
	mov	DWORD PTR x$1$[rsp], eax
	npad	10
$LL67@vc_binary_:

; 996  : 			posX = y * bytesperline + x * channels;
; 997  : 			posE = y * bytesperline + (x + 1) * channels;
; 998  : 			posF = (y + 1) * bytesperline + (x - 1) * channels;
; 999  : 			posG = (y + 1) * bytesperline + x * channels;
; 1000 : 			posH = (y + 1) * bytesperline + (x + 1) * channels;
; 1001 : 
; 1002 : 			//         _______________________
; 1003 : 			//        |     |    |    |
; 1004 : 			//        | POS_A | POS_B | POS_C |
; 1005 : 			//        |  -1  |  -1  |  1  |
; 1006 : 			//        |_______|_______|_______|
; 1007 : 			//        |     |    |    |
; 1008 : 			//        | POS_D | POS_X | POS_E |
; 1009 : 			//        |  -1  |   0  |  1  |
; 1010 : 			//        |_______|_______|_______|
; 1011 : 			//        |     |    |    |
; 1012 : 			//        | POS_F | POS_G | POS_H |
; 1013 : 			//        |  -1  |   1  |  1  |
; 1014 : 			//        |_______|_______|_______|
; 1015 : 
; 1016 : 			// Convolução
; 1017 : 			sumx = datasrc[posA] * -1;

	movzx	r9d, BYTE PTR [r14+r12]

; 1023 : 			sumx += datasrc[posH] * +1;

	mov	rax, QWORD PTR tv9624[rsp]
	movzx	ecx, BYTE PTR [r14+r15]
	movzx	ebx, BYTE PTR [r14]
	movzx	r11d, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9588[rsp]
	movzx	r8d, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9569[rsp]
	movzx	eax, BYTE PTR [r14+rax]
	sub	ecx, eax

; 1024 : 			sumx = sumx / 3; // 3 = 1 + 1 + 1

	mov	eax, 1431655766				; 55555556H
	sub	ecx, ebx
	sub	ecx, r9d
	add	ecx, r11d
	add	ecx, r8d
	imul	ecx

; 1029 : 			sumy += datasrc[posC] * -1;
; 1030 : 
; 1031 : 			sumy += datasrc[posF] * +1;
; 1032 : 			sumy += datasrc[posG] * +1;

	mov	rax, QWORD PTR tv9600[rsp]
	mov	r10d, edx
	shr	r10d, 31
	add	r10d, edx
	movzx	ecx, BYTE PTR [rax+r14]
	mov	rax, QWORD PTR tv9579[rsp]

; 1033 : 			sumy += datasrc[posH] * +1;
; 1034 : 			sumy = sumy / 3; // 3 = 1 + 1 + 1
; 1035 : 			// magnitude = 3
; 1036 : 
; 1037 : 			// Calcular a magnitude do vector:
; 1038 : 			datadst[posX] = (unsigned char)sqrt((double)(sumx * sumx + sumy * sumy));

	imul	r10d, r10d
	movzx	eax, BYTE PTR [r14+rax]
	sub	ecx, eax
	mov	eax, 1431655766				; 55555556H
	sub	ecx, r8d
	sub	ecx, r9d
	add	ecx, ebx
	add	ecx, r11d
	imul	ecx
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	edx, edx
	add	edx, r10d
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	call	sqrt
	cvttsd2si eax, xmm0
	mov	BYTE PTR [r14+rsi], al
	mov	rax, QWORD PTR tv9600[rsp]
	movzx	ecx, BYTE PTR [r14+rdi]
	movzx	ebx, BYTE PTR [rax+r14]
	mov	rax, QWORD PTR tv9579[rsp]
	movzx	r9d, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9622[rsp]
	movzx	r10d, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9585[rsp]
	movzx	r8d, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9580[rsp]
	movzx	eax, BYTE PTR [r14+rax]
	sub	ecx, eax
	mov	eax, 1431655766				; 55555556H
	sub	ecx, ebx
	sub	ecx, r9d
	add	ecx, r10d
	add	ecx, r8d
	imul	ecx
	mov	rax, QWORD PTR tv9624[rsp]
	mov	r11d, edx
	shr	r11d, 31
	add	r11d, edx
	movzx	ecx, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9588[rsp]
	imul	r11d, r11d
	movzx	eax, BYTE PTR [r14+rax]
	sub	ecx, eax
	mov	eax, 1431655766				; 55555556H
	sub	ecx, r8d
	sub	ecx, r9d
	add	ecx, r10d
	add	ecx, ebx
	imul	ecx
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	edx, edx
	add	edx, r11d
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	call	sqrt
	cvttsd2si eax, xmm0
	mov	BYTE PTR [r14+r13], al
	mov	rax, QWORD PTR tv9624[rsp]
	movzx	ebx, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9588[rsp]
	movzx	r9d, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9620[rsp]
	movzx	r10d, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9583[rsp]
	movzx	r8d, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9582[rsp]
	movzx	ecx, BYTE PTR [r14+rax]
	movzx	eax, BYTE PTR [r14+r15]
	sub	ecx, eax
	mov	eax, 1431655766				; 55555556H
	sub	ecx, ebx
	sub	ecx, r9d
	add	ecx, r10d
	add	ecx, r8d
	imul	ecx
	mov	rax, QWORD PTR tv9622[rsp]
	mov	r11d, edx
	shr	r11d, 31
	add	r11d, edx
	movzx	ecx, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9585[rsp]
	imul	r11d, r11d
	movzx	eax, BYTE PTR [r14+rax]
	sub	ecx, eax
	mov	eax, 1431655766				; 55555556H
	sub	ecx, r8d
	sub	ecx, r9d
	add	ecx, r10d
	add	ecx, ebx
	imul	ecx
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	edx, edx
	add	edx, r11d
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	call	sqrt
	cvttsd2si eax, xmm0
	mov	BYTE PTR [r14+rbp], al
	mov	rax, QWORD PTR tv9622[rsp]
	movzx	ebx, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9585[rsp]
	movzx	r9d, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9621[rsp]
	movzx	r10d, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9584[rsp]
	movzx	r8d, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9586[rsp]
	movzx	ecx, BYTE PTR [r14+rax]
	movzx	eax, BYTE PTR [r14+rdi]
	sub	ecx, eax
	mov	eax, 1431655766				; 55555556H
	sub	ecx, ebx
	sub	ecx, r9d
	add	ecx, r10d
	add	ecx, r8d
	imul	ecx
	mov	rax, QWORD PTR tv9620[rsp]
	mov	r11d, edx
	shr	r11d, 31
	add	r11d, edx
	movzx	ecx, BYTE PTR [r14+rax]
	mov	rax, QWORD PTR tv9583[rsp]
	movzx	eax, BYTE PTR [r14+rax]
	sub	ecx, eax
	mov	eax, 1431655766				; 55555556H
	sub	ecx, r8d
	sub	ecx, r9d
	add	ecx, r10d
	add	ecx, ebx
	imul	ecx
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	edx, edx
	imul	r11d, r11d
	add	edx, r11d
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	call	sqrt
	mov	rcx, QWORD PTR tv9581[rsp]
	cvttsd2si eax, xmm0
	mov	BYTE PTR [r14+rcx], al
	add	r14, QWORD PTR tv9645[rsp]
	sub	QWORD PTR tv9671[rsp], 1
	jne	$LL67@vc_binary_

; 989  : 	{
; 990  : 		for (x = 1; x < width - 1; x++)

	mov	r10d, DWORD PTR x$1$[rsp]
	mov	r15d, DWORD PTR tv9672[rsp]
	movsxd	r12, DWORD PTR channels$1$[rsp]
	mov	rsi, QWORD PTR tv9626[rsp]
	mov	rdi, r12
	mov	r13d, DWORD PTR tv9627[rsp]
	mov	rbp, QWORD PTR datadst$1$[rsp]
	mov	rbx, QWORD PTR datasrc$1$[rsp]
	mov	edx, DWORD PTR tv9593[rsp]
	cmp	r10d, r15d
	jge	$LN98@vc_binary_
$LC66@vc_binary_:
	lea	r9d, DWORD PTR [rdx+r13]
	mov	ecx, r10d
	mov	edx, DWORD PTR tv9596[rsp]
	lea	r8d, DWORD PTR [r10+1]
	imul	ecx, r12d
	add	edx, r13d
	imul	r8d, r12d
	lea	eax, DWORD PTR [r9+rcx]
	movsxd	r14, eax
	lea	eax, DWORD PTR [rcx+r13]
	add	r14, rbp
	movsxd	rbp, eax
	lea	eax, DWORD PTR [rdx+rcx]
	add	rbp, rbx
	movsxd	r15, eax
	lea	ecx, DWORD PTR [r10-1]
	imul	ecx, DWORD PTR channels$1$[rsp]
	lea	eax, DWORD PTR [rdx+r8]
	movsxd	r12, eax
	add	r15, rbx
	lea	eax, DWORD PTR [r8+r13]
	add	r12, rbx
	movsxd	r13, eax
	add	r13, rbx
	lea	eax, DWORD PTR [rdx+rcx]
	movsxd	rsi, eax
	mov	eax, DWORD PTR tv9627[rsp]
	add	rsi, rbx
	add	eax, ecx
	movsxd	rdx, eax
	lea	eax, DWORD PTR [r9+r8]
	movsxd	r11, eax
	add	rdx, rbx
	lea	eax, DWORD PTR [r9+rcx]
	mov	QWORD PTR tv9638[rsp], rdx
	movsxd	rcx, eax
	add	r11, rbx
	add	rcx, rbx
	mov	QWORD PTR tv9637[rsp], r11
	mov	QWORD PTR tv9636[rsp], rcx
	mov	ecx, DWORD PTR tv9672[rsp]
	mov	rax, QWORD PTR tv9636[rsp]
	sub	ecx, r10d
	mov	QWORD PTR tv9628[rsp], rcx
$LC86@vc_binary_:

; 1018 : 			sumx += datasrc[posD] * -1;

	movzx	eax, BYTE PTR [rax]

; 1019 : 			sumx += datasrc[posF] * -1;

	movzx	ebx, BYTE PTR [rdx]

; 1020 : 
; 1021 : 			sumx += datasrc[posC] * +1;
; 1022 : 			sumx += datasrc[posE] * +1;

	movzx	ecx, BYTE PTR [r11]
	movzx	r9d, BYTE PTR [rsi]
	sub	ecx, eax
	movzx	r8d, BYTE PTR [r12]
	sub	ecx, r9d

; 1023 : 			sumx += datasrc[posH] * +1;

	movzx	r10d, BYTE PTR [r13]
	sub	ecx, ebx
	add	ecx, r8d

; 1024 : 			sumx = sumx / 3; // 3 = 1 + 1 + 1

	mov	eax, 1431655766				; 55555556H
	add	ecx, r10d
	imul	ecx

; 1025 : 			// magnitude = 3
; 1026 : 
; 1027 : 			sumy = datasrc[posA] * -1;
; 1028 : 			sumy += datasrc[posB] * -1;

	movzx	eax, BYTE PTR [r15]

; 1029 : 			sumy += datasrc[posC] * -1;
; 1030 : 
; 1031 : 			sumy += datasrc[posF] * +1;
; 1032 : 			sumy += datasrc[posG] * +1;

	movzx	ecx, BYTE PTR [rbp]
	mov	r11d, edx
	sub	ecx, eax
	shr	r11d, 31
	add	r11d, edx
	sub	ecx, r8d
	sub	ecx, r9d

; 1033 : 			sumy += datasrc[posH] * +1;
; 1034 : 			sumy = sumy / 3; // 3 = 1 + 1 + 1
; 1035 : 			// magnitude = 3
; 1036 : 
; 1037 : 			// Calcular a magnitude do vector:
; 1038 : 			datadst[posX] = (unsigned char)sqrt((double)(sumx * sumx + sumy * sumy));

	imul	r11d, r11d
	add	ecx, r10d
	mov	eax, 1431655766				; 55555556H
	add	ecx, ebx
	imul	ecx
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	edx, edx
	add	edx, r11d
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	call	sqrt
	mov	rdx, QWORD PTR tv9638[rsp]
	add	rsi, rdi
	mov	r11, QWORD PTR tv9637[rsp]
	add	rdx, rdi
	cvttsd2si eax, xmm0
	add	r11, rdi
	mov	QWORD PTR tv9638[rsp], rdx
	add	r13, rdi
	mov	QWORD PTR tv9637[rsp], r11
	add	r12, rdi
	add	r15, rdi
	add	rbp, rdi
	mov	BYTE PTR [r14], al
	add	r14, rdi
	mov	rax, QWORD PTR tv9636[rsp]
	add	rax, rdi
	sub	QWORD PTR tv9628[rsp], 1
	mov	QWORD PTR tv9636[rsp], rax
	jne	$LC86@vc_binary_

; 989  : 	{
; 990  : 		for (x = 1; x < width - 1; x++)

	mov	rsi, QWORD PTR tv9626[rsp]
	mov	r13d, DWORD PTR tv9627[rsp]
	mov	rbx, QWORD PTR datasrc$1$[rsp]
	mov	r12d, DWORD PTR channels$1$[rsp]
	mov	rbp, QWORD PTR datadst$1$[rsp]
	mov	r15d, DWORD PTR tv9672[rsp]
	mov	edx, DWORD PTR tv9593[rsp]
$LN98@vc_binary_:

; 987  : 
; 988  : 	for (y = 1; y < height - 1; y++)

	mov	r14, QWORD PTR tv9606[rsp]
	mov	r9, QWORD PTR tv9603[rsp]
	mov	rax, QWORD PTR tv9599[rsp]
	mov	r8, QWORD PTR tv9568[rsp]
	mov	r11d, DWORD PTR bytesperline$1$[rsp]
$LN2@vc_binary_:
	add	r13d, r11d
	add	rsi, rax
	sub	QWORD PTR tv9601[rsp], 1
	mov	DWORD PTR tv9627[rsp], r13d
	mov	QWORD PTR tv9626[rsp], rsi
	jne	$LL4@vc_binary_
	mov	edi, DWORD PTR width$1$[rsp]
	mov	edx, DWORD PTR height$1$[rsp]
	mov	esi, DWORD PTR tv9660[rsp]
	jmp	SHORT $LN3@vc_binary_
$LN99@vc_binary_:
	mov	r11d, DWORD PTR bytesperline$1$[rsp]
$LN3@vc_binary_:

; 1039 : 			//datadst[posX] = (unsigned char) (sqrt((double) (sumx*sumx + sumy*sumy)) / 4.0);
; 1040 : 		}
; 1041 : 	}
; 1042 : 
; 1043 : 	// Compute a grey level histogram
; 1044 : 	for (y = 0; y < height; y++)

	test	edx, edx
	jle	SHORT $LN9@vc_binary_
	movsxd	rbx, r11d
	mov	r9, rbp
	mov	r10d, edx
	npad	5
$LL10@vc_binary_:

; 1045 : 	{
; 1046 : 		for (x = 0; x < width; x++)

	test	edi, edi
	jle	SHORT $LN8@vc_binary_

; 1047 : 		{
; 1048 : 			hist[datadst[y * bytesperline + x * channels]]++;

	movsxd	r8, r12d
	mov	rcx, r9
	mov	edx, edi
	npad	4
$LL13@vc_binary_:
	movzx	eax, BYTE PTR [rcx]
	add	rcx, r8
	inc	DWORD PTR hist$[rsp+rax*4]
	sub	rdx, 1
	jne	SHORT $LL13@vc_binary_
$LN8@vc_binary_:

; 1039 : 			//datadst[posX] = (unsigned char) (sqrt((double) (sumx*sumx + sumy*sumy)) / 4.0);
; 1040 : 		}
; 1041 : 	}
; 1042 : 
; 1043 : 	// Compute a grey level histogram
; 1044 : 	for (y = 0; y < height; y++)

	add	r9, rbx
	sub	r10, 1
	jne	SHORT $LL10@vc_binary_
	mov	edx, DWORD PTR height$1$[rsp]
$LN9@vc_binary_:

; 1049 : 		}
; 1050 : 	}
; 1051 : 
; 1052 : 	// Threshold at the middle of the occupied levels
; 1053 : 	histmax = 0;

	xor	r14d, r14d
	movd	xmm1, esi
	cvtdq2ps xmm1, xmm1
	mov	eax, r14d

; 1054 : 	for (i = 0; i <= 255; i++)

	mov	r9d, r14d
	mov	ecx, r14d
	mulss	xmm1, xmm6
	npad	9
$LL16@vc_binary_:

; 1055 : 	{
; 1056 : 		histmax += hist[i];

	add	eax, DWORD PTR hist$[rsp+rcx*4]
	movd	xmm0, eax

; 1057 : 
; 1058 : 		// th = Prewitt Threshold
; 1059 : 		if (histmax >= (((float)size) * th))

	cvtdq2ps xmm0, xmm0
	comiss	xmm0, xmm1
	jae	SHORT $LN71@vc_binary_
	add	eax, DWORD PTR hist$[rsp+rcx*4+4]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	comiss	xmm0, xmm1
	jae	SHORT $LN68@vc_binary_
	add	eax, DWORD PTR hist$[rsp+rcx*4+8]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	comiss	xmm0, xmm1
	jae	SHORT $LN69@vc_binary_
	add	eax, DWORD PTR hist$[rsp+rcx*4+12]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	comiss	xmm0, xmm1
	jae	SHORT $LN70@vc_binary_

; 1054 : 	for (i = 0; i <= 255; i++)

	add	rcx, 4
	add	r9d, 4
	cmp	rcx, 255				; 000000ffH
	jle	SHORT $LL16@vc_binary_
	jmp	SHORT $LN71@vc_binary_
$LN70@vc_binary_:

; 1057 : 
; 1058 : 		// th = Prewitt Threshold
; 1059 : 		if (histmax >= (((float)size) * th))

	add	r9d, 3
	jmp	SHORT $LN71@vc_binary_
$LN69@vc_binary_:
	add	r9d, 2
	jmp	SHORT $LN71@vc_binary_
$LN68@vc_binary_:
	inc	r9d
$LN71@vc_binary_:

; 1063 : 	//vc_gray_to_binary_bernsen(datadst, , <#int kernel#>, <#int c#>)
; 1064 : 
; 1065 : 	// Apply the threshold
; 1066 : 	for (y = 0; y < height; y++)

	test	edx, edx
	jle	SHORT $LN18@vc_binary_

; 1060 : 			break;
; 1061 : 	}
; 1062 : 	histthreshold = i;

	movsxd	rbx, r11d
	mov	r11d, edx
$LL19@vc_binary_:

; 1067 : 	{
; 1068 : 		for (x = 0; x < width; x++)

	test	edi, edi
	jle	SHORT $LN17@vc_binary_
	movsxd	r10, r12d
	mov	rdx, rbp
	mov	r8d, edi
	npad	11
$LL22@vc_binary_:

; 1069 : 		{
; 1070 : 			posX = y * bytesperline + x * channels;
; 1071 : 
; 1072 : 			// Aplica threshold: -> Se a Magnitude(x,y) > th entao é pixel de contorno
; 1073 : 			// datadst[posX] = Magnitude  &&  histthreshold = th
; 1074 : 			if (datadst[posX] >= histthreshold)

	movzx	eax, BYTE PTR [rdx]
	mov	ecx, 255				; 000000ffH
	cmp	eax, r9d
	cmovl	ecx, r14d
	mov	BYTE PTR [rdx], cl
	add	rdx, r10
	sub	r8, 1
	jne	SHORT $LL22@vc_binary_
$LN17@vc_binary_:

; 1063 : 	//vc_gray_to_binary_bernsen(datadst, , <#int kernel#>, <#int c#>)
; 1064 : 
; 1065 : 	// Apply the threshold
; 1066 : 	for (y = 0; y < height; y++)

	add	rbp, rbx
	sub	r11, 1
	jne	SHORT $LL19@vc_binary_
$LN18@vc_binary_:

; 1075 : 				datadst[posX] = 255;
; 1076 : 			else
; 1077 : 				datadst[posX] = 0;
; 1078 : 		}
; 1079 : 	}
; 1080 : 	return 1;

	mov	eax, 1
	jmp	SHORT $LN1@vc_binary_
$LN24@vc_binary_:

; 980  : 		return 0;

	xor	eax, eax
$LN1@vc_binary_:

; 1081 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+1488]
	movaps	xmm6, XMMWORD PTR [rsp+1392]
	add	rsp, 1408				; 00000580H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
vc_binary_edge_prewitt ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_trab_clean
_TEXT	SEGMENT
original$ = 16
converted$ = 24
license_line$ = 32
percent$ = 40
vc_trab_clean PROC					; COMDAT

; 1386 : {

$LN31:
	sub	rsp, 8
	xorps	xmm0, xmm0
	mov	r11, rdx

; 1387 : 	int x, y, pos;
; 1388 : 
; 1389 : 	if (percent <= 0)

	comiss	xmm0, xmm3
	mov	r9, rcx
	jb	SHORT $LN8@vc_trab_cl

; 1390 : 		return 0;

	xor	eax, eax

; 1409 : }

	add	rsp, 8
	ret	0
$LN8@vc_trab_cl:

; 1391 : 
; 1392 : 	//Calcula as percentagens
; 1393 : 	percent /= 100;
; 1394 : 	int aux = original->height * percent;

	mov	edx, DWORD PTR [rcx+12]
	mov	eax, r8d
	divss	xmm3, DWORD PTR __real@42c80000
	mov	QWORD PTR [rsp], rdi

; 1395 : 	float min = license_line - aux >= 0 ? license_line - aux : 0,

	mov	edi, 0

; 1396 : 		max = license_line + aux <= original->height ? license_line + aux : original->height;
; 1397 : 
; 1398 : 	for (y = 0; y < original->height; y++)

	mov	r10d, edi
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0
	mulss	xmm3, xmm0
	cvttss2si ecx, xmm3
	sub	eax, ecx
	cmovs	eax, edi
	movd	xmm2, eax
	lea	eax, DWORD PTR [rcx+r8]
	cmp	eax, edx
	cvtdq2ps xmm2, xmm2
	cmovg	eax, edx
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	test	edx, edx
	jle	$LN3@vc_trab_cl
	mov	QWORD PTR [rsp+16], rbx
	mov	ebx, 255				; 000000ffH
$LL4@vc_trab_cl:

; 1399 : 		for (x = 0; x < original->width; x++)

	mov	r8d, edi
	cmp	DWORD PTR [r9+8], edi
	jle	SHORT $LN2@vc_trab_cl
	movd	xmm0, r10d
	cvtdq2ps xmm0, xmm0
	npad	15
$LL7@vc_trab_cl:

; 1400 : 		{
; 1401 : 			pos = y * original->bytesperline + x * original->channels;

	mov	ecx, DWORD PTR [r9+16]
	mov	eax, DWORD PTR [r9+24]
	imul	ecx, r8d
	imul	eax, r10d
	add	ecx, eax

; 1402 : 			if (y <= min || y >= max)

	comiss	xmm2, xmm0
	jae	SHORT $LN26@vc_trab_cl
	comiss	xmm0, xmm1
	jae	SHORT $LN26@vc_trab_cl

; 1404 : 			else
; 1405 : 				converted->data[pos] = original->data[pos] == 255 ? 255 : original->data[pos];

	mov	rax, QWORD PTR [r9]
	movsxd	rdx, ecx
	movzx	ecx, BYTE PTR [rdx+rax]
	mov	rax, QWORD PTR [r11]
	cmp	cl, bl
	cmove	ecx, ebx
	mov	BYTE PTR [rdx+rax], cl
	jmp	SHORT $LN5@vc_trab_cl
$LN26@vc_trab_cl:

; 1403 : 				converted->data[pos] = 0;

	mov	rax, QWORD PTR [r11]
	movsxd	rcx, ecx
	mov	BYTE PTR [rcx+rax], dil
$LN5@vc_trab_cl:

; 1399 : 		for (x = 0; x < original->width; x++)

	inc	r8d
	cmp	r8d, DWORD PTR [r9+8]
	jl	SHORT $LL7@vc_trab_cl
$LN2@vc_trab_cl:

; 1396 : 		max = license_line + aux <= original->height ? license_line + aux : original->height;
; 1397 : 
; 1398 : 	for (y = 0; y < original->height; y++)

	inc	r10d
	cmp	r10d, DWORD PTR [r9+12]
	jl	SHORT $LL4@vc_trab_cl
	mov	rbx, QWORD PTR [rsp+16]
$LN3@vc_trab_cl:

; 1406 : 		}
; 1407 : 
; 1408 : 	return 1;

	mov	rdi, QWORD PTR [rsp]
	mov	eax, 1

; 1409 : }

	add	rsp, 8
	ret	0
vc_trab_clean ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Sergio\Desktop\vc_teste\temp\temp\vc.c
;	COMDAT vc_trab_prewitt
_TEXT	SEGMENT
tv1141 = 32
width$1$ = 36
height$1$ = 40
$T1 = 48
$T2 = 56
tv1137 = 64
tv1158 = 72
original$ = 160
converted$ = 168
x$1$ = 176
tv1204 = 184
vc_trab_prewitt PROC					; COMDAT

; 1711 : {

$LN30:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	r13
	sub	rsp, 136				; 00000088H

; 1712 : 	int x, y, pos;
; 1713 : 	int width = original->width, height = original->height;

	movsxd	rax, DWORD PTR [rcx+8]

; 1714 : 	int yUp = 0, yDown = 0, xLeft = 0, xRight = 0;
; 1715 : 	int gx, gy, edge;
; 1716 : 
; 1717 : 	for (y = 0; y < original->height; y++)

	xor	esi, esi
	mov	r11, rcx
	mov	DWORD PTR width$1$[rsp], eax
	mov	ecx, DWORD PTR [rcx+12]
	mov	r9, rax
	mov	DWORD PTR height$1$[rsp], ecx
	mov	r13d, esi
	test	ecx, ecx
	jle	$LN28@vc_trab_pr
	mov	QWORD PTR [rsp+128], rbx
	mov	edx, esi
	mov	QWORD PTR [rsp+120], rbp
	mov	r10, rax
	mov	QWORD PTR [rsp+112], rdi
	mov	QWORD PTR [rsp+104], r12
	mov	QWORD PTR [rsp+96], r14
	mov	QWORD PTR [rsp+88], r15
	mov	QWORD PTR tv1158[rsp], rax
	mov	QWORD PTR $T2[rsp], rdx
	npad	10
$LL4@vc_trab_pr:

; 1718 : 		for (x = 0; x < original->width; x++)

	mov	QWORD PTR $T1[rsp], rsi
	mov	ebx, esi
	mov	DWORD PTR x$1$[rsp], ebx
	test	eax, eax
	jle	$LN2@vc_trab_pr

; 1721 : 			//
; 1722 : 			yUp = MAX(y - 1, 0) * original->bytesperline;
; 1723 : 			yDown = MIN(y + 1, height - 1) * original->bytesperline;

	lea	eax, DWORD PTR [rcx-1]
	lea	ecx, DWORD PTR [r13+1]
	cmp	ecx, eax
	lea	edi, DWORD PTR [r9-1]
	lea	r8d, DWORD PTR [r13-1]
	mov	DWORD PTR tv1204[rsp], edi
	cmovge	ecx, eax
	lea	rax, QWORD PTR [r10+rdx]
	mov	QWORD PTR tv1137[rsp], rax
	mov	DWORD PTR tv1141[rsp], ecx
	npad	2
$LL7@vc_trab_pr:

; 1724 : 			xLeft = MAX(x - 1, 0);

	mov	r12d, DWORD PTR [r11+24]
	lea	r10d, DWORD PTR [rbx-1]
	test	r8d, r8d

; 1725 : 			xRight = MAX(x + 1, width - 1);

	lea	r15d, DWORD PTR [rbx+1]
	mov	r9d, r8d

; 1726 : 
; 1727 : 			//Horizontal
; 1728 : 			//| -1 0 +1 |
; 1729 : 			//| -1 0 +1 |
; 1730 : 			//| -1 0 +1 |
; 1731 : 			gx = original->data[yUp + xRight] * -1;
; 1732 : 			gx += original->data[y + xRight] * -1;

	mov	edx, r15d
	cmovle	r9d, esi
	mov	r8d, ecx
	mov	rsi, QWORD PTR [r11]
	imul	r8d, r12d
	imul	r9d, r12d
	cmp	r15d, edi
	cmovle	edx, edi

; 1733 : 			gx += original->data[yDown + xRight] * -1;
; 1734 : 			//
; 1735 : 			gx += original->data[yUp + xLeft] * 1;
; 1736 : 			gx += original->data[y + xLeft] * 1;
; 1737 : 			gx += original->data[yDown + xLeft] * 1;

	test	r10d, r10d
	lea	eax, DWORD PTR [rdx+r8]
	movsxd	rcx, eax
	lea	edi, DWORD PTR [r8+rbx]
	lea	eax, DWORD PTR [rdx+r9]
	mov	rdx, QWORD PTR tv1137[rsp]
	movzx	ebp, BYTE PTR [rcx+rsi]
	movsxd	rcx, eax
	lea	eax, DWORD PTR [rdi-1]
	cmovle	eax, r8d
	mov	r8d, DWORD PTR x$1$[rsp]
	cdqe
	add	r8d, r9d
	test	r10d, r10d
	movzx	r14d, BYTE PTR [rcx+rsi]
	movzx	ebx, BYTE PTR [rax+rsi]
	lea	eax, DWORD PTR [r8-1]
	cmovle	eax, r9d
	mov	r9, QWORD PTR $T2[rsp]
	cdqe
	dec	rdx
	add	rdx, rsi
	lea	rcx, QWORD PTR [r9+1]
	movzx	r11d, BYTE PTR [rax+rsi]
	mov	rax, QWORD PTR $T1[rsp]
	add	rax, rsi
	add	rcx, rax
	mov	rax, QWORD PTR $T1[rsp]
	cmp	r15d, DWORD PTR tv1204[rsp]
	cmovle	rcx, rdx
	dec	rax
	add	rax, r9
	test	r10d, r10d
	movzx	edx, BYTE PTR [rcx]
	cmovle	rax, r9
	movzx	ecx, BYTE PTR [rax+rsi]

; 1738 : 			//
; 1739 : 			gx = gx / 3; //Magnitude 3

	mov	eax, 1431655766				; 55555556H
	sub	ecx, edx
	sub	ecx, r14d
	sub	ecx, ebp
	add	ecx, r11d
	add	ecx, ebx
	imul	ecx

; 1740 : 
; 1741 : 			//Verical
; 1742 : 			//| -1 -1 -1 |
; 1743 : 			//| 0  0   0 |
; 1744 : 			//| +1 +1 +1 |
; 1745 : 			gy = original->data[yUp + xLeft] * 1;
; 1746 : 			gy += original->data[yUp + x] * 1;

	movsxd	rax, r8d
	mov	r9d, edx
	shr	r9d, 31
	add	r9d, edx
	movzx	r8d, BYTE PTR [rax+rsi]

; 1747 : 			gy += original->data[yUp + xRight] * 1;
; 1748 : 			//
; 1749 : 			gy += original->data[yDown + xLeft] * -1;
; 1750 : 			gy += original->data[yDown + x] * -1;

	movsxd	rax, edi

; 1751 : 			gy += original->data[yDown + xRight] * -1;
; 1752 : 			//
; 1753 : 			gy = gy / 3; //Magnitude 3
; 1754 : 
; 1755 : 			edge = (unsigned char)sqrt((float)(gx * gx + gy * gy));

	imul	r9d, r9d
	movzx	ecx, BYTE PTR [rax+rsi]
	mov	eax, 1431655766				; 55555556H
	sub	r8d, ecx
	sub	r8d, ebp
	sub	r8d, ebx
	add	r8d, r14d
	add	r8d, r11d
	imul	r8d
	mov	eax, edx
	shr	eax, 31
	add	edx, eax
	imul	edx, edx
	add	edx, r9d
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0
	cvtps2pd xmm0, xmm0
	call	sqrt
	cvttsd2si edx, xmm0

; 1718 : 		for (x = 0; x < original->width; x++)

	mov	eax, DWORD PTR x$1$[rsp]
	lea	r8d, DWORD PTR [r13-1]

; 1719 : 		{
; 1720 : 			pos = y * original->bytesperline + x * original->channels;

	mov	r11, QWORD PTR original$[rsp]
	mov	ebx, r15d
	inc	QWORD PTR $T1[rsp]
	mov	esi, 0
	mov	edi, DWORD PTR tv1204[rsp]
	imul	r12d, r13d
	imul	eax, DWORD PTR [r11+16]
	mov	DWORD PTR x$1$[rsp], ebx
	add	r12d, eax

; 1756 : 
; 1757 : 			//Verifica se é menor que 0 ou maior que 255
; 1758 : 			converted->data[pos] = edge < 0 ? 0 : edge > 255 ? 255 : edge;

	mov	rax, QWORD PTR converted$[rsp]
	movsxd	rcx, r12d
	mov	rax, QWORD PTR [rax]
	mov	BYTE PTR [rcx+rax], dl
	mov	eax, DWORD PTR [r11+8]
	mov	ecx, DWORD PTR tv1141[rsp]
	cmp	r15d, eax
	jl	$LL7@vc_trab_pr
	mov	rdx, QWORD PTR $T2[rsp]
	mov	r9d, DWORD PTR width$1$[rsp]
	mov	ecx, DWORD PTR height$1$[rsp]
	mov	r10, QWORD PTR tv1158[rsp]
$LN2@vc_trab_pr:

; 1714 : 	int yUp = 0, yDown = 0, xLeft = 0, xRight = 0;
; 1715 : 	int gx, gy, edge;
; 1716 : 
; 1717 : 	for (y = 0; y < original->height; y++)

	inc	rdx
	inc	r13d
	mov	QWORD PTR $T2[rsp], rdx
	cmp	r13d, DWORD PTR [r11+12]
	jl	$LL4@vc_trab_pr

; 1759 : 		}
; 1760 : 
; 1761 : 	return 0;

	mov	r15, QWORD PTR [rsp+88]
	mov	r14, QWORD PTR [rsp+96]
	mov	r12, QWORD PTR [rsp+104]
	mov	rdi, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+120]
	mov	rbx, QWORD PTR [rsp+128]
$LN28@vc_trab_pr:

; 1762 : }

	xor	eax, eax
	add	rsp, 136				; 00000088H
	pop	r13
	pop	rsi
	ret	0
vc_trab_prewitt ENDP
_TEXT	ENDS
END
